  Sun Nov 22 2015 10:55                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is indexed using the X register witch values held at
    27                        ; the same index offsets as they would be on the return stack. The Y register
    28                        ; holds the forth instruction pointer.
    29                        ;
    30                        ;==============================================================================
    31                        ;------------------------------------------------------------------------------
    32                        
    33                                        pw      132
    34                                        inclist on
    35                                        maclist off
    36                        
    37                                        chip    65816
    38                                        longi   off
    39                                        longa   off
    40                        
    41                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
  Sun Nov 22 2015 10:55                                                                                                    Page 2


    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;------------------------------------------------------------------------------
    25                        
    26                        ;==============================================================================
    27                        ; Status Register Bits
    28                        ;------------------------------------------------------------------------------
    29                        
    30             00000007   N_FLAG          equ     7
    31             00000006   V_FLAG          equ     6
    32             00000005   M_FLAG          equ     5
    33             00000004   X_FLAG          equ     4
    34             00000004   B_FLAG          equ     4
    35             00000003   D_FLAG          equ     3
    36             00000002   I_FLAG          equ     2
    37             00000001   Z_FLAG          equ     1
    38             00000000   C_FLAG          equ     0
    39                        
    40                        ;==============================================================================
    41                        ; Macros
    42                        ;------------------------------------------------------------------------------
    43                        
    44                        ; Puts the processor into emulation mode. A, X and Y become 8-bits and the
    45                        ; stack is fixed at $0100-$01ff. 
    46                        
    47                        emulate         macro
    48                                        sec
    49                                        xce
    50                                        endm
    51                        
    52                        ; Puts the processor into native mode. The size of the memory and index
    53                        ; register operations is controlled by the M & X bits in the status register.
    54                        
    55                        native          macro
    56                                        clc
    57                                        xce
    58                                        endm
    59                        
    60                        ; Resets the M bit making the accumator and memory accesses 16-bits wide.
    61                         
    62                        long_a          macro
    63                                        rep     #(1<<M_FLAG)
    64                                        longa   on
    65                                        endm
    66                        
    67                        ; Resets the X bit making the index registers 16-bits wide
    68                        
    69                        long_i          macro
  Sun Nov 22 2015 10:55                                                                                                    Page 3


    70                                        rep     #(1<<X_FLAG)
    71                                        longi   on
    72                                        endm
    73                        
    74                        ; Resets the M and X bits making the accumator, memory accesses and index
    75                        ; registers 16-bits wide.
    76                                        
    77                        long_ai         macro
    78                                        rep     #(1<<M_FLAG)|(1<<X_FLAG)
    79                                        longa   on
    80                                        longi   on
    81                                        endm
    82                        
    83                        ; Sets the M bit making the accumator and memory accesses 16-bits wide.
    84                        
    85                        short_a         macro
    86                                        sep     #(1<<M_FLAG)
    87                                        longa   off
    88                                        endm
    89                        
    90                        ; Sets the X bit making the index registers 8-bits wide
    91                        
    92                        short_i         macro
    93                                        sep     #(1<<X_FLAG)
    94                                        longi   off
    95                                        endm
    96                                        
    97                        ; Sets the M and X bits making the accumator, memory accesses and index
    98                        ; registers 8-bits wide.
    99                        
   100                        short_ai        macro
   101                                        sep     #(1<<M_FLAG)|(1<<X_FLAG)
   102                                        longa   off
   103                                        longi   off
   104                                        endm
    42                        
    43                        ;==============================================================================
    44                        ; Macros
    45                        ;------------------------------------------------------------------------------
    46                        
    47             00000000   COUNT           set     0                       ; Word counter
    48             00000000   WORD0           equ     0                       ; Null address for first word
    49                        
    50                        HEADER          macro   TYPE
    51                        WORD@<COUNT+1>:
    52                                        dw      WORD@<COUNT>
    53                                        db      TYPE
    54                        COUNT           set     COUNT+1
    55                                        endm
    56                        
    57             00000000   NORMAL          equ     $00
    58             00000080   IMMEDIATE       equ     $80
    59                        
    60                        TRAILER         macro
    61                        LAST_WORD       equ     WORD@<COUNT>
    62                                        endm
    63                        
    64                        ;==============================================================================
  Sun Nov 22 2015 10:55                                                                                                    Page 4


    65                        ; Definitions
    66                        ;------------------------------------------------------------------------------
    67                        
    68             00000080   DSTACK_SIZE     equ     128
    69             00000081   DSTACK_INIT     equ     DSTACK+DSTACK_SIZE-1
    70             000001FF   RSTACK_INIT     equ     $01ff
    71                        
    72             00000014   USER_SIZE       equ     20
    73                        
    74             00000000   TO_IN_OFFSET    equ     0
    75             00000002   BASE_OFFSET     equ     2
    76             00000004   BLK_OFFSET      equ     4
    77             00000006   DP_OFFSET       equ     6
    78             00000008   LATEST_OFFSET   equ     8
    79             0000000A   SCR_OFFSET      equ     10
    80             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
    81             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
    82             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
    83             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
    84                        
    85             00000080   TIB_SIZE        equ     128
    86                        
    87                        ;==============================================================================
    88                        ; Data Areas
    89                        ;------------------------------------------------------------------------------
    90                        
    91                                        page0
    92                                        org     $00
    93                        
    94 00:0000:              WA              ds      2                       ; Word address
    95                        
    96 00:0002:              DSTACK          ds      DSTACK_SIZE             ; The data stack (indexed by X)
    97                        
    98                                        data
    99                                        org     $210
   100                        
   101 00:0210:              USER_AREA       ds      USER_SIZE               ; User Variables
   102                        
   103 00:0224:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   104                        
   105                        ;==============================================================================
   106                        ; Forth Entry Point
   107                        ;------------------------------------------------------------------------------
   108                        
   109                        FORTH           section OFFSET $0400
   110                        
   111                                        public  Start
   112                        Start:
   113 00:0400: 18 FB                        native                          ; Go to native mode
   114 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   115 00:0404: A9 FF 01                     lda     #RSTACK_INIT            ; Initialise return stack
   116 00:0407: 1B                           tcs
   117 00:0408: A2 81 00                     ldx     #DSTACK_INIT            ; .. and data stack
   118                        
   119 00:040B: A0 11 04                     ldy     #COLD                   ; Then perform COLD start
   120 00:040E: 4C FA 0C                     jmp     NEXT
   121                        
   122                        COLD:
  Sun Nov 22 2015 10:55                                                                                                    Page 5


   123 00:0411: 44 05                        dw      DECIMAL
   124 00:0413: 00 05 80 04                  dw      ZERO,BLK,STORE
       00:0417: 6A 05 
   125 00:0419: 20 05 EA 04                  dw      FALSE,STATE,STORE
       00:041D: 6A 05 
   126 00:041F: 75 0E 75 0E                  dw      CR,CR,DO_S_QUOTE
       00:0423: 55 0E 
   127 00:0425: 23 48 61 6E                  db      35,"HandCoded W65C816 ANS-Forth [15.11]"
       00:0429: 64 43 6F 64 
       00:042D: 65 64 20 57 
       00:0431: 36 35 43 38 
       00:0435: 31 36 20 41 
       00:0439: 4E 53 2D 46 
       00:043D: 6F 72 74 68 
       00:0441: 20 5B 31 35 
       00:0445: 2E 31 31 5D 
   128 00:0449: E7 0E 75 0E                  dw      TYPE,CR,CR
       00:044D: 75 0E 
   129 00:044F: E8 09                        dw      ABORT
   130                        
   131                        ;==============================================================================
   132                        ; System/User Variables
   133                        ;------------------------------------------------------------------------------
   134                        
   135                        ; #TIB ( -- a-addr )
   136                        ;
   137                        ; a-addr is the address of a cell containing the number of characters in the
   138                        ; terminal input buffer.
   139                        
   140 00:0451: 00 00 00                     HEADER  NORMAL
   141 00:0454: 04 23 54 49                  db      4,"#TIB"
       00:0458: 42 
   142 00:0459: 4C 45 0D     HASH_TIB:       jmp     DO_CONSTANT
   143 00:045C: 5E 04                        dw      $+2
   144 00:045E: 7E 00                        dw      TIB_SIZE-2
   145                        
   146                        ; >IN ( -- a-addr )
   147                        ;
   148                        ; a-addr is the address of a cell containing the offset in characters from the
   149                        ; start of the input buffer to the start of the parse area.
   150                        
   151 00:0460: 51 04 00                     HEADER  NORMAL
   152 00:0463: 03 3E 49 4E                  db      3,">IN"
   153 00:0467: 4C 14 0E     TO_IN:          jmp     DO_USER
   154 00:046A: 00 00                        dw      TO_IN_OFFSET
   155                        
   156                        ; BASE ( -- a-addr )
   157                        ;
   158                        ; a-addr is the address of a cell containing the current number-conversion
   159                        ; radix {{2...36}}.
   160                        
   161 00:046C: 60 04 00                     HEADER  NORMAL
   162 00:046F: 04 42 41 53                  db      4,"BASE"
       00:0473: 45 
   163 00:0474: 4C 14 0E     BASE:           jmp     DO_USER
   164 00:0477: 02 00                        dw      BASE_OFFSET
   165                        
   166                        ; BLK ( -- a-addr )
  Sun Nov 22 2015 10:55                                                                                                    Page 6


   167                        ;
   168                        ; a-addr is the address of a cell containing zero or the number of the mass-
   169                        ; storage block being interpreted. If BLK contains zero, the input source is
   170                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   171                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   172                        
   173 00:0479: 6C 04 00                     HEADER  NORMAL
   174 00:047C: 03 42 4C 4B                  db      3,"BLK"
   175 00:0480: 4C 14 0E     BLK:            jmp     DO_USER
   176 00:0483: 04 00                        dw      BLK_OFFSET
   177                        
   178                        ; (BUFFER)
   179                        
   180 00:0485: 79 04 00                     HEADER  NORMAL
   181 00:0488: 08 28 42 55                  db      8,"(BUFFER)"
       00:048C: 46 46 45 52 
       00:0490: 29 
   182 00:0491: 4C 14 0E     BUFFER:         jmp     DO_USER
   183 00:0494: 10 00                        dw      BUFFER_OFFSET
   184                        
   185                        ; DP ( -- a-addr )
   186                        
   187 00:0496: 85 04 00                     HEADER  NORMAL
   188 00:0499: 02 44 50                     db      2,"DP"
   189 00:049C: 4C 14 0E     DP:             jmp     DO_USER
   190 00:049F: 06 00                        dw      DP_OFFSET
   191                        
   192                        ; LATEST ( -- a-addr )
   193                        
   194 00:04A1: 96 04 00                     HEADER  NORMAL
   195 00:04A4: 06 4C 41 54                  db      6,"LATEST"
       00:04A8: 45 53 54 
   196 00:04AB: 4C 14 0E     LATEST:         jmp     DO_USER
   197 00:04AE: 08 00                        dw      LATEST_OFFSET
   198                        
   199                        ; (LENGTH)
   200                        
   201 00:04B0: A1 04 00                     HEADER  NORMAL
   202 00:04B3: 08 28 4C 45                  db      8,"(LENGTH)"
       00:04B7: 4E 47 54 48 
       00:04BB: 29 
   203 00:04BC: 4C 14 0E     LENGTH:         jmp     DO_USER
   204 00:04BF: 12 00                        dw      LENGTH_OFFSET
   205                        
   206                        ; SCR ( -- a-addr )
   207                        ;
   208                        ; a-addr is the address of a cell containing the block number of the block most
   209                        ; recently LISTed.
   210                        
   211 00:04C1: B0 04 00                     HEADER  NORMAL
   212 00:04C4: 03 53 43 52                  db      3,"SCR"
   213 00:04C8: 4C 14 0E     SCR:            jmp     DO_USER
   214 00:04CB: 0A 00                        dw      SCR_OFFSET
   215                        
   216                        ; (SOURCE-ID)
   217                        
   218 00:04CD: C1 04 00                     HEADER  NORMAL
   219 00:04D0: 0B 28 53 4F                  db      11,"(SOURCE-ID)"
  Sun Nov 22 2015 10:55                                                                                                    Page 7


       00:04D4: 55 52 43 45 
       00:04D8: 2D 49 44 29 
   220 00:04DC: 4C 14 0E     SOURCEID:       jmp     DO_USER
   221 00:04DF: 0C 00                        dw      SOURCEID_OFFSET
   222                        
   223                        ; STATE ( -- a-addr )
   224                        ;
   225                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   226                        ; is true when in compilation state, false otherwise. The true value in STATE
   227                        ; is non-zero, but is otherwise implementation-defined.
   228                        
   229 00:04E1: CD 04 00                     HEADER  NORMAL
   230 00:04E4: 05 53 54 41                  db      5,"STATE"
       00:04E8: 54 45 
   231 00:04EA: 4C 14 0E     STATE:          jmp     DO_USER
   232 00:04ED: 0E 00                        dw      STATE_OFFSET
   233                        
   234                        ; TIB ( -- c-addr )
   235                        ;
   236                        ; c-addr is the address of the terminal input buffer.
   237                        
   238 00:04EF: E1 04 00                     HEADER  NORMAL
   239 00:04F2: 03 54 49 42                  db      3,"TIB"
   240 00:04F6: 4C 45 0D     TIB:            jmp     DO_CONSTANT
   241 00:04F9: 24 02                        dw      TIB_AREA
   242                        
   243                        ;==============================================================================
   244                        ; Constants
   245                        ;------------------------------------------------------------------------------
   246                        
   247                        ; 0 ( -- 0 )
   248                        ;
   249                        ; Push the constant value zero on the stack
   250                        
   251 00:04FB: EF 04 00                     HEADER  NORMAL
   252 00:04FE: 01 30                        db      1,"0"
   253                        ZERO:
   254 00:0500: CA                           dex                             ; Make space on the stack
   255 00:0501: CA                           dex
   256 00:0502: 74 03                        stz     DSTACK+1,X              ; And create a zero value
   257 00:0504: 4C FA 0C                     jmp     NEXT                    ; Done
   258                        
   259                        ; BL ( -- char )
   260                        ;
   261                        ; char is the character value for a space.
   262                        
   263 00:0507: FB 04 00                     HEADER  NORMAL
   264 00:050A: 02 42 4C                     db      2,"BL"
   265                        BL:
   266 00:050D: CA                           dex                             ; Make space on the stack
   267 00:050E: CA                           dex
   268 00:050F: A9 20 00                     lda     #' '                    ; And save a space value
   269 00:0512: 95 03                        sta     DSTACK+1,x
   270 00:0514: 4C FA 0C                     jmp     NEXT                    ; Done
   271                        
   272                        ; FALSE ( -- false )
   273                        ;
   274                        ; Return a false flag.
  Sun Nov 22 2015 10:55                                                                                                    Page 8


   275                        
   276 00:0517: 07 05 00                     HEADER  NORMAL
   277 00:051A: 05 46 41 4C                  db      5,"FALSE"
       00:051E: 53 45 
   278                        FALSE:
   279 00:0520: CA                           dex                             ; Make space on the stack
   280 00:0521: CA                           dex
   281 00:0522: 74 03                        stz     DSTACK+1,X              ; And create a false value
   282 00:0524: 4C FA 0C                     jmp     NEXT                    ; Done
   283                        
   284                        ; TRUE ( -- true )
   285                        ;
   286                        ; Return a true flag, a single-cell value with all bits set.
   287                        
   288 00:0527: 17 05 00                     HEADER  NORMAL
   289 00:052A: 04 54 52 55                  db      4,"TRUE"
       00:052E: 45 
   290                        TRUE:
   291 00:052F: CA                           dex                             ; Make space on the stack
   292 00:0530: CA                           dex
   293 00:0531: A9 FF FF                     lda     #$ffff                  ; And create a true value
   294 00:0534: 95 03                        sta     DSTACK+1,x
   295 00:0536: 4C FA 0C                     jmp     NEXT                    ; Done
   296                        
   297                        ;==============================================================================
   298                        ; Radix
   299                        ;------------------------------------------------------------------------------
   300                        
   301                        ; DECIMAL ( -- )
   302                        ;
   303                        ; Set the numeric conversion radix to ten (decimal).
   304                        
   305 00:0539: 27 05 00                     HEADER  NORMAL
   306 00:053C: 07 44 45 43                  db      7,"DECIMAL"
       00:0540: 49 4D 41 4C 
   307 00:0544: 4C F5 0C     DECIMAL:        jmp     DO_COLON
   308 00:0547: C3 0D 0A 00                  dw      DO_LITERAL,10,BASE,STORE
       00:054B: 74 04 6A 05 
   309 00:054F: 46 0A                        dw      EXIT
   310                        
   311                        ; HEX ( -- )
   312                        ;
   313                        ; Set contents of BASE to sixteen.
   314                        
   315 00:0551: 39 05 00                     HEADER  NORMAL
   316 00:0554: 03 48 45 58                  db      3,"HEX"
   317 00:0558: 4C F5 0C     HEX:            jmp     DO_COLON
   318 00:055B: C3 0D 10 00                  dw      DO_LITERAL,16,BASE,STORE
       00:055F: 74 04 6A 05 
   319 00:0563: 46 0A                        dw      EXIT
   320                        
   321                        ;==============================================================================
   322                        ; Memory Operations
   323                        ;------------------------------------------------------------------------------
   324                        
   325                        ; ! ( x a-addr -- )
   326                        ;
   327                        ; Store x at a-addr.
  Sun Nov 22 2015 10:55                                                                                                    Page 9


   328                        
   329 00:0565: 51 05 00                     HEADER  NORMAL
   330 00:0568: 01 21                        db      1,"!"
   331                        STORE:
   332 00:056A: 5A                           phy
   333 00:056B: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   334 00:056D: B5 05                        lda     DSTACK+3,x              ; Fetch the data value
   335 00:056F: 99 00 00                     sta     0,y                     ; Save it
   336 00:0572: E8                           inx                             ; Clean up data stack
   337 00:0573: E8                           inx
   338 00:0574: E8                           inx
   339 00:0575: E8                           inx
   340 00:0576: 7A                           ply
   341 00:0577: 4C FA 0C                     jmp     NEXT                    ; Done
   342                        
   343                        ; +! ( n|u a-addr -- )
   344                        ;
   345                        ; Add n|u to the single-cell number at a-addr.
   346                        
   347 00:057A: 65 05 00                     HEADER  NORMAL
   348 00:057D: 02 2B 21                     db      2,"+!"
   349                        PLUS_STORE:
   350 00:0580: 5A                           phy
   351 00:0581: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   352 00:0583: B5 05                        lda     DSTACK+3,x              ; Fetch the data value
   353 00:0585: 18                           clc                             ; Add data to memory
   354 00:0586: 79 00 00                     adc     0,y
   355 00:0589: 99 00 00                     sta     0,y                     ; And save result
   356 00:058C: E8                           inx                             ; Clean up data stacl
   357 00:058D: E8                           inx
   358 00:058E: E8                           inx
   359 00:058F: E8                           inx
   360 00:0590: 7A                           ply
   361 00:0591: 4C FA 0C                     jmp     NEXT                    ; Done
   362                        
   363                        ; , ( x -- )
   364                        ;
   365                        ; Reserve one cell of data space and store x in the cell. If the data-space
   366                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   367                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   368                        ; is not aligned prior to execution of ,.
   369                        ;
   370                        ;   HERE ! 1 CELLS ALLOT
   371                        
   372 00:0594: 7A 05 00                     HEADER  NORMAL
   373 00:0597: 01 2C                        db      1,","
   374 00:0599: 4C F5 0C     COMMA:          jmp     DO_COLON
   375 00:059C: 49 06 6A 05                  dw      HERE,STORE
   376 00:05A0: C3 0D 01 00                  dw      DO_LITERAL,1,CELLS,ALLOT
       00:05A4: 85 06 EE 05 
   377 00:05A8: 46 0A                        dw      EXIT
   378                        
   379                        ; 2! ( x1 x2 a-addr -- )
   380                        ;
   381                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   382                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   383                        
   384 00:05AA: 94 05 00                     HEADER  NORMAL
  Sun Nov 22 2015 10:55                                                                                                    Page 10


   385 00:05AD: 02 32 21                     db      2,"2!"
   386                        TWO_STORE:
   387 00:05B0: 4C F5 0C                     jmp     DO_COLON
   388 00:05B3: 59 07                        dw      SWAP
   389 00:05B5: 48 07                        dw      OVER
   390 00:05B7: 6A 05                        dw      STORE
   391 00:05B9: 75 06                        dw      CELL_PLUS
   392 00:05BB: 6A 05                        dw      STORE
   393 00:05BD: 46 0A                        dw      EXIT
   394                        
   395                        ; 2@ ( a-addr -- x1 x2 )
   396                        ;
   397                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   398                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   399                        ; @.
   400                        
   401 00:05BF: AA 05 00                     HEADER  NORMAL
   402 00:05C2: 02 32 40                     db      2,"2@"
   403                        TWO_FETCH:
   404 00:05C5: 4C F5 0C                     jmp     DO_COLON
   405 00:05C8: 27 07                        dw      DUP
   406 00:05CA: 75 06                        dw      CELL_PLUS
   407 00:05CC: D9 05                        dw      FETCH
   408 00:05CE: 59 07                        dw      SWAP
   409 00:05D0: D9 05                        dw      FETCH
   410 00:05D2: 46 0A                        dw      EXIT
   411                        
   412                        ; @ ( a-addr -- x )
   413                        ;
   414                        ; x is the value stored at a-addr.
   415                        
   416 00:05D4: BF 05 00                     HEADER  NORMAL
   417 00:05D7: 01 40                        db      1,"@"
   418                        FETCH:
   419 00:05D9: 5A                           phy
   420 00:05DA: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   421 00:05DC: B9 00 00                     lda     0,y                     ; Load the actual data
   422 00:05DF: 95 03                        sta     DSTACK+1,x              ; And replace the top value
   423 00:05E1: 7A                           ply
   424 00:05E2: 4C FA 0C                     jmp     NEXT                    ; Done
   425                        
   426                        ; ALLOT ( n -- )
   427                        ;
   428                        ; If n is greater than zero, reserve n address units of data space. If n is
   429                        ; less than zero, release |n| address units of data space. If n is zero, leave
   430                        ; the data-space pointer unchanged.
   431                        ;
   432                        ; In this implementation its is defined as:
   433                        ;
   434                        ;   DP +!
   435                        
   436 00:05E5: D4 05 00                     HEADER  NORMAL
   437 00:05E8: 05 41 4C 4C                  db      5,"ALLOT"
       00:05EC: 4F 54 
   438 00:05EE: 4C F5 0C     ALLOT:          jmp     DO_COLON
   439 00:05F1: 9C 04 80 05                  dw      DP,PLUS_STORE
   440 00:05F5: 46 0A                        dw      EXIT
   441                        
  Sun Nov 22 2015 10:55                                                                                                    Page 11


   442                        ; C! ( char c-addr -- )
   443                        ;
   444                        ; Store char at c-addr. When character size is smaller than cell size, only the
   445                        ; number of low-order bits corresponding to character size are transferred.
   446                        
   447 00:05F7: E5 05 00                     HEADER  NORMAL
   448 00:05FA: 02 43 21                     db      2,"C!"
   449                        C_STORE:
   450 00:05FD: 5A                           phy
   451 00:05FE: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   452 00:0600: B5 05                        lda     DSTACK+3,x              ; Fetch the data value
   453 00:0602: E2 20                        short_a
   454 00:0604: 99 00 00                     sta     0,y                     ; Save it
   455 00:0607: C2 20                        long_a
   456 00:0609: E8                           inx
   457 00:060A: E8                           inx
   458 00:060B: E8                           inx
   459 00:060C: E8                           inx
   460 00:060D: 7A                           ply
   461 00:060E: 4C FA 0C                     jmp     NEXT                    ; Done
   462                        
   463                        ; C, ( char -- )
   464                        ;
   465                        ; Reserve space for one character in the data space and store char in the
   466                        ; space. If the data-space pointer is character aligned when C, begins
   467                        ; execution, it will remain character aligned when C, finishes execution.
   468                        ; An ambiguous condition exists if the data-space pointer is not character-
   469                        ; aligned prior to execution of C,
   470                        ;
   471                        ;   HERE C! 1 CHARS ALLOT
   472                        
   473 00:0611: F7 05 00                     HEADER  NORMAL
   474 00:0614: 02 43 2C                     db      2,"C,"
   475 00:0617: 4C F5 0C     C_COMMA:        jmp     DO_COLON
   476 00:061A: 49 06 FD 05                  dw      HERE,C_STORE
   477 00:061E: C3 0D 01 00                  dw      DO_LITERAL,1,CHARS,ALLOT
       00:0622: A1 06 EE 05 
   478 00:0626: 46 0A                        dw      EXIT
   479                        
   480                        ; C@ ( c-addr -- char )
   481                        ;
   482                        ; Fetch the character stored at c-addr. When the cell size is greater than
   483                        ; character size, the unused high-order bits are all zeroes.
   484                        
   485 00:0628: 11 06 00                     HEADER  NORMAL
   486 00:062B: 02 43 40                     db      2,"C@"
   487                        C_FETCH:
   488 00:062E: 5A                           phy
   489 00:062F: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   490 00:0631: E2 20                        short_a
   491 00:0633: B9 00 00                     lda     0,y                     ; Load the actual data
   492 00:0636: C2 20                        long_a
   493 00:0638: 29 FF 00                     and     #$00ff
   494 00:063B: 95 03                        sta     DSTACK+1,x              ; And replace the top value
   495 00:063D: 7A                           ply
   496 00:063E: 4C FA 0C                     jmp     NEXT                    ; Done
   497                        
   498                        ; HERE
  Sun Nov 22 2015 10:55                                                                                                    Page 12


   499                        
   500 00:0641: 28 06 00                     HEADER  NORMAL
   501 00:0644: 04 48 45 52                  db      4,"HERE"
       00:0648: 45 
   502 00:0649: 4C F5 0C     HERE:           jmp     DO_COLON
   503 00:064C: 9C 04 D9 05                  dw      DP,FETCH
   504 00:0650: 46 0A                        dw      EXIT
   505                        
   506                        ;==============================================================================
   507                        ; Alignment
   508                        ;------------------------------------------------------------------------------
   509                        
   510                        ; ALIGN ( -- )
   511                        ;
   512                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   513                        
   514 00:0652: 41 06 00                     HEADER  NORMAL
   515 00:0655: 05 41 4C 49                  db      5,"ALIGN"
       00:0659: 47 4E 
   516                        ALIGN:
   517 00:065B: 4C FA 0C                     jmp     NEXT                    ; Done
   518                        
   519                        ; ALIGNED ( addr -- a-addr )
   520                        ;
   521                        ; a-addr is the first aligned address greater than or equal to addr.
   522                        
   523 00:065E: 52 06 00                     HEADER  NORMAL
   524 00:0661: 07 41 4C 49                  db      7,"ALIGNED"
       00:0665: 47 4E 45 44 
   525                        ALIGNED:
   526 00:0669: 4C FA 0C                     jmp     NEXT                    ; Done
   527                        
   528                        ; CELL+ ( a-addr1 -- a-addr2 )
   529                        ;
   530                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   531                        
   532 00:066C: 5E 06 00                     HEADER  NORMAL
   533 00:066F: 05 43 45 4C                  db      5,"CELL+"
       00:0673: 4C 2B 
   534                        CELL_PLUS:
   535 00:0675: F6 03                        inc     DSTACK+1,x              ; Bump the address by two
   536 00:0677: F6 03                        inc     DSTACK+1,X
   537 00:0679: 4C FA 0C                     jmp     NEXT
   538                        
   539                        ; CELLS ( n1 -- n2 )
   540                        ;
   541                        ; n2 is the size in address units of n1 cells.
   542                        
   543 00:067C: 6C 06 00                     HEADER  NORMAL
   544 00:067F: 05 43 45 4C                  db      5,"CELLS"
       00:0683: 4C 53 
   545                        CELLS:
   546 00:0685: 16 03                        asl     DSTACK+1,x              ; Two bytes per cell
   547 00:0687: 4C FA 0C                     jmp     NEXT
   548                        
   549                        ; CHAR+ ( c-addr1 -- c-addr2 )
   550                        ;
   551                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
  Sun Nov 22 2015 10:55                                                                                                    Page 13


   552                        
   553 00:068A: 7C 06 00                     HEADER  NORMAL
   554 00:068D: 05 43 48 41                  db      5,"CHAR+"
       00:0691: 52 2B 
   555                        CHAR_PLUS:
   556 00:0693: F6 03                        inc     DSTACK+1,x              ; Bump the address by one
   557 00:0695: 4C FA 0C                     jmp     NEXT
   558                        
   559                        ; CHARS ( n1 -- n2 )
   560                        ;
   561                        ; n2 is the size in address units of n1 characters.
   562                        
   563 00:0698: 8A 06 00                     HEADER  NORMAL
   564 00:069B: 05 43 48 41                  db      5,"CHARS"
       00:069F: 52 53 
   565                        CHARS:
   566 00:06A1: 4C FA 0C                     jmp     NEXT
   567                        
   568                        ;==============================================================================
   569                        ; Stack Operations
   570                        ;------------------------------------------------------------------------------
   571                        
   572                        ; 2DROP ( x1 x2 -- )
   573                        ;
   574                        ; Drop cell pair x1 x2 from the stack.
   575                        
   576 00:06A4: 98 06 00                     HEADER  NORMAL
   577 00:06A7: 05 32 44 52                  db      5,"2DROP"
       00:06AB: 4F 50 
   578                        TWO_DROP:
   579 00:06AD: E8                           inx
   580 00:06AE: E8                           inx
   581 00:06AF: E8                           inx
   582 00:06B0: E8                           inx
   583 00:06B1: 4C FA 0C                     jmp     NEXT
   584                        
   585                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   586                        ;
   587                        ; Duplicate cell pair x1 x2.
   588                        
   589 00:06B4: A4 06 00                     HEADER  NORMAL
   590 00:06B7: 04 32 44 55                  db      4,"2DUP"
       00:06BB: 50 
   591                        TWO_DUP:
   592 00:06BC: B5 03                        lda     DSTACK+1,x              ; Fetch the top value
   593 00:06BE: CA                           dex                             ; Make space for new values
   594 00:06BF: CA                           dex
   595 00:06C0: CA                           dex
   596 00:06C1: CA                           dex
   597 00:06C2: 95 03                        sta     DSTACK+1,x              ; Make two copies
   598 00:06C4: 95 05                        sta     DSTACK+3,x
   599 00:06C6: 4C FA 0C                     jmp     NEXT
   600                        
   601                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   602                        ;
   603                        ; Copy cell pair x1 x2 to the top of the stack.
   604                        
   605 00:06C9: B4 06 00                     HEADER  NORMAL
  Sun Nov 22 2015 10:55                                                                                                    Page 14


   606 00:06CC: 05 32 4F 56                  db      5,"2OVER"
       00:06D0: 45 52 
   607                        TWO_OVER:
   608 00:06D2: B5 09                        lda     DSTACK+7,x              ; Copy over x1
   609 00:06D4: CA                           dex
   610 00:06D5: CA                           dex
   611 00:06D6: 95 03                        sta     DSTACK+1,x
   612 00:06D8: B5 09                        lda     DSTACK+7,x              ; Copy over x2
   613 00:06DA: CA                           dex
   614 00:06DB: CA                           dex
   615 00:06DC: 95 03                        sta     DSTACK+1,x
   616 00:06DE: 4C FA 0C                     jmp     NEXT                    ; Done
   617                        
   618                        ; 2ROT
   619                        
   620                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   621                        ;
   622                        ; Exchange the top two cell pairs.
   623                        
   624 00:06E1: C9 06 00                     HEADER  NORMAL
   625 00:06E4: 05 32 53 57                  db      5,"2SWAP"
       00:06E8: 41 50 
   626                        TWO_SWAP:
   627 00:06EA: B5 05                        lda     DSTACK+3,x              ; Save x3
   628 00:06EC: 48                           pha
   629 00:06ED: B5 03                        lda     DSTACK+1,x              ; Save x4
   630 00:06EF: B5 09                        lda     DSTACK+7,x              ; Move x1
   631 00:06F1: 95 05                        sta     DSTACK+3,x
   632 00:06F3: B5 07                        lda     DSTACK+5,x              ; Move x2
   633 00:06F5: 95 03                        sta     DSTACK+1,x
   634 00:06F7: 68                           pla                             ; Move x4
   635 00:06F8: 95 07                        sta     DSTACK+5,x
   636 00:06FA: 68                           pla                             ; Move x3
   637 00:06FB: 95 09                        sta     DSTACK+7,x
   638 00:06FD: 4C FA 0C                     jmp     NEXT                    ; Done
   639                        
   640                        ; ?DUP ( x -- 0 | x x )
   641                        ;
   642                        ; Duplicate x if it is non-zero.
   643                        
   644 00:0700: E1 06 00                     HEADER  NORMAL
   645 00:0703: 04 3F 44 55                  db      4,"?DUP"
       00:0707: 50 
   646                        QUERY_DUP:
   647 00:0708: B5 03                        lda     DSTACK+1,x              ; Fetch top value
   648 00:070A: F0 04                        beq     QUERY_DUP_1             ; Non-zero value?
   649 00:070C: CA                           dex
   650 00:070D: CA                           dex
   651 00:070E: 95 03                        sta     DSTACK+1,x              ; Push a copy
   652 00:0710: 4C FA 0C     QUERY_DUP_1:    jmp     NEXT                    ; Done
   653                        
   654                        ; DROP ( x -- )
   655                        ;
   656                        ; Remove x from the stack.
   657                        
   658 00:0713: 00 07 00                     HEADER  NORMAL
   659 00:0716: 04 44 52 4F                  db      4,"DROP"
       00:071A: 50 
  Sun Nov 22 2015 10:55                                                                                                    Page 15


   660                        DROP:
   661 00:071B: E8                           inx                             ; Drop the top value
   662 00:071C: E8                           inx
   663 00:071D: 4C FA 0C                     jmp     NEXT                    ; Done
   664                        
   665                        ; DUP ( x -- x x )
   666                        ;
   667                        ; Duplicate x.
   668                        
   669 00:0720: 13 07 00                     HEADER  NORMAL
   670 00:0723: 03 44 55 50                  db      3,"DUP"
   671                        DUP:
   672 00:0727: B5 03                        lda     DSTACK+1,x              ; Fetch top value
   673 00:0729: CA                           dex                             ; And make a copy
   674 00:072A: CA                           dex
   675 00:072B: 95 03                        sta     DSTACK+1,x
   676 00:072D: 4C FA 0C                     jmp     NEXT                    ; Done
   677                        
   678                        ; NIP ( x1 x2 -- x2 )
   679                        ;
   680                        ; Drop the first item below the top of stack.
   681                        
   682 00:0730: 20 07 00                     HEADER  NORMAL
   683 00:0733: 03 4E 49 50                  db      3,"NIP"
   684                        NIP:
   685 00:0737: B5 03                        lda     DSTACK+1,x              ; Copy x2 over x1
   686 00:0739: 95 05                        sta     DSTACK+3,x
   687 00:073B: E8                           inx                             ; Clean up the stack
   688 00:073C: E8                           inx
   689 00:073D: 4C FA 0C                     jmp     NEXT
   690                        
   691                        ; OVER ( x1 x2 -- x1 x2 x1 )
   692                        ;
   693                        ; Place a copy of x1 on top of the stack.
   694                        
   695 00:0740: 30 07 00                     HEADER  NORMAL
   696 00:0743: 04 4F 56 45                  db      4,"OVER"
       00:0747: 52 
   697                        OVER:
   698 00:0748: B5 05                        lda     DSTACK+3,x              ; Fetch second value
   699 00:074A: CA                           dex                             ; And make a copy
   700 00:074B: CA                           dex
   701 00:074C: 95 03                        sta     DSTACK+1,x
   702 00:074E: 4C FA 0C                     jmp     NEXT                    ; Done
   703                        
   704                        ; SWAP ( x1 x2 -- x2 x1 )
   705                        ;
   706                        ; Exchange the top two stack items.
   707                        
   708 00:0751: 40 07 00                     HEADER  NORMAL
   709 00:0754: 04 53 57 41                  db      4,"SWAP"
       00:0758: 50 
   710                        SWAP:
   711 00:0759: B5 03                        lda     DSTACK+1,x              ; Fetch top of stack
   712 00:075B: 48                           pha                             ; .. and save
   713 00:075C: B5 05                        lda     DSTACK+3,x              ; Exchange second
   714 00:075E: 95 03                        sta     DSTACK+1,x              ; .. and top
   715 00:0760: 68                           pla                             ; Recover top
  Sun Nov 22 2015 10:55                                                                                                    Page 16


   716 00:0761: 95 05                        sta     DSTACK+3,x              ; .. and save as second
   717 00:0763: 4C FA 0C                     jmp     NEXT                    ; Done
   718                        
   719                        ; ROT
   720                        ; ROLL
   721                        
   722                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   723                        ;
   724                        ; Copy the first (top) stack item below the second stack item.
   725                        
   726 00:0766: 51 07 00                     HEADER  NORMAL
   727 00:0769: 04 54 55 43                  db      4,"TUCK"
       00:076D: 4B 
   728 00:076E: 4C F5 0C     TUCK:           jmp     DO_COLON
   729 00:0771: 59 07                        dw      SWAP
   730 00:0773: 48 07                        dw      OVER
   731 00:0775: 46 0A                        dw      EXIT
   732                        
   733                        ;==============================================================================
   734                        ; Return Stack Operations
   735                        ;------------------------------------------------------------------------------
   736                        
   737                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   738                        ;
   739                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   740                        ; SWAP >R >R.
   741                        
   742 00:0777: 66 07 00                     HEADER  NORMAL
   743 00:077A: 03 32 3E 52                  db      3,"2>R"
   744                        TWO_TO_R:
   745 00:077E: B5 05                        lda     DSTACK+3,x              ; Transfer x1
   746 00:0780: 48                           pha
   747 00:0781: B5 03                        lda     DSTACK+1,x              ; Transfer x2
   748 00:0783: 48                           pha
   749 00:0784: E8                           inx                             ; Clean up data stack
   750 00:0785: E8                           inx
   751 00:0786: E8                           inx
   752 00:0787: E8                           inx
   753 00:0788: 4C FA 0C                     jmp     NEXT                    ; Done
   754                        
   755                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   756                        ;
   757                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   758                        ; R> SWAP.
   759                        
   760 00:078B: 77 07 00                     HEADER  NORMAL
   761 00:078E: 03 32 52 3E                  db      3,"2R>"
   762                        TWO_R_FROM:
   763 00:0792: CA                           dex                             ; Make space for values
   764 00:0793: CA                           dex
   765 00:0794: CA                           dex
   766 00:0795: CA                           dex
   767 00:0796: 68                           pla                             ; Transfer x2
   768 00:0797: 95 03                        sta     DSTACK+1,x
   769 00:0799: 68                           pla                             ; Transfer x1
   770 00:079A: 95 05                        sta     DSTACK+3,x
   771 00:079C: 4C FA 0C                     jmp     NEXT                    ; Done
   772                        
  Sun Nov 22 2015 10:55                                                                                                    Page 17


   773                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   774                        ;
   775                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   776                        ; 2DUP >R >R SWAP.
   777                        
   778 00:079F: 8B 07 00                     HEADER  NORMAL
   779 00:07A2: 03 32 52 40                  db      3,"2R@"
   780                        TWO_R_FETCH:
   781 00:07A6: CA                           dex                             ; Make space for values
   782 00:07A7: CA                           dex
   783 00:07A8: CA                           dex
   784 00:07A9: CA                           dex
   785 00:07AA: A3 01                        lda     1,s                     ; Transfer x2
   786 00:07AC: 95 03                        sta     DSTACK+1,x
   787 00:07AE: A3 03                        lda     3,s                     ; Transfer x1
   788 00:07B0: 95 05                        sta     DSTACK+3,x
   789 00:07B2: 4C FA 0C                     jmp     NEXT                    ; Done
   790                        
   791                        ; >R ( x -- ) ( R: -- x )
   792                        ;
   793                        ; Move x to the return stack.
   794                        
   795 00:07B5: 9F 07 00                     HEADER  NORMAL
   796 00:07B8: 02 3E 52                     db      2,">R"
   797                        TO_R:
   798 00:07BB: B5 03                        lda     DSTACK+1,x              ; Transfer top value
   799 00:07BD: 48                           pha                             ; .. to return stack
   800 00:07BE: E8                           inx
   801 00:07BF: E8                           inx
   802 00:07C0: 4C FA 0C                     jmp     NEXT                    ; Done
   803                        
   804                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   805                        ;
   806                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   807                        ; exists if the loop control parameters are unavailable.
   808                        
   809 00:07C3: B5 07 00                     HEADER  NORMAL
   810 00:07C6: 01 49                        db      1,"I"
   811                        I:
   812 00:07C8: A3 01                        lda     1,s
   813 00:07CA: CA                           dex
   814 00:07CB: CA                           dex
   815 00:07CC: 95 03                        sta     DSTACK+1,x
   816 00:07CE: 4C FA 0C                     jmp     NEXT
   817                        
   818                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   819                        ;
   820                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   821                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   822                        ; unavailable.
   823                        
   824 00:07D1: C3 07 00                     HEADER  NORMAL
   825 00:07D4: 01 4A                        db      1,"J"
   826                        J:
   827 00:07D6: A3 03                        lda     3,s
   828 00:07D8: CA                           dex
   829 00:07D9: CA                           dex
   830 00:07DA: 95 03                        sta     DSTACK+1,x
  Sun Nov 22 2015 10:55                                                                                                    Page 18


   831 00:07DC: 4C FA 0C                     jmp     NEXT
   832                        
   833                        ; R> ( -- x ) ( R: x -- )
   834                        ;
   835                        ; Move x from the return stack to the data stack.
   836                        
   837 00:07DF: D1 07 00                     HEADER  NORMAL
   838 00:07E2: 02 52 3E                     db      2,"R>"
   839                        R_FROM:
   840 00:07E5: 68                           pla                             ; Fetch return stack value
   841 00:07E6: CA                           dex                             ; And push
   842 00:07E7: CA                           dex
   843 00:07E8: 95 03                        sta     DSTACK+1,X
   844 00:07EA: 4C FA 0C                     jmp     NEXT                    ; Done
   845                        
   846                        ; R@ ( -- x ) ( R: x -- x )
   847                        ;
   848                        ; Copy x from the return stack to the data stack.
   849                        
   850 00:07ED: DF 07 00                     HEADER  NORMAL
   851 00:07F0: 02 52 40                     db      2,"R@"
   852                        R_FETCH:
   853 00:07F3: A3 01                        lda     1,s
   854 00:07F5: CA                           dex
   855 00:07F6: CA                           dex
   856 00:07F7: 95 03                        sta     DSTACK+1,x
   857 00:07F9: 4C FA 0C                     jmp     NEXT
   858                        
   859                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   860                        ;
   861                        ; Rotate the top three stack entries.
   862                        
   863 00:07FC: ED 07 00                     HEADER  NORMAL
   864 00:07FF: 03 52 4F 54                  db      3,"ROT"
   865 00:0803: B5 07        ROT:            lda     DSTACK+5,x              ; Save x1
   866 00:0805: 48                           pha
   867 00:0806: B5 05                        lda     DSTACK+3,x              ; Move x2,x3 up
   868 00:0808: 95 07                        sta     DSTACK+5,x
   869 00:080A: B5 03                        lda     DSTACK+1,x
   870 00:080C: 95 05                        sta     DSTACK+3,x
   871 00:080E: 68                           pla                             ; Recover x1
   872 00:080F: 95 03                        sta     DSTACK+1,x
   873 00:0811: 4C FA 0C                     jmp     NEXT                    ; Done
   874                        
   875                        ;==============================================================================
   876                        ; Single Precision Arithmetic
   877                        ;------------------------------------------------------------------------------
   878                        
   879                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   880                        ;
   881                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   882                        
   883 00:0814: FC 07 00                     HEADER  NORMAL
   884 00:0817: 01 2A                        db      1,"*"
   885                        STAR:
   886 00:0819: 4C FA 0C                     jmp     NEXT                    ; Done
   887                        
   888                        ; */
  Sun Nov 22 2015 10:55                                                                                                    Page 19


   889                        ; */MOD
   890                        
   891                        
   892                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   893                        ;
   894                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   895                        
   896 00:081C: 14 08 00                     HEADER  NORMAL
   897 00:081F: 01 2B                        db      1,"+"
   898                        PLUS:
   899 00:0821: 18                           clc                             ; Add top two values
   900 00:0822: B5 03                        lda     DSTACK+1,x
   901 00:0824: 75 05                        adc     DSTACK+3,x
   902 00:0826: 95 05                        sta     DSTACK+3,x              ; Save result
   903 00:0828: E8                           inx                             ; Clean up data stack
   904 00:0829: E8                           inx
   905 00:082A: 4C FA 0C                     JMP     NEXT                    ; Done
   906                        
   907                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   908                        ;
   909                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   910                        
   911 00:082D: 1C 08 00                     HEADER  NORMAL
   912 00:0830: 01 2D                        db      1,"-"
   913                        MINUS:
   914 00:0832: 38                           sec                             ; Subtract top two values
   915 00:0833: B5 03                        lda     DSTACK+1,x
   916 00:0835: F5 05                        sbc     DSTACK+3,x
   917 00:0837: 95 05                        sta     DSTACK+3,x              ; Save result
   918 00:0839: E8                           inx                             ; Clean up data stack
   919 00:083A: E8                           inx
   920 00:083B: 4C FA 0C                     jmp     NEXT                    ; Done
   921                        
   922                        ; /
   923                        ; /MOD
   924                        
   925                        ; 1+ ( n1|u1 -- n2|u2 )
   926                        ;
   927                        ; Add one (1) to n1|u1 giving the sum n2|u2.
   928                        
   929 00:083E: 2D 08 00                     HEADER  NORMAL
   930 00:0841: 02 31 2B                     db      2,"1+"
   931                        ONE_PLUS:
   932 00:0844: F6 03                        inc     DSTACK+1,x              ; Increment top of stack
   933 00:0846: 4C FA 0C                     jmp     NEXT                    ; Done
   934                        
   935                        ; 1- ( n1|u1 -- n2|u2 )
   936                        ;
   937                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
   938                        
   939 00:0849: 3E 08 00                     HEADER  NORMAL
   940 00:084C: 02 31 2D                     db      2,"1-"
   941                        ONE_MINUS:
   942 00:084F: D6 03                        dec     DSTACK+1,x              ; Decrement top of stack
   943 00:0851: 4C FA 0C                     jmp     NEXT                    ; Done
   944                        
   945                        ; 2* ( x1 -- x2 )
   946                        ;
  Sun Nov 22 2015 10:55                                                                                                    Page 20


   947                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
   948                        ; filling the vacated least-significant bit with zero.
   949                        
   950 00:0854: 49 08 00                     HEADER  NORMAL
   951 00:0857: 02 32 2A                     db      2,"2*"
   952                        TWO_STAR:
   953 00:085A: 16 03                        asl     DSTACK+1,x              ; Multiply top value by two
   954 00:085C: 4C FA 0C                     jmp     NEXT                    ; Done
   955                        
   956                        ; 2/ ( x1 -- x2 )
   957                        ;
   958                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
   959                        ; leaving the most-significant bit unchanged.
   960                        
   961 00:085F: 54 08 00                     HEADER  NORMAL
   962 00:0862: 02 32 2F                     db      2,"2/"
   963                        TWO_SLASH:
   964 00:0865: B5 03                        lda     DSTACK+1,x              ; Load the top value
   965 00:0867: 2A                           rol     a                       ; Extract the top bit
   966 00:0868: 76 03                        ror     DSTACK+1,x              ; And shift back into value
   967 00:086A: 4C FA 0C                     jmp     NEXT
   968                        
   969                        ; ABS ( n -- u )
   970                        ;
   971                        ; u is the absolute value of n.
   972                        
   973 00:086D: 5F 08 00                     HEADER  NORMAL
   974 00:0870: 03 41 42 53                  db      3,"ABS"
   975                        ABS:
   976 00:0874: 38                           sec                             ; Assume to is negative
   977 00:0875: A9 00 00                     lda     #0
   978 00:0878: F5 03                        sbc     DSTACK+1,x              ; Invert it
   979 00:087A: 30 02                        bmi     ABS_1                   ; Correct assumption?
   980 00:087C: 95 03                        sta     DSTACK+1,x              ; Yes, same the result
   981 00:087E: 4C FA 0C     ABS_1           jmp     NEXT                    ; Done
   982                        
   983                        ; MAX
   984                        ; MIN
   985                        ; MOD
   986                        
   987                        ; NEGATE ( n1 -- n2 )
   988                        ;
   989                        ; Negate n1, giving its arithmetic inverse n2.
   990                        
   991 00:0881: 6D 08 00                     HEADER  NORMAL
   992 00:0884: 06 4E 45 47                  db      6,"NEGATE"
       00:0888: 41 54 45 
   993                        NEGATE:
   994 00:088B: 38                           sec                             ; Negate the top of stack
   995 00:088C: A9 00 00                     lda     #0
   996 00:088F: F5 03                        sbc     DSTACK+1,x
   997 00:0891: 95 03                        sta     DSTACK+1,x
   998 00:0893: 4C FA 0C                     jmp     NEXT                    ; Done
   999                        
  1000                        ; UMAX
  1001                        
  1002 00:0896: 81 08 00                     HEADER  NORMAL
  1003 00:0899: 04 55 4D 41                  db      4,"UMAX"
  Sun Nov 22 2015 10:55                                                                                                    Page 21


       00:089D: 58 
  1004                        UMAX:
  1005 00:089E: B5 03                        lda     DSTACK+1,x              ; Compare the top values
  1006 00:08A0: D5 05                        cmp     DSTACK+3,x
  1007 00:08A2: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1008 00:08A4: 4C 1B 07                     jmp     DROP                    ; No, x1 is
  1009 00:08A7: 4C 37 07     UMAX_EXIT:      jmp     NIP
  1010                        
  1011                        ; UMIN
  1012                        
  1013 00:08AA: 96 08 00                     HEADER  NORMAL
  1014 00:08AD: 04 55 4D 49                  db      4,"UMIN"
       00:08B1: 4E 
  1015                        UMIN:
  1016 00:08B2: B5 03                        lda     DSTACK+1,x              ; Compare the top values
  1017 00:08B4: D5 05                        cmp     DSTACK+3,x
  1018 00:08B6: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1019 00:08B8: 4C 1B 07                     jmp     DROP                    ; No, x1 is
  1020 00:08BB: 4C 37 07     UMIN_EXIT:      jmp     NIP
  1021                        
  1022                        ;==============================================================================
  1023                        ; Double Precision Arithmetic
  1024                        ;------------------------------------------------------------------------------
  1025                        
  1026                        ; D+
  1027                        ; D-
  1028                        ; DNEGATE
  1029                        
  1030                        ;==============================================================================
  1031                        ; Mixed Arithmetic
  1032                        ;------------------------------------------------------------------------------
  1033                        
  1034                        
  1035                        ; D>S ( d -- n )
  1036                        ;
  1037                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1038                        ; range of a signed single-cell number.
  1039                        
  1040 00:08BE: AA 08 00                     HEADER  NORMAL
  1041 00:08C1: 03 44 3E 53                  db      3,"D>S"
  1042                        D_TO_S:
  1043 00:08C5: E8                           inx                             ; Drop the high word
  1044 00:08C6: E8                           inx
  1045 00:08C7: 4C FA 0C                     jmp     NEXT
  1046                        
  1047                        ; S>D ( n -- d )
  1048                        ;
  1049                        ; Convert the number n to the double-cell number d with the same numerical
  1050                        ; value.
  1051                        
  1052 00:08CA: BE 08 00                     HEADER  NORMAL
  1053 00:08CD: 03 53 3E 44                  db      3,"S>D"
  1054                        S_TO_D:
  1055 00:08D1: CA                           dex                             ; Assume n is positive
  1056 00:08D2: CA                           dex
  1057 00:08D3: 74 03                        stz     DSTACK+1,x              ; .. push a zero value
  1058 00:08D5: 34 05                        bit     DSTACK+3,x              ; Test the number
  1059 00:08D7: 10 02                        bpl     S_TO_D_1
  Sun Nov 22 2015 10:55                                                                                                    Page 22


  1060 00:08D9: D6 03                        dec     DSTACK+1,x              ; Make top -1 if negative
  1061 00:08DB: 4C FA 0C     S_TO_D_1        jmp     NEXT                    ; Done
  1062                        
  1063                        ;==============================================================================
  1064                        ; Comparisons
  1065                        ;------------------------------------------------------------------------------
  1066                        
  1067                        ; 0< ( n -- flag )
  1068                        ;
  1069                        ; flag is true if and only if n is less than zero.
  1070                        
  1071 00:08DE: CA 08 00                     HEADER  NORMAL
  1072 00:08E1: 02 30 3C                     db      2,"0<"
  1073                        ZERO_LESS:
  1074 00:08E4: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1075 00:08E6: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1076 00:08E8: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1077 00:08EA: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1078 00:08EC: 4C FA 0C     ZERO_LT_1:      jmp     NEXT                    ; Done
  1079                        
  1080                        ; 0<> ( x -- flag )
  1081                        ;
  1082                        ; flag is true if and only if x is not equal to zero.
  1083                        
  1084 00:08EF: DE 08 00                     HEADER  NORMAL
  1085 00:08F2: 03 30 3C 3E                  db      3,"0<>"
  1086                        ZERO_NOT_EQUAL:
  1087 00:08F6: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1088 00:08F8: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1089 00:08FA: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1090 00:08FC: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1091 00:08FE: 4C FA 0C     ZERO_NE_1:      jmp     NEXT                    ; Done
  1092                        
  1093                        ; 0= ( x -- flag )
  1094                        ;
  1095                        ; flag is true if and only if x is equal to zero.
  1096                        
  1097 00:0901: EF 08 00                     HEADER  NORMAL
  1098 00:0904: 02 30 3D                     db      2,"0="
  1099                        ZERO_EQUAL:
  1100 00:0907: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1101 00:0909: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1102 00:090B: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1103 00:090D: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1104 00:090F: 4C FA 0C     ZERO_EQ_1:      jmp     NEXT                    ; Done
  1105                        
  1106                        ; 0> ( n -- flag )
  1107                        ;
  1108                        ; flag is true if and only if n is greater than zero.
  1109                        
  1110 00:0912: 01 09 00                     HEADER  NORMAL
  1111 00:0915: 02 30 3E                     db      2,"0>"
  1112                        ZERO_GREATER:
  1113 00:0918: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1114 00:091A: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1115 00:091C: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1116 00:091E: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1117 00:0920: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  Sun Nov 22 2015 10:55                                                                                                    Page 23


  1118 00:0922: 4C FA 0C     ZERO_GT_EXIT:   jmp     NEXT                    ; Done
  1119                        
  1120                        ; <
  1121                        
  1122                        ; <>
  1123                        
  1124 00:0925: 12 09 00                     HEADER  NORMAL
  1125 00:0928: 02 3C 3E                     db      2,"<>"
  1126                        NOT_EQUAL:
  1127 00:092B: B5 03                        lda     DSTACK+1,x              ; Pull x2 from stack
  1128 00:092D: E8                           inx
  1129 00:092E: E8                           inx
  1130 00:092F: D5 03                        cmp     DSTACK+1,x              ; Compare with x1
  1131 00:0931: 74 03                        stz     DSTACK+1,x              ; Assume equal
  1132 00:0933: F0 02                        beq     NE_EXIT                 ; Test flags
  1133 00:0935: D6 03                        dec     DSTACK+1,x              ; Make result true
  1134 00:0937: 4C FA 0C     NE_EXIT:        jmp     NEXT                    ; Done
  1135                        
  1136                        ; = ( x1 x2 -- flag )
  1137                        ;
  1138                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1139                        
  1140 00:093A: 25 09 00                     HEADER  NORMAL
  1141 00:093D: 01 3D                        db      1,"="
  1142                        EQUAL:
  1143 00:093F: B5 03                        lda     DSTACK+1,x              ; Pull x2 from stack
  1144 00:0941: E8                           inx
  1145 00:0942: E8                           inx
  1146 00:0943: D5 03                        cmp     DSTACK+1,x              ; Compare with x1
  1147 00:0945: 74 03                        stz     DSTACK+1,x              ; Assume not equal
  1148 00:0947: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1149 00:0949: F6 03                        inc     DSTACK+1,x              ; Make result true
  1150 00:094B: 4C FA 0C     EQ_EXIT:        jmp     NEXT                    ; Done
  1151                        
  1152                        ; >
  1153                        
  1154                        ; U<
  1155                        ; U>
  1156                        
  1157                        ;==============================================================================
  1158                        ; Logical Operations
  1159                        ;------------------------------------------------------------------------------
  1160                        
  1161                        ; AND ( x1 x2 -- x3 )
  1162                        ;
  1163                        ; x3 is the bit-by-bit logical “and” of x1 with x2.
  1164                        
  1165 00:094E: 3A 09 00                     HEADER  NORMAL
  1166 00:0951: 03 41 4E 44                  db      3,"AND"
  1167                        AND:
  1168 00:0955: B5 03                        lda     DSTACK+1,x
  1169 00:0957: 35 05                        and     DSTACK+3,x
  1170 00:0959: 95 05                        sta     DSTACK+3,x
  1171 00:095B: E8                           inx
  1172 00:095C: E8                           inx
  1173 00:095D: 4C FA 0C                     jmp     NEXT
  1174                        
  1175                        ; INVERT ( x1 -- x2 )
  Sun Nov 22 2015 10:55                                                                                                    Page 24


  1176                        ;
  1177                        ; Invert all bits of x1, giving its logical inverse x2.
  1178                        
  1179 00:0960: 4E 09 00                     HEADER  NORMAL
  1180 00:0963: 06 49 4E 56                  db      6,"INVERT"
       00:0967: 45 52 54 
  1181                        INVERT:
  1182 00:096A: B5 03                        lda     DSTACK+1,x              ; Fetch top value
  1183 00:096C: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1184 00:096F: 95 03                        sta     DSTACK+1,x              ; .. and write back
  1185 00:0971: 4C FA 0C                     jmp     NEXT                    ; Done
  1186                        
  1187                        ; LSHIFT ( x1 u -- x2 )
  1188                        ;
  1189                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1190                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1191                        ; exists if u is greater than or equal to the number of bits in a cell.
  1192                        
  1193 00:0974: 60 09 00                     HEADER  NORMAL
  1194 00:0977: 06 4C 53 48                  db      6,"LSHIFT"
       00:097B: 49 46 54 
  1195                        LSHIFT:
  1196 00:097E: B5 03                        lda     DSTACK+1,x              ; Pull bit count
  1197 00:0980: 08                           php
  1198 00:0981: E8                           inx                             ; .. from the stack
  1199 00:0982: E8                           inx
  1200 00:0983: 28                           plp
  1201 00:0984: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1202 00:0986: C9 10 00                     cmp     #16                     ; Shifting by 16+ bits
  1203 00:0989: B0 08                        bcs     LSHIFT_2                ; Yes, result will be zero
  1204 00:098B: 16 03        LSHIFT_1        asl     DSTACK+1,x              ; Shift one bit left
  1205 00:098D: 3A                           dec     a                       ; Update count
  1206 00:098E: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1207 00:0990: 4C FA 0C     LSHIFT_0        jmp     NEXT                    ; Done
  1208 00:0993: 74 03        LSHIFT_2        stz     DSTACK+1,x              ; Clear top value
  1209 00:0995: 4C FA 0C                     jmp     NEXT                    ; Done
  1210                        
  1211                        ; OR ( x1 x2 -- x3 )
  1212                        ;
  1213                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1214                        
  1215 00:0998: 74 09 00                     HEADER  NORMAL
  1216 00:099B: 02 4F 52                     db      2,"OR"
  1217                        OR:
  1218 00:099E: B5 03                        lda     DSTACK+1,x
  1219 00:09A0: 15 05                        ora     DSTACK+3,x
  1220 00:09A2: 95 05                        sta     DSTACK+3,x
  1221 00:09A4: E8                           inx
  1222 00:09A5: E8                           inx
  1223 00:09A6: 4C FA 0C                     jmp     NEXT
  1224                        
  1225                        ; RSHIFT ( x1 u -- x2 )
  1226                        ;
  1227                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1228                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1229                        ; exists if u is greater than or equal to the number of bits in a cell.
  1230                        
  1231 00:09A9: 98 09 00                     HEADER  NORMAL
  Sun Nov 22 2015 10:55                                                                                                    Page 25


  1232 00:09AC: 06 52 53 48                  db      6,"RSHIFT"
       00:09B0: 49 46 54 
  1233                        RSHIFT:
  1234 00:09B3: B5 03                        lda     DSTACK+1,x              ; Pull bit count
  1235 00:09B5: 08                           php
  1236 00:09B6: E8                           inx                             ; .. from the stack
  1237 00:09B7: E8                           inx
  1238 00:09B8: 28                           plp
  1239 00:09B9: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1240 00:09BB: C9 10 00                     cmp     #16                     ; Shifting by 16+ bits
  1241 00:09BE: B0 08                        bcs     RSHIFT_2                ; Yes, result will be zero
  1242 00:09C0: 56 03        RSHIFT_1        lsr     DSTACK+1,x              ; Shift one bit left
  1243 00:09C2: 3A                           dec     a                       ; Update count
  1244 00:09C3: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1245 00:09C5: 4C FA 0C     RSHIFT_0        jmp     NEXT                    ; Done
  1246 00:09C8: 74 03        RSHIFT_2        stz     DSTACK+1,x              ; Clear top value
  1247 00:09CA: 4C FA 0C                     jmp     NEXT                    ; Done
  1248                        
  1249                        ; XOR ( x1 x2 -- x3 )
  1250                        ;
  1251                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1252                        
  1253 00:09CD: A9 09 00                     HEADER  NORMAL
  1254 00:09D0: 03 58 4F 52                  db      3,"XOR"
  1255                        XOR:
  1256 00:09D4: B5 03                        lda     DSTACK+1,x
  1257 00:09D6: 55 05                        eor     DSTACK+3,x
  1258 00:09D8: 95 05                        sta     DSTACK+3,x
  1259 00:09DA: E8                           inx
  1260 00:09DB: E8                           inx
  1261 00:09DC: 4C FA 0C                     jmp     NEXT
  1262                        
  1263                        ;==============================================================================
  1264                        ; Control Words
  1265                        ;------------------------------------------------------------------------------
  1266                        
  1267                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1268                        ;
  1269                        ; Empty the data stack and perform the function of QUIT, which includes
  1270                        ; emptying the return stack, without displaying a message.
  1271                        
  1272 00:09DF: CD 09 00                     HEADER  NORMAL
  1273 00:09E2: 05 41 42 4F                  db      5,"ABORT"
       00:09E6: 52 54 
  1274 00:09E8: 4C F5 0C     ABORT:          jmp     DO_COLON
  1275 00:09EB: EF 09                        dw      DO_ABORT
  1276 00:09ED: 52 0A                        dw      QUIT
  1277                        
  1278                        DO_ABORT:
  1279 00:09EF: A2 81 00                     ldx     #DSTACK_INIT
  1280 00:09F2: 4C FA 0C                     jmp     NEXT
  1281                        
  1282                        ; (BUILD) ( dtc-addr -- )
  1283                        ;
  1284                        ; Adds a jump the to exection function for the new word.
  1285                        
  1286 00:09F5: DF 09 00                     HEADER  NORMAL
  1287 00:09F8: 07 28 42 55                  db      7,"(BUILD)"
  Sun Nov 22 2015 10:55                                                                                                    Page 26


       00:09FC: 49 4C 44 29 
  1288 00:0A00: 4C F5 0C     BUILD:          jmp     DO_COLON
  1289 00:0A03: C3 0D 4C 00                  dw      DO_LITERAL,$4c,C_COMMA
       00:0A07: 17 06 
  1290 00:0A09: 99 05 46 0A                  dw      COMMA,EXIT
  1291                        
  1292                        ; CREATE ( -- )
  1293                        ;
  1294                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1295                        ; definition for name with the execution semantics defined below. If the data-
  1296                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1297                        ; data-space pointer defines name’s data field. CREATE does not allocate data
  1298                        ; space in name’s data field.
  1299                        
  1300 00:0A0D: F5 09 00                     HEADER  NORMAL
  1301 00:0A10: 06 43 52 45                  db      6,"CREATE"
       00:0A14: 41 54 45 
  1302 00:0A17: 4C F5 0C     CREATE:         jmp     DO_COLON
  1303                                        ; parse
  1304 00:0A1A: 49 06 AB 04                  dw      HERE,LATEST,FETCH,COMMA
       00:0A1E: D9 05 99 05 
  1305 00:0A22: 00 05 17 06                  dw      ZERO,C_COMMA,LATEST,STORE
       00:0A26: AB 04 6A 05 
  1306                                        ; move name
  1307 00:0A2A: 46 0A                        dw      EXIT
  1308                                        
  1309                        ; EXECUTE
  1310                        
  1311 00:0A2C: 0D 0A 00                     HEADER  NORMAL
  1312 00:0A2F: 07 45 58 45                  db      7,"EXECUTE"
       00:0A33: 43 55 54 45 
  1313                        EXECUTE:
  1314 00:0A37: B5 03                        lda     DSTACK+1,x
  1315 00:0A39: E8                           inx
  1316 00:0A3A: E8                           inx
  1317 00:0A3B: 3A                           dec     a
  1318 00:0A3C: 48                           pha
  1319 00:0A3D: 60                           rts
  1320                        
  1321                        ; EXIT ( -- ) ( R: nest-sys -- )
  1322                        
  1323 00:0A3E: 2C 0A 00                     HEADER  NORMAL
  1324 00:0A41: 04 45 58 49                  db      4,"EXIT"
       00:0A45: 54 
  1325                        EXIT:
  1326 00:0A46: 7A                           ply
  1327 00:0A47: 4C FA 0C                     jmp     NEXT
  1328                        
  1329                        ; QUIT ( -- ) ( R: i*x -- )
  1330                        ;
  1331                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1332                        ; user input device the input source, and enter interpretation state. Do not
  1333                        ; display a message. Repeat the following:
  1334                        ; – Accept a line from the input source into the input buffer, set >IN to zero,
  1335                        ;   and interpret.
  1336                        ; – Display the implementation-defined system prompt if in interpretation state,
  1337                        ;   all processing has been completed, and no ambiguous condition exists.
  1338                        ;
  Sun Nov 22 2015 10:55                                                                                                    Page 27


  1339                        ; In this implementation it is defined as:
  1340                        ;
  1341                        ;   DO_QUIT 0 STATE !
  1342                        ;   0 (SOURCE-ID) !
  1343                        ;   BEGIN
  1344                        ;       REFILL
  1345                        ;       WHILE SOURCE EVALUATE
  1346                        ;       STATE @ 0= IF CR S" OK" TYPE THEN
  1347                        ;   AGAIN ;
  1348                        
  1349 00:0A4A: 3E 0A 00                     HEADER  NORMAL
  1350 00:0A4D: 04 51 55 49                  db      4,"QUIT"
       00:0A51: 54 
  1351 00:0A52: 4C F5 0C     QUIT:           jmp     DO_COLON
  1352 00:0A55: 80 0A                        dw      DO_QUIT
  1353 00:0A57: 00 05 EA 04                  dw      ZERO,STATE,STORE
       00:0A5B: 6A 05 
  1354 00:0A5D: 00 05 DC 04                  dw      ZERO,SOURCEID,STORE
       00:0A61: 6A 05 
  1355 00:0A63: A0 0B 91 0D  QUIT_1:         dw      REFILL,QUERY_BRANCH,QUIT_2
       00:0A67: 6B 0A 
  1356 00:0A69: 36 0B                        dw      INTERPRET
  1357 00:0A6B: EA 04 D9 05  QUIT_2:         dw      STATE,FETCH,ZERO_EQUAL
       00:0A6F: 07 09 
  1358 00:0A71: 91 0D 7C 0A                  dw      QUERY_BRANCH,QUIT_3
  1359 00:0A75: 55 0E                        dw      DO_S_QUOTE
  1360 00:0A77: 02 4F 6B                     db      2,"Ok"
  1361 00:0A7A: E7 0E        		dw	TYPE
  1362 00:0A7C: 7F 0D 63 0A  QUIT_3:         dw      BRANCH,QUIT_1
  1363                        
  1364                        DO_QUIT:
  1365 00:0A80: A9 FF 01                     lda     #RSTACK_INIT            ; Reset the return stack
  1366 00:0A83: 1B                           tcs
  1367 00:0A84: 4C FA 0C                     jmp     NEXT                    ; Done
  1368                        
  1369                        ;==============================================================================
  1370                        ; Parser & Interpreter
  1371                        ;------------------------------------------------------------------------------
  1372                        
  1373                        ; ?NUMBER
  1374                        
  1375 00:0A87: 4A 0A 00                     HEADER  NORMAL
  1376 00:0A8A: 07 3F 4E 55                  db      7,"?NUMBER"
       00:0A8E: 4D 42 45 52 
  1377 00:0A92: F5           QUERY_NUMBER:   db      DO_COLON
  1378                        
  1379 00:0A93: 46 0A                        dw      EXIT
  1380                        
  1381                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1382                        ;
  1383                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1384                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1385                        ; received. A program that depends on the presence or absence of non-graphic
  1386                        ; characters in the string has an environmental dependency. The editing
  1387                        ; functions, if any, that the system performs in order to construct the string
  1388                        ; are implementation-defined.
  1389                        ;
  1390                        ; Input terminates when an implementation-defined line terminator is received.
  Sun Nov 22 2015 10:55                                                                                                    Page 28


  1391                        ; When input terminates, nothing is appended to the string, and the display is
  1392                        ; maintained in an implementation-defined way.
  1393                        ;
  1394                        ; +n2 is the length of the string stored at c-addr.
  1395                        ;
  1396                        ;   OVER + 1- OVER      -- sa ea a
  1397                        ;   BEGIN KEY           -- sa ea a c
  1398                        ;   DUP 0D <> WHILE
  1399                        ;       DUP EMIT        -- sa ea a c
  1400                        ;       DUP 8 = IF  DROP 1-
  1401                        ;             >R OVER R> UMAX
  1402                        ;             ELSE  OVER C! 1+ OVER UMIN
  1403                        ;       THEN            -- sa ea a
  1404                        ;   REPEAT              -- sa ea a c
  1405                        ;   DROP NIP SWAP - ;
  1406                        
  1407 00:0A95: 87 0A 00                     HEADER  NORMAL
  1408 00:0A98: 06 41 43 43                  db      6,"ACCEPT"
       00:0A9C: 45 50 54 
  1409 00:0A9F: 4C F5 0C     ACCEPT:         jmp     DO_COLON
  1410 00:0AA2: 48 07 21 08                  dw      OVER,PLUS,ONE_MINUS,OVER
       00:0AA6: 4F 08 48 07 
  1411 00:0AAA: 9F 0E 27 07  ACCEPT_1:       dw      KEY,DUP,DO_LITERAL,$0D,NOT_EQUAL
       00:0AAE: C3 0D 0D 00 
       00:0AB2: 2B 09 
  1412 00:0AB4: 91 0D F0 0A                  dw      QUERY_BRANCH,ACCEPT_4
  1413 00:0AB8: 27 07 8E 0E                  dw      DUP,EMIT
  1414 00:0ABC: 27 07 C3 0D                  dw      DUP,DO_LITERAL,$08,EQUAL
       00:0AC0: 08 00 3F 09 
  1415 00:0AC4: 48 07 C3 0D                  dw      OVER,DO_LITERAL,$7f,EQUAL,OR
       00:0AC8: 7F 00 3F 09 
       00:0ACC: 9E 09 
  1416 00:0ACE: 91 0D E2 0A                  dw      QUERY_BRANCH,ACCEPT_2
  1417 00:0AD2: 1B 07 4F 08                  dw      DROP,ONE_MINUS
  1418 00:0AD6: BB 07 48 07                  dw      TO_R,OVER,R_FROM,UMAX,BRANCH,ACCEPT_3
       00:0ADA: E5 07 9E 08 
       00:0ADE: 7F 0D EC 0A 
  1419 00:0AE2: 48 07 FD 05  ACCEPT_2:       dw      OVER,C_STORE,ONE_PLUS,OVER,UMIN
       00:0AE6: 44 08 48 07 
       00:0AEA: B2 08 
  1420 00:0AEC: 7F 0D AA 0A  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1421 00:0AF0: 1B 07 37 07  ACCEPT_4:       dw      DROP,NIP,SWAP,MINUS,EXIT
       00:0AF4: 59 07 32 08 
       00:0AF8: 46 0A 
  1422                        
  1423                        ; EVALUATE ( i*x c-addr u -- j*x )
  1424                        ;
  1425                        ; Save the current input source specification. Store minus-one (-1) in
  1426                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1427                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1428                        ; parse area is empty, restore the prior input source specification. Other
  1429                        ; stack effects are due to the words EVALUATEd.
  1430                        ;
  1431                        ;   >R >R SAVE-INPUT
  1432                        ;   -1 (SOURCE-ID) !
  1433                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1434                        ;   INTERPRET
  1435                        ;   RESTORE-INPUT DROP
  Sun Nov 22 2015 10:55                                                                                                    Page 29


  1436                        
  1437 00:0AFA: 95 0A 00                     HEADER  NORMAL
  1438 00:0AFD: 08 45 56 41                  db      8,"EVALUATE"
       00:0B01: 4C 55 41 54 
       00:0B05: 45 
  1439 00:0B06: 4C F5 0C     EVALUATE:       jmp     DO_COLON
  1440 00:0B09: BB 07 BB 07                  dw      TO_R,TO_R,SAVE_INPUT
       00:0B0D: 03 0C 
  1441 00:0B0F: E5 07 E5 07                  dw      R_FROM,R_FROM
  1442 00:0B13: 2F 05 DC 04                  dw      TRUE,SOURCEID,STORE
       00:0B17: 6A 05 
  1443 00:0B19: 00 05 67 04                  dw      ZERO,TO_IN,STORE
       00:0B1D: 6A 05 
  1444 00:0B1F: BC 04 6A 05                  dw      LENGTH,STORE
  1445 00:0B23: 91 04 6A 05                  dw      BUFFER,STORE
  1446 00:0B27: 36 0B                        dw      INTERPRET
  1447 00:0B29: DE 0B 1B 07                  dw      RESTORE_INPUT,DROP
  1448 00:0B2D: 46 0A                        dw      EXIT
  1449                        
  1450                        ; INTERPRET ( -- )
  1451                        ;
  1452                        ;
  1453                        ;   BEGIN
  1454                        ;   BL WORD DUP C@ WHILE        -- textadr
  1455                        ;       FIND                    -- a 0/1/-1
  1456                        ;       ?DUP IF                 -- xt 1/-1
  1457                        ;           1+ STATE @ 0= OR    immed or interp?
  1458                        ;           IF EXECUTE ELSE ,XT THEN
  1459                        ;       ELSE                    -- textadr
  1460                        ;           ?NUMBER
  1461                        ;           IF POSTPONE LITERAL     converted ok
  1462                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1463                        ;           THEN
  1464                        ;       THEN
  1465                        ;   REPEAT DROP ;
  1466                        
  1467 00:0B2F: FA 0A 36                     HEADER  INTERPRET
  1468 00:0B32: 09 00 54 45                  dw      9,"INTERPRET"
  1469 00:0B36: 4C F5 0C     INTERPRET:      jmp     DO_COLON
  1470 00:0B39: 0D 05 4D 0C  INTERPRET_1:    dw      BL,WORD,DUP,C_FETCH,QUERY_BRANCH,INTERPRET_7
       00:0B3D: 27 07 2E 06 
       00:0B41: 91 0D 85 0B 
  1471 00:0B45: 91 0B 08 07                  dw      FIND,QUERY_DUP,QUERY_BRANCH,INTERPRET_4
       00:0B49: 91 0D 67 0B 
  1472 00:0B4D: 44 08 EA 04                  dw      ONE_PLUS,STATE,FETCH,ZERO_EQUAL,OR
       00:0B51: D9 05 07 09 
       00:0B55: 9E 09 
  1473 00:0B57: 91 0D 61 0B                  dw      QUERY_BRANCH,INTERPRET_2,EXECUTE,BRANCH,INTERPRET_3
       00:0B5B: 37 0A 7F 0D 
       00:0B5F: 63 0B 
  1474 00:0B61: 99 05        INTERPRET_2:    dw      COMMA
  1475 00:0B63: 7F 0D 81 0B  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1476 00:0B67: 92 0A 91 0D  INTERPRET_4:    dw      QUERY_NUMBER,QUERY_BRANCH,INTERPRET_5
       00:0B6B: 73 0B 
  1477 00:0B6D: A9 0D 7F 0D                  dw      LITERAL,BRANCH,INTERPRET_6
       00:0B71: 81 0B 
  1478 00:0B73: 5A 00 E7 0E  INTERPRET_5:    dw      COUNT,TYPE,DO_LITERAL,$3f,EMIT,CR,ABORT
       00:0B77: C3 0D 3F 00 
  Sun Nov 22 2015 10:55                                                                                                    Page 30


       00:0B7B: 8E 0E 75 0E 
       00:0B7F: E8 09 
  1479 00:0B81: 7F 0D 39 0B  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1480 00:0B85: 1B 07 46 0A  INTERPRET_7:    dw      DROP,EXIT
  1481                        
  1482                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  1483                        ;
  1484                        ; Find the definition named in the counted string at c-addr. If the definition
  1485                        ; is not found, return c-addr and zero. If the definition is found, return its
  1486                        ; execution token xt. If the definition is immediate, also return one (1),
  1487                        ; otherwise also return minus-one (-1). For a given string, the values returned
  1488                        ; by FIND while compiling may differ from those returned while not compiling.
  1489                        ;
  1490                        ;   LATEST @ BEGIN             -- a nfa
  1491                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  1492                        ;       N=                     -- a nfa f
  1493                        ;       DUP IF
  1494                        ;           DROP
  1495                        ;           NFA>LFA H@ DUP     -- a link link
  1496                        ;       THEN
  1497                        ;   0= UNTIL                   -- a nfa  OR  a 0
  1498                        ;   DUP IF
  1499                        ;       NIP DUP NFA>CFA        -- nfa xt
  1500                        ;       SWAP IMMED?            -- xt iflag
  1501                        ;       0= 1 OR                -- xt 1/-1
  1502                        ;   THEN ;
  1503                        
  1504 00:0B89: 2F 0B 00                     HEADER  NORMAL
  1505 00:0B8C: 04 46 49 4E                  db      4,"FIND"
       00:0B90: 44 
  1506 00:0B91: 4C F5 0C     FIND:           jmp     DO_COLON
  1507                        
  1508                        
  1509                        
  1510 00:0B94: 46 0A                        dw      EXIT
  1511                        
  1512                        ; REFILL ( -- flag )
  1513                        ;
  1514                        ; Attempt to fill the input buffer from the input source, returning a true flag
  1515                        ; if successful.
  1516                        ;
  1517                        ; When the input source is the user input device, attempt to receive input into
  1518                        ; the terminal input buffer. If successful, make the result the input buffer,
  1519                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  1520                        ; is considered successful. If there is no input available from the current
  1521                        ; input source, return false.
  1522                        ;
  1523                        ; When the input source is a string from EVALUATE, return false and perform no
  1524                        ; other action.
  1525                        ;
  1526                        ;   SOURCE-ID 0= IF
  1527                        ;    TIB DUP #TIB @ ACCEPT SPACE
  1528                        ;    LENGTH ! BUFFER !
  1529                        ;    0 >IN ! TRUE EXIT
  1530                        ;   THEN
  1531                        ;   FALSE
  1532                        
  1533 00:0B96: 89 0B 00                     HEADER  NORMAL
  Sun Nov 22 2015 10:55                                                                                                    Page 31


  1534 00:0B99: 06 52 45 46                  db      6,"REFILL"
       00:0B9D: 49 4C 4C 
  1535 00:0BA0: 4C F5 0C     REFILL:         jmp     DO_COLON
  1536 00:0BA3: 3C 0C 07 09                  dw      SOURCE_ID,ZERO_EQUAL,QUERY_BRANCH,REFILL_1
       00:0BA7: 91 0D C9 0B 
  1537 00:0BAB: F6 04 27 07                  dw      TIB,DUP,HASH_TIB,FETCH,ACCEPT,SPACE
       00:0BAF: 59 04 D9 05 
       00:0BB3: 9F 0A B5 0E 
  1538 00:0BB7: BC 04 6A 05                  dw      LENGTH,STORE,BUFFER,STORE
       00:0BBB: 91 04 6A 05 
  1539 00:0BBF: 00 05 67 04                  dw      ZERO,TO_IN,STORE,TRUE,EXIT
       00:0BC3: 6A 05 2F 05 
       00:0BC7: 46 0A 
  1540 00:0BC9: 20 05 46 0A  REFILL_1:       dw      FALSE,EXIT
  1541                        
  1542                        ; RESTORE-INPUT
  1543                        
  1544 00:0BCD: 96 0B 00                     HEADER  NORMAL
  1545 00:0BD0: 0D 52 45 53                  db      13,"RESTORE-INPUT"
       00:0BD4: 54 4F 52 45 
       00:0BD8: 2D 49 4E 50 
       00:0BDC: 55 54 
  1546 00:0BDE: 4C F5 0C     RESTORE_INPUT   jmp     DO_COLON
  1547 00:0BE1: 67 04 6A 05                  dw      TO_IN,STORE
  1548 00:0BE5: BC 04 6A 05                  dw      LENGTH,STORE
  1549 00:0BE9: 91 04 6A 05                  dw      BUFFER,STORE
  1550 00:0BED: DC 04 6A 05                  dw      SOURCEID,STORE
  1551 00:0BF1: 2F 05 46 0A                  dw      TRUE,EXIT
  1552                        
  1553                        ; SAVE-INPUT
  1554                        
  1555 00:0BF5: CD 0B 00                     HEADER  NORMAL
  1556 00:0BF8: 0A 53 41 56                  db      10,"SAVE-INPUT"
       00:0BFC: 45 2D 49 4E 
       00:0C00: 50 55 54 
  1557 00:0C03: 4C F5 0C     SAVE_INPUT:     jmp     DO_COLON
  1558 00:0C06: DC 04 D9 05                  dw      SOURCEID,FETCH
  1559 00:0C0A: 91 04 D9 05                  dw      BUFFER,FETCH
  1560 00:0C0E: BC 04 D9 05                  dw      LENGTH,FETCH
  1561 00:0C12: 67 04 D9 05                  dw      TO_IN,FETCH,EXIT
       00:0C16: 46 0A 
  1562                        
  1563                        ; SOURCE ( -- c-addr u )
  1564                        ;
  1565                        ; c-addr is the address of, and u is the number of characters in, the input
  1566                        ; buffer.
  1567                        ;
  1568                        ; In this implementation it is defined as
  1569                        ;
  1570                        ;   BUFFER @ LENGTH @
  1571                        
  1572 00:0C18: F5 0B 00                     HEADER  NORMAL
  1573 00:0C1B: 06 53 4F 55                  db      6,"SOURCE"
       00:0C1F: 52 43 45 
  1574 00:0C22: 4C F5 0C     SOURCE:         jmp     DO_COLON
  1575 00:0C25: 91 04 D9 05                  dw      BUFFER,FETCH
  1576 00:0C29: BC 04 D9 05                  dw      LENGTH,FETCH
  1577 00:0C2D: 46 0A                        dw      EXIT
  Sun Nov 22 2015 10:55                                                                                                    Page 32


  1578                        
  1579                        ; SOURCE-ID ( -- 0 | -1 )
  1580                        ;
  1581                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  1582                        ; device.
  1583                        
  1584 00:0C2F: 18 0C 00                     HEADER  NORMAL
  1585 00:0C32: 09 53 4F 55                  db      9,"SOURCE-ID"
       00:0C36: 52 43 45 2D 
       00:0C3A: 49 44 
  1586 00:0C3C: 4C F5 0C     SOURCE_ID:      jmp     DO_COLON
  1587 00:0C3F: DC 04 D9 05                  dw      SOURCEID,FETCH,EXIT
       00:0C43: 46 0A 
  1588                        
  1589                        ; WORD
  1590                        ;
  1591                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  1592                        ;   DUP >R   ROT SKIP           -- c adr' n'
  1593                        ;   OVER >R  ROT SCAN           -- adr" n"
  1594                        ;   DUP IF CHAR- THEN        skip trailing delim.
  1595                        ;   R> R> ROT -   >IN +!        update >IN offset
  1596                        ;   TUCK -                      -- adr' N
  1597                        ;   HERE >counted               --
  1598                        ;   HERE                        -- a
  1599                        ;   BL OVER COUNT + C! ;    append trailing blank
  1600                        
  1601 00:0C45: 2F 0C 00                     HEADER  NORMAL
  1602 00:0C48: 04 57 4F 52                  db      4,"WORD"
       00:0C4C: 44 
  1603 00:0C4D: 4C F5 0C     WORD:           jmp     DO_COLON
  1604 00:0C50: 27 07 22 0C                  dw      DUP,SOURCE,TO_IN,FETCH,SLASH_STRING
       00:0C54: 67 04 D9 05 
       00:0C58: 91 0C 
  1605 00:0C5A: 27 07 BB 07                  dw      DUP,TO_R,ROT,SKIP
       00:0C5E: 03 08 6C 0C 
  1606 00:0C62: 48 07 BB 07                  dw      OVER,TO_R,ROT,SCAN
       00:0C66: 03 08 71 0C 
  1607                        
  1608 00:0C6A: 46 0A                        dw      EXIT
  1609                        
  1610 00:0C6C: 4C F5 0C     SKIP:           jmp     DO_COLON
  1611                        
  1612 00:0C6F: 46 0A                        dw      EXIT
  1613                        
  1614 00:0C71: 4C F5 0C     SCAN:           jmp     DO_COLON
  1615                        
  1616 00:0C74: 46 0A                        dw      EXIT
  1617                        
  1618                        ;==============================================================================
  1619                        ; String Words
  1620                        ;------------------------------------------------------------------------------
  1621                        
  1622                        ; -TRAILING
  1623                        
  1624 00:0C76: 45 0C 00                     HEADER  NORMAL
  1625 00:0C79: 09 2D 54 52                  db      9,"-TRAILING"
       00:0C7D: 41 49 4C 49 
       00:0C81: 4E 47 
  Sun Nov 22 2015 10:55                                                                                                    Page 33


  1626 00:0C83: 4C F5 0C     DASH_TRAILING:  jmp     DO_COLON
  1627                        
  1628                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  1629                        ;
  1630                        ; Adjust the character string at c-addr1 by n characters. The resulting
  1631                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  1632                        ; characters and is u1 minus n characters long.
  1633                        ;
  1634                        ;   ROT OVER + ROT ROT -
  1635                        
  1636 00:0C86: 76 0C 00                     HEADER  NORMAL
  1637 00:0C89: 07 2F 53 54                  db      7,"/STRING"
       00:0C8D: 52 49 4E 47 
  1638 00:0C91: 4C F5 0C     SLASH_STRING:   jmp     DO_COLON
  1639 00:0C94: 03 08 48 07                  dw      ROT,OVER,PLUS
       00:0C98: 21 08 
  1640 00:0C9A: 03 08 03 08                  dw      ROT,ROT,MINUS,EXIT
       00:0C9E: 32 08 46 0A 
  1641                        
  1642                        ; BLANK
  1643                        
  1644                        ; CMOVE ( c-addr1 c-addr2 u -- )
  1645                        ;
  1646                        ; If u is greater than zero, copy u consecutive characters from the data space
  1647                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1648                        ; character from lower addresses to higher addresses.
  1649                        
  1650 00:0CA2: 86 0C 00     		HEADER	NORMAL
  1651 00:0CA5: 05 43 4D 4F  		db	5,"CMOVE"
       00:0CA9: 56 45 
  1652                        CMOVE:
  1653 00:0CAB: B5 03        		lda	DSTACK+1,x		; Any data to move?
  1654 00:0CAD: D0 03        		bne	$+5
  1655 00:0CAF: 4C FA 0C     		jmp	NEXT			; Done
  1656 00:0CB2: E2 20        		short_a
  1657 00:0CB4: A1 07        		lda	(DSTACK+5,x)		; Move a byte
  1658 00:0CB6: 81 05        		sta	(DSTACK+3,x)
  1659 00:0CB8: C2 20        		long_a
  1660 00:0CBA: F6 07        		inc	DSTACK+5,x		; Adjust the address
  1661 00:0CBC: F6 05        		inc	DSTACK+3,x
  1662 00:0CBE: D6 03        		dec	DSTACK+1,x		; Adjust the count
  1663 00:0CC0: 80 E9        		bra	CMOVE			; And try again
  1664                        
  1665                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  1666                        ;
  1667                        ; If u is greater than zero, copy u consecutive characters from the data space
  1668                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1669                        ; character from higher addresses to lower addresses.
  1670                        
  1671 00:0CC2: A2 0C 00     		HEADER	NORMAL
  1672 00:0CC5: 06 43 4D 4F  		db	6,"CMOVE>"
       00:0CC9: 56 45 3E 
  1673                        CMOVE_GREATER:
  1674 00:0CCC: 4C FA 0C     		jmp	NEXT
  1675                        
  1676                        ; COMPARE
  1677                        
  1678                        ; SEARCH
  Sun Nov 22 2015 10:55                                                                                                    Page 34


  1679                        
  1680                        
  1681                        ;==============================================================================
  1682                        ; Compiling Words
  1683                        ;------------------------------------------------------------------------------
  1684                        
  1685                        ; +LOOP ( -- )
  1686                        
  1687 00:0CCF: C2 0C 80                     HEADER  IMMEDIATE
  1688 00:0CD2: 05 2B 4C 4F                  db      5,"+LOOP"
       00:0CD6: 4F 50 
  1689 00:0CD8: 4C F5 0C     PLUS_LOOP:      jmp     DO_COLON
  1690                        
  1691 00:0CDB: 46 0A                        dw      EXIT
  1692                        
  1693                        ; (+LOOP)
  1694                        
  1695 00:0CDD: CF 0C 00                     HEADER  NORMAL
  1696 00:0CE0: 07 28 2B 4C                  db      7,"(+LOOP)"
       00:0CE4: 4F 4F 50 29 
  1697                        DO_PLUS_LOOP:
  1698                        
  1699 00:0CE8: 4C FA 0C                     jmp     NEXT
  1700                        
  1701                        ; : ( -- )
  1702                        
  1703 00:0CEB: DD 0C 00                     HEADER  NORMAL
  1704 00:0CEE: 01 3A                        db      1,":"
  1705 00:0CF0: 4C F5 0C     COLON:          jmp     DO_COLON
  1706                        
  1707 00:0CF3: 46 0A                        dw      EXIT
  1708                        
  1709                        DO_COLON:
  1710 00:0CF5: 5A                           phy                             ; Save the instruction pointer
  1711 00:0CF6: A8                           tay                             ; Calculate the new IP
  1712 00:0CF7: C8                           iny
  1713 00:0CF8: C8                           iny
  1714 00:0CF9: C8                           iny
  1715                        NEXT:
  1716 00:0CFA: B9 00 00                     lda     0,y                     ; Fetch the next word address
  1717 00:0CFD: 85 00                        sta     WA
  1718 00:0CFF: C8                           iny                             ; Bump the instruction pointer
  1719 00:0D00: C8                           iny
  1720 00:0D01: 6C 00 00                     jmp     (!WA)                   ; And execute word
  1721                        
  1722                        ; AGAIN
  1723                        
  1724 00:0D04: EB 0C 80                     HEADER  IMMEDIATE
  1725 00:0D07: 05 00 4E 49                  dw      5,"AGAIN"
  1726 00:0D0B: 4C F5 0C     AGAIN:          jmp     DO_COLON
  1727                        
  1728 00:0D0E: 46 0A                        dw      EXIT
  1729                        
  1730                        ; BEGIN
  1731                        
  1732 00:0D10: 04 0D 80                     HEADER  IMMEDIATE
  1733 00:0D13: 05 00 4E 49                  dw      5,"BEGIN"
  1734 00:0D17: 4C F5 0C     BEGIN:          jmp     DO_COLON
  Sun Nov 22 2015 10:55                                                                                                    Page 35


  1735                        
  1736 00:0D1A: 46 0A                        dw      EXIT
  1737                        
  1738                        ; CONSTANT ( x “<spaces>name” -- )
  1739                        ;
  1740                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1741                        ; definition for name with the execution semantics defined below.
  1742                        
  1743 00:0D1C: 10 0D 00                     HEADER  NORMAL
  1744 00:0D1F: 08 43 4F 4E                  db      8,"CONSTANT"
       00:0D23: 53 54 41 4E 
       00:0D27: 54 
  1745 00:0D28: 4C F5 0C     CONSTANT:       jmp     DO_COLON
  1746 00:0D2B: 17 0A                        dw      CREATE
  1747 00:0D2D: C3 0D 45 0D                  dw      DO_LITERAL,DO_CONSTANT,BUILD
       00:0D31: 00 0A 
  1748 00:0D33: 99 05 46 0A                  dw      COMMA,EXIT
  1749                        
  1750                        ; (CONSTANT) ( -- x )
  1751                        
  1752 00:0D37: 1C 0D 00                     HEADER  NORMAL
  1753 00:0D3A: 0A 28 43 4F                  db      10,"(CONSTANT)"
       00:0D3E: 4E 53 54 41 
       00:0D42: 4E 54 29 
  1754                        DO_CONSTANT:
  1755 00:0D45: 5A                           phy                             ; Save IP
  1756 00:0D46: A8                           tay                             ; Fetch constant after WA
  1757 00:0D47: B9 03 00                     lda     3,y
  1758 00:0D4A: CA                           dex                             ; And push
  1759 00:0D4B: CA                           dex
  1760 00:0D4C: 95 03                        sta     DSTACK+1,x
  1761 00:0D4E: 7A                           ply
  1762 00:0D4F: 4C FA 0C                     jmp     NEXT                    ; Done
  1763                        
  1764                        ; DO ( -- )
  1765                        
  1766 00:0D52: 37 0D 80                     HEADER  IMMEDIATE
  1767 00:0D55: 02 44 4F                     db      2,"DO"
  1768 00:0D58: 4C F5 0C     DO:             jmp     DO_COLON
  1769                        
  1770 00:0D5B: 46 0A                        dw      EXIT
  1771                        
  1772                        ; (DO) ( -- )
  1773                        
  1774 00:0D5D: 52 0D 00                     HEADER  NORMAL
  1775 00:0D60: 04 28 44 4F                  db      4,"(DO)"
       00:0D64: 29 
  1776                        DO_DO:
  1777 00:0D65: B5 05                        lda     DSTACK+3,x
  1778 00:0D67: 48                           pha
  1779 00:0D68: B5 03                        lda     DSTACK+1,x
  1780 00:0D6A: 48                           pha
  1781 00:0D6B: E8                           inx
  1782 00:0D6C: E8                           inx
  1783 00:0D6D: E8                           inx
  1784 00:0D6E: E8                           inx
  1785 00:0D6F: 4C FA 0C                     jmp     NEXT
  1786                        
  Sun Nov 22 2015 10:55                                                                                                    Page 36


  1787                        ; ELSE
  1788                        
  1789 00:0D72: 5D 0D 80                     HEADER  IMMEDIATE
  1790 00:0D75: 04 45 4C 53                  db      4,"ELSE"
       00:0D79: 45 
  1791 00:0D7A: 4C F5 0C     ELSE:           jmp     DO_COLON
  1792                        
  1793 00:0D7D: 46 0A                        dw      EXIT
  1794                        
  1795                        ; (BRANCH) ( -- )
  1796                        ;
  1797                        ; Cause the IP to be loaded with the word following the link to this word.
  1798                        
  1799                        BRANCH:
  1800 00:0D7F: B9 00 00                     lda     0,y                     ; Load branch address into IP
  1801 00:0D82: A8                           tay
  1802 00:0D83: 4C FA 0C                     jmp     NEXT                    ; Done
  1803                        
  1804                        
  1805                        
  1806                        ; IF
  1807                        
  1808 00:0D86: 72 0D 80                     HEADER  IMMEDIATE
  1809 00:0D89: 02 49 46                     db      2,"IF"
  1810 00:0D8C: 4C F5 0C     IF:             jmp     DO_COLON
  1811                        
  1812 00:0D8F: 46 0A                        dw      EXIT
  1813                        
  1814                        ; (?BRANCH) ( flag -- )
  1815                        ;
  1816                        ; If flag is false then cause the IP to be loaded with the word following the
  1817                        ; link to this word, otherwise skip over it.
  1818                        
  1819                        QUERY_BRANCH:
  1820 00:0D91: B5 03                        lda     DSTACK+1,x              ; Pull the top of stack value
  1821 00:0D93: 08                           php                             ; Save the flags
  1822 00:0D94: E8                           inx                             ; Drop top item
  1823 00:0D95: E8                           inx
  1824 00:0D96: 28                           plp
  1825 00:0D97: F0 E6                        beq     BRANCH                  ; Branch if top was zero
  1826 00:0D99: C8                           iny                             ; Otherwise skip address
  1827 00:0D9A: C8                           iny
  1828 00:0D9B: 4C FA 0C                     jmp     NEXT                    ; Done
  1829                        
  1830                        ; LITERAL ( x -- )
  1831                        ;
  1832                        ; Append the run-time semantics given below to the current definition.
  1833                        
  1834 00:0D9E: 86 0D 80                     HEADER  IMMEDIATE
  1835 00:0DA1: 07 4C 49 54                  db      7,"LITERAL"
       00:0DA5: 45 52 41 4C 
  1836 00:0DA9: 4C F5 0C     LITERAL:        jmp     DO_COLON
  1837 00:0DAC: C3 0D C3 0D                  dw      DO_LITERAL,DO_LITERAL,COMMA
       00:0DB0: 99 05 
  1838 00:0DB2: 99 05 46 0A                  dw      COMMA,EXIT
  1839                        
  1840                        ; (LITERAL) ( -- x )
  1841                        ;
  Sun Nov 22 2015 10:55                                                                                                    Page 37


  1842                        ; Place x on the stack.
  1843                        
  1844 00:0DB6: 9E 0D 00                     HEADER  NORMAL
  1845 00:0DB9: 0A 28 4C 49                  db      10,"(LITERAL)"
       00:0DBD: 54 45 52 41 
       00:0DC1: 4C 29 
  1846                        DO_LITERAL:
  1847 00:0DC3: B9 00 00                     lda     0,y                     ; Fetch constant from IP
  1848 00:0DC6: C8                           iny
  1849 00:0DC7: C8                           iny
  1850 00:0DC8: CA                           dex                             ; And push
  1851 00:0DC9: CA                           dex
  1852 00:0DCA: 95 03                        sta     DSTACK+1,x
  1853 00:0DCC: 4C FA 0C                     jmp     NEXT                    ; Done
  1854                        
  1855                        ; LOOP
  1856                        
  1857 00:0DCF: B6 0D 80                     HEADER  IMMEDIATE
  1858 00:0DD2: 04 4C 4F 4F                  db      4,"LOOP"
       00:0DD6: 50 
  1859 00:0DD7: 4C F5 0C     LOOP:           jmp     DO_COLON
  1860                        
  1861 00:0DDA: 46 0A                        dw      EXIT
  1862                        
  1863                        ; (LOOP)
  1864                        
  1865 00:0DDC: CF 0D 00                     HEADER  NORMAL
  1866 00:0DDF: 06 28 4C 4F                  db      6,"(LOOP)"
       00:0DE3: 4F 50 29 
  1867                        DO_LOOP
  1868 00:0DE6: A3 01                        lda     1,s                     ; Add one to loop counter
  1869 00:0DE8: 1A                           inc     a
  1870 00:0DE9: 83 01                        sta     1,s
  1871 00:0DEB: C3 03                        cmp     3,s                     ; Reached limit?
  1872 00:0DED: B0 07                        bcs     DO_LOOP_END             ; Yes
  1873 00:0DEF: B9 00 00                     lda     0,y                     ; No, branch back to start
  1874 00:0DF2: A8                           tay
  1875 00:0DF3: 4C FA 0C                     jmp     NEXT                    ; Done
  1876 00:0DF6: C8           DO_LOOP_END:    iny                             ; Skip over address
  1877 00:0DF7: C8                           iny
  1878 00:0DF8: 68           		pla				; Drop loop variables
  1879 00:0DF9: 68           		pla
  1880 00:0DFA: 4C FA 0C                     jmp     NEXT                    ; Done
  1881                        
  1882                        ; USER
  1883                        
  1884 00:0DFD: DC 0D 00                     HEADER  NORMAL
  1885 00:0E00: 04 55 53 45                  db      4,"USER"
       00:0E04: 52 
  1886 00:0E05: 4C F5 0C     USER:           jmp     DO_COLON
  1887                        
  1888 00:0E08: 46 0A                        dw      EXIT
  1889                        
  1890 00:0E0A: FD 0D 00                     HEADER  NORMAL
  1891 00:0E0D: 06 28 55 53                  db      6,"(USER)"
       00:0E11: 45 52 29 
  1892                        DO_USER:
  1893 00:0E14: 5A                           phy                             ; Save the IP
  Sun Nov 22 2015 10:55                                                                                                    Page 38


  1894 00:0E15: A8                           tay                             ; Fetch offset after WA
  1895 00:0E16: B9 03 00                     lda     3,y
  1896 00:0E19: 18                           clc                             ; Work out address in user area
  1897 00:0E1A: 69 10 02                     adc     #USER_AREA
  1898 00:0E1D: CA                           dex                             ; Push on data stack
  1899 00:0E1E: CA                           dex
  1900 00:0E1F: 95 03                        sta     DSTACK+1,x
  1901 00:0E21: 7A                           ply                             ; Restore IP
  1902 00:0E22: 4C FA 0C                     jmp     NEXT                    ; Done
  1903                        
  1904                        ; VARIABLE
  1905                        
  1906 00:0E25: 0A 0E 00                     HEADER  NORMAL
  1907 00:0E28: 08 56 41 52                  db      8,"VARIABLE"
       00:0E2C: 49 41 42 4C 
       00:0E30: 45 
  1908 00:0E31: 4C F5 0C     VARIABLE:       jmp     DO_COLON
  1909                        
  1910 00:0E34: 46 0A                        dw      EXIT
  1911                        
  1912 00:0E36: 25 0E 00                     HEADER  NORMAL
  1913 00:0E39: 0A 28 56 41                  db      10,"(VARIABLE)"
       00:0E3D: 52 49 41 42 
       00:0E41: 4C 45 29 
  1914                        DO_VARIABLE:
  1915 00:0E44: 18                           clc
  1916 00:0E45: 69 03 00                     adc     #3
  1917 00:0E48: CA                           dex
  1918 00:0E49: CA                           dex
  1919 00:0E4A: 95 03                        sta     DSTACK+1,x
  1920 00:0E4C: 4C FA 0C                     jmp     NEXT
  1921                        
  1922                        
  1923                        
  1924                        
  1925                        
  1926 00:0E4F: 36 0E 80                     HEADER  IMMEDIATE
  1927 00:0E52: 02 53 22                     db      2,"S",'"'
  1928                        S_QUOTE:
  1929                        
  1930                        ; (S") ( -- c-addr u )
  1931                        
  1932                        DO_S_QUOTE:
  1933 00:0E55: CA                           dex                             ; Reserve space for values
  1934 00:0E56: CA                           dex
  1935 00:0E57: CA                           dex
  1936 00:0E58: CA                           dex
  1937 00:0E59: E2 20                        short_a
  1938 00:0E5B: B9 00 00                     lda     0,y                     ; Fetch the length
  1939 00:0E5E: C2 20                        long_a
  1940 00:0E60: 29 FF 00                     and     #$00ff
  1941 00:0E63: 95 03                        sta     DSTACK+1,x
  1942 00:0E65: C8                           iny                             ; Save the text address
  1943 00:0E66: 94 05                        sty     DSTACK+3,x
  1944 00:0E68: 18                           clc                             ; And update IP
  1945 00:0E69: 75 05                        adc     DSTACK+3,X
  1946 00:0E6B: A8                           tay
  1947 00:0E6C: 4C FA 0C                     jmp     NEXT                    ; Done
  Sun Nov 22 2015 10:55                                                                                                    Page 39


  1948                        
  1949                        ;==============================================================================
  1950                        ; I/O Operations
  1951                        ;------------------------------------------------------------------------------
  1952                        
  1953                        ; CR ( -- )
  1954                        ;
  1955                        ; Cause subsequent output to appear at the beginning of the next line.
  1956                        ;
  1957                        ; In this implementation it is defined as
  1958                        ;
  1959                        ;   13 EMIT 10 EMIT
  1960                        
  1961 00:0E6F: 4F 0E 00                     HEADER  NORMAL
  1962 00:0E72: 02 43 52                     db      2,"CR"
  1963 00:0E75: 4C F5 0C     CR:             jmp     DO_COLON
  1964 00:0E78: C3 0D 0D 00                  dw      DO_LITERAL,13,EMIT
       00:0E7C: 8E 0E 
  1965 00:0E7E: C3 0D 0A 00                  dw      DO_LITERAL,10,EMIT
       00:0E82: 8E 0E 
  1966 00:0E84: 46 0A                        dw      EXIT
  1967                        
  1968                        ; EMIT ( x -- )
  1969                        ;
  1970                        ; If x is a graphic character in the implementation-defined character set,
  1971                        ; display x. The effect of EMIT for all other values of x is implementation
  1972                        ; -defined.
  1973                        
  1974 00:0E86: 6F 0E 00                     HEADER  NORMAL
  1975 00:0E89: 04 45 4D 49                  db      4,"EMIT"
       00:0E8D: 54 
  1976                                        extern  UartTx
  1977                        EMIT:
  1978 00:0E8E: B5 03                        lda     DSTACK+1,X              ; Fetch character from stack
  1979 00:0E90: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  1980 00:0E93: E8                           inx                             ; Drop the character
  1981 00:0E94: E8                           inx
  1982 00:0E95: 4C FA 0C                     jmp     NEXT                    ; Done
  1983                        
  1984                        ; KEY ( -- char )
  1985                        ;
  1986                        ; Receive one character char, a member of the implementation-defined character
  1987                        ; set. Keyboard events that do not correspond to such characters are discarded
  1988                        ; until a valid character is received, and those events are subsequently
  1989                        ; unavailable.
  1990                        ;
  1991                        ; All standard characters can be received. Characters received by KEY are not
  1992                        ; displayed.
  1993                        
  1994 00:0E98: 86 0E 00                     HEADER  NORMAL
  1995 00:0E9B: 03 4B 45 59                  db      3,"KEY"
  1996                                        extern  UartRx
  1997                        KEY:
  1998 00:0E9F: 20 xx xx                     jsr     UartRx                  ; Receive a character
  1999 00:0EA2: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2000 00:0EA5: CA                           dex                             ; And push to stack
  2001 00:0EA6: CA                           dex
  2002 00:0EA7: 95 03                        sta     DSTACK+1,x
  Sun Nov 22 2015 10:55                                                                                                    Page 40


  2003 00:0EA9: 4C FA 0C                     jmp     NEXT                    ; Done
  2004                        
  2005                        ; SPACE ( -- )
  2006                        ;
  2007                        ; Display one space.
  2008                        ;
  2009                        ; In this implementation it is defined as
  2010                        ;
  2011                        ;   SPACE EMIT
  2012                        
  2013 00:0EAC: 98 0E 00                     HEADER  NORMAL
  2014 00:0EAF: 05 53 50 41                  db      5,"SPACE"
       00:0EB3: 43 45 
  2015 00:0EB5: 4C F5 0C     SPACE:          jmp     DO_COLON
  2016 00:0EB8: 0D 05                        dw      BL
  2017 00:0EBA: 8E 0E                        dw      EMIT
  2018 00:0EBC: 46 0A                        dw      EXIT
  2019                        
  2020                        ; SPACES ( n -- )
  2021                        ;
  2022                        ; If n is greater than zero, display n spaces.
  2023                        ;
  2024                        ; In this implementation it is defined as
  2025                        ;
  2026                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2027                        
  2028 00:0EBE: AC 0E 00                     HEADER  NORMAL
  2029 00:0EC1: 06 53 50 41                  db      6,"SPACES"
       00:0EC5: 43 45 53 
  2030 00:0EC8: 4C F5 0C     SPACES:         jmp     DO_COLON
  2031 00:0ECB: 27 07 18 09  SPACES_1:       dw      DUP,ZERO_GREATER,QUERY_BRANCH,SPACES_2
       00:0ECF: 91 0D DB 0E 
  2032 00:0ED3: B5 0E 4F 08                  dw      SPACE,ONE_MINUS,BRANCH,SPACES_1
       00:0ED7: 7F 0D CB 0E 
  2033 00:0EDB: 1B 07 46 0A  SPACES_2:       dw      DROP,EXIT
  2034                        
  2035                        ; TYPE ( c-addr u -- )
  2036                        ;
  2037                        ; If u is greater than zero, display the character string specified by c-addr
  2038                        ; and u.
  2039                        ;
  2040                        ; In this implementation it is defined as
  2041                        ;
  2042                        ;   ?DUP IF
  2043                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2044                        ;   ELSE DROP THEN
  2045                        
  2046 00:0EDF: BE 0E 00                     HEADER  NORMAL
  2047 00:0EE2: 04 54 59 50                  db      4,"TYPE"
       00:0EE6: 45 
  2048 00:0EE7: 4C F5 0C     TYPE:           jmp     DO_COLON
  2049 00:0EEA: 08 07 91 0D                  dw      QUERY_DUP,QUERY_BRANCH,TYPE_2
       00:0EEE: 06 0F 
  2050 00:0EF0: 48 07 21 08                  dw      OVER,PLUS,SWAP,DO_DO
       00:0EF4: 59 07 65 0D 
  2051 00:0EF8: C8 07 2E 06  TYPE_1:         dw      I,C_FETCH,EMIT,DO_LOOP,TYPE_1
       00:0EFC: 8E 0E E6 0D 
       00:0F00: F8 0E 
  Sun Nov 22 2015 10:55                                                                                                    Page 41


  2052 00:0F02: 7F 0D 08 0F                  dw      BRANCH,TYPE_3
  2053 00:0F06: 1B 07        TYPE_2          dw      DROP
  2054 00:0F08: 46 0A        TYPE_3          dw      EXIT
  2055                        
  2056                        ;================================================================================
  2057                        ;--------------------------------------------------------------------------------
  2058                        
  2059                        ; #
  2060                        ; #>
  2061                        ; #S
  2062                        ; SIGN
  2063                        
  2064                        ;================================================================================
  2065                        ;--------------------------------------------------------------------------------
  2066                        
  2067                                        TRAILER
  2068                        NEXT_WORD:
  2069                        
  2070                                        end


      Lines assembled: 2704
      Errors: 0
