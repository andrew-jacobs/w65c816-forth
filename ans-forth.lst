  Mon Apr 18 2016 15:06                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;===============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;-------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is DP
    27                        ;
    28                        ; The Y register holds the forth instruction pointer and the direct page
    29                        ; register is used to access the word address pointer and user variables.
    30                        ;
    31                        ; Some of the high-level definitions are based on Bradford J. Rodriguez's
    32                        ; CamelForth implementations.
    33                        ;
    34                        ;-------------------------------------------------------------------------------
    35                        
    36                                        pw      132
    37                                        inclist on
    38                                        maclist off
    39                        
    40                                        chip    65816
    41                                        longi   off
    42                                        longa   off
    43                        
    44                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
  Mon Apr 18 2016 15:06                                                                                                    Page 2


     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;===============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;===============================================================================
    25                        ; Revision History:
    26                        ;
    27                        ; 2015-12-18 AJ Initial version
    28                        ;-------------------------------------------------------------------------------
    29                        ; $Id$
    30                        ;-------------------------------------------------------------------------------
    31                        
    32                        ;==============================================================================
    33                        ; Status Register Bits
    34                        ;------------------------------------------------------------------------------
    35                        
    36             00000080   N_FLAG          equ     1<<7
    37             00000040   V_FLAG          equ     1<<6
    38             00000020   M_FLAG          equ     1<<5
    39             00000010   X_FLAG          equ     1<<4
    40             00000010   B_FLAG          equ     1<<4
    41             00000008   D_FLAG          equ     1<<3
    42             00000004   I_FLAG          equ     1<<2
    43             00000002   Z_FLAG          equ     1<<1
    44             00000001   C_FLAG          equ     1<<0
    45                        
    46                        ;==============================================================================
    47                        ; Macros
    48                        ;------------------------------------------------------------------------------
    49                        
    50                        ; Puts the processor in emulation mode. A, X and Y become 8-bits and the stack
    51                        ; is fixed at $0100-$01ff. 
    52                        
    53                        emulate         macro
    54                                        sec
    55                                        xce
    56                                        endm
    57                        
    58                        ; Puts the processor in native mode. The size of the memory and index register
    59                        ; operations is not controlled by the M & X bits in the status register.
    60                        
    61                        native          macro
    62                                        clc
    63                                        xce
    64                                        endm
    65                        
    66                        ; Resets the M bit making the accumulator and memory accesses 16-bits wide.
  Mon Apr 18 2016 15:06                                                                                                    Page 3


    67                         
    68                        long_a          macro
    69                                        rep     #M_FLAG
    70                                        longa   on
    71                                        endm
    72                        
    73                        ; Resets the X bit making the index registers 16-bits wide
    74                        
    75                        long_i          macro
    76                                        rep     #X_FLAG
    77                                        longi   on
    78                                        endm
    79                        
    80                        ; Resets the M and X bits making the accumulator, memory accesses and index
    81                        ; registers 16-bits wide.
    82                                        
    83                        long_ai         macro
    84                                        rep     #M_FLAG|X_FLAG
    85                                        longa   on
    86                                        longi   on
    87                                        endm
    88                        
    89                        ; Sets the M bit making the accumulator and memory accesses 8-bits wide.
    90                        
    91                        short_a         macro
    92                                        sep     #M_FLAG
    93                                        longa   off
    94                                        endm
    95                        
    96                        ; Sets the X bit making the index registers 8-bits wide.
    97                        
    98                        short_i         macro
    99                                        sep     #X_FLAG
   100                                        longi   off
   101                                        endm
   102                                        
   103                        ; Sets the M & X bits making the accumulator, memory accesses and index
   104                        ; registers 8-bits wide.
   105                        
   106                        short_ai        macro
   107                                        sep     #M_FLAG|X_FLAG
   108                                        longa   off
   109                                        longi   off
   110                                        endm
    45                        
    46                        ;===============================================================================
    47                        ; Macros
    48                        ;-------------------------------------------------------------------------------
    49                        
    50                        ; The LINK macro deposits the link section of a word header automatically
    51                        ; linking the new word to the last.
    52                        
    53             00000000   WORDZ           set     0                       ; Word counter
    54             00000000   WORD0           equ     0                       ; Null address for first word
    55                        
    56                        LINK            macro   TYPE
    57                                        dw      WORD@<WORDZ>            ; Link
    58                                        db      TYPE                    ; Type
  Mon Apr 18 2016 15:06                                                                                                    Page 4


    59                        WORDZ           set     WORDZ+1
    60                        WORD@<WORDZ>:
    61                                        endm
    62                        
    63                        ; Deposits a word header containing the name which is linked back to the
    64                        ; previous word.
    65                        ;
    66                        ; The WDC assembler does not handle string parameters to macros very well,
    67                        ; stopping at the first comma or space in them, so some headers must be
    68                        ; manually constructed.
    69                        
    70             00000000   NORMAL          equ     $00
    71             00000080   IMMEDIATE       equ     $80
    72                        
    73                        HEADER          macro   LEN,NAME,TYPE
    74                                        LINK    TYPE
    75                                        db      LEN,NAME
    76                                        endm
    77                        
    78                        ; The CONTINUE macro is used at the end of a native word to invoke the next
    79                        ; word pointer.
    80                        
    81                        CONTINUE        macro
    82                                        tyx                             ; Copy IP to X
    83                                        iny
    84                                        iny
    85                                        jmp     (0,x)                   ; Then execute word
    86                                        endm
    87                        
    88                        TRAILER         macro
    89                        LAST_WORD       equ     WORD@<WORDZ>
    90                                        endm
    91                        
    92                        ;===============================================================================
    93                        ; Definitions
    94                        ;-------------------------------------------------------------------------------
    95                        
    96             00000014   USER_SIZE       equ     20
    97             00000080   DSTACK_SIZE     equ     128
    98             00000080   RSTACK_SIZE     equ     128
    99                        
   100             00000000   TO_IN_OFFSET    equ     0
   101             00000002   BASE_OFFSET     equ     2
   102             00000004   BLK_OFFSET      equ     4
   103             00000006   DP_OFFSET       equ     6
   104             00000008   LATEST_OFFSET   equ     8
   105             0000000A   SCR_OFFSET      equ     10
   106             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
   107             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
   108             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
   109             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
   110                        
   111             00000080   TIB_SIZE        equ     128
   112                        
   113                        ;===============================================================================
   114                        ; Data Areas
   115                        ;-------------------------------------------------------------------------------
   116                        
  Mon Apr 18 2016 15:06                                                                                                    Page 5


   117                                        page0
   118                                        org     $00
   119                        
   120 00:0000:              USER_AREA       ds      USER_SIZE               ; User Variables
   121                        
   122                        
   123             00000100   DSTACK_START    equ     $0100
   124             00000180   DSTACK_END      equ     DSTACK_START+DSTACK_SIZE
   125                        
   126             00000180   RSTACK_START    equ     $0180
   127             00000200   RSTACK_END      equ     RSTACK_START+RSTACK_SIZE
   128                        
   129                        
   130                                        data
   131                                        org     $0200
   132                        
   133 00:0200:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   134                        
   135                        ;===============================================================================
   136                        ; Forth Entry Point
   137                        ;-------------------------------------------------------------------------------
   138                        
   139                        FORTH           section OFFSET $0400
   140                        
   141                                        public  Start
   142                        Start:
   143 00:0400: 18 FB                        native                          ; Go to native mode
   144 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   145 00:0404: A9 FF 01                     lda     #RSTACK_END-1           ; Initialise return stack
   146 00:0407: 1B                           tcs
   147 00:0408: A9 7F 01                     lda     #DSTACK_END-1           ; .. and data stack
   148 00:040B: 5B                           tcd
   149                        
   150 00:040C: A0 15 04                     ldy     #COLD                   ; Then perform COLD start
   151 00:040F: BB C8 C8 7C                  CONTINUE
       00:0413: 00 00 
   152                        
   153                        COLD:
   154 00:0415: 20 05                        dw      DECIMAL
   155 00:0417: C9 04                        dw      ZERO
   156 00:0419: 70 04                        dw      BLK
   157 00:041B: 46 05                        dw      STORE
   158 00:041D: F3 04                        dw      FALSE
   159 00:041F: B3 04                        dw      STATE
   160 00:0421: 46 05                        dw      STORE
   161 00:0423: 67 13                        dw      DO_LITERAL
   162 00:0425: F0 19                        dw      NEXT_WORD
   163 00:0427: 80 04                        dw      DP
   164 00:0429: 46 05                        dw      STORE
   165 00:042B: 67 13                        dw      DO_LITERAL
   166 00:042D: E1 19                        dw      LAST_WORD
   167 00:042F: 8F 04                        dw      LATEST
   168 00:0431: 46 05                        dw      STORE
   169 00:0433: DB 14                        dw      CR
   170 00:0435: DB 14                        dw      CR
   171 00:0437: 59 16                        dw      DO_TITLE
   172 00:0439: 58 15                        dw      TYPE
   173 00:043B: DB 14                        dw      CR
  Mon Apr 18 2016 15:06                                                                                                    Page 6


   174 00:043D: DB 14                        dw      CR
   175 00:043F: 9F 0C                        dw      ABORT
   176                        
   177                        ;===============================================================================
   178                        ; System/User Variables
   179                        ;-------------------------------------------------------------------------------
   180                        
   181                        ; #TIB ( -- a-addr )
   182                        ;
   183                        ; a-addr is the address of a cell containing the number of characters in the
   184                        ; terminal input buffer.
   185                        
   186 00:0441: 00 00 00 04                  HEADER  4,"#TIB",NORMAL
       00:0445: 23 54 49 42 
   187 00:0449: 20 E4 12     HASH_TIB:       jsr     DO_CONSTANT
   188 00:044C: 4E 04                        dw      $+2
   189 00:044E: 7E 00                        dw      TIB_SIZE-2
   190                        
   191                        ; >IN ( -- a-addr )
   192                        ;
   193                        ; a-addr is the address of a cell containing the offset in characters from the
   194                        ; start of the input buffer to the start of the parse area.
   195                        
   196 00:0450: 44 04 00 03                  HEADER  3,">IN",NORMAL
       00:0454: 3E 49 4E 
   197 00:0457: 20 36 14     TO_IN:          jsr     DO_USER
   198 00:045A: 00 00                        dw      TO_IN_OFFSET
   199                        
   200                        ; BASE ( -- a-addr )
   201                        ;
   202                        ; a-addr is the address of a cell containing the current number-conversion
   203                        ; radix {{2...36}}.
   204                        
   205 00:045C: 53 04 00 04                  HEADER  4,"BASE",NORMAL
       00:0460: 42 41 53 45 
   206 00:0464: 20 36 14     BASE:           jsr     DO_USER
   207 00:0467: 02 00                        dw      BASE_OFFSET
   208                        
   209                        ; BLK ( -- a-addr )
   210                        ;
   211                        ; a-addr is the address of a cell containing zero or the number of the mass-
   212                        ; storage block being interpreted. If BLK contains zero, the input source is
   213                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   214                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   215                        
   216 00:0469: 5F 04 00 03                  HEADER  3,"BLK",NORMAL
       00:046D: 42 4C 4B 
   217 00:0470: 20 36 14     BLK:            jsr     DO_USER
   218 00:0473: 04 00                        dw      BLK_OFFSET
   219                        
   220                        ; (BUFFER)
   221                        
   222                        ;               HEADER  8,"(BUFFER)",NORMAL
   223 00:0475: 20 36 14     BUFFER:         jsr     DO_USER
   224 00:0478: 10 00                        dw      BUFFER_OFFSET
   225                        
   226                        ; DP ( -- a-addr )
   227                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 7


   228                        ; Dictionary Pointer
   229                        
   230 00:047A: 6C 04 00 02                  HEADER  2,"DP",NORMAL
       00:047E: 44 50 
   231 00:0480: 20 36 14     DP:             jsr     DO_USER
   232 00:0483: 06 00                        dw      DP_OFFSET
   233                        
   234                        ; LATEST ( -- a-addr )
   235                        
   236 00:0485: 7D 04 00 06                  HEADER  6,"LATEST",NORMAL
       00:0489: 4C 41 54 45 
       00:048D: 53 54 
   237 00:048F: 20 36 14     LATEST:         jsr     DO_USER
   238 00:0492: 08 00                        dw      LATEST_OFFSET
   239                        
   240                        ; (LENGTH)
   241                        
   242                        ;               HEADER  8,"(LENGTH)",NORMAL
   243 00:0494: 20 36 14     LENGTH:         jsr     DO_USER
   244 00:0497: 12 00                        dw      LENGTH_OFFSET
   245                        
   246                        ; SCR ( -- a-addr )
   247                        ;
   248                        ; a-addr is the address of a cell containing the block number of the block most
   249                        ; recently LISTed.
   250                        
   251 00:0499: 88 04 00 03                  HEADER  3,"SCR",NORMAL
       00:049D: 53 43 52 
   252 00:04A0: 20 36 14     SCR:            jsr     DO_USER
   253 00:04A3: 0A 00                        dw      SCR_OFFSET
   254                        
   255                        ; (SOURCE-ID)
   256                        
   257                        ;               HEADER  11,"(SOURCE-ID)",NORMAL
   258 00:04A5: 20 36 14     SOURCEID:       jsr     DO_USER
   259 00:04A8: 0C 00                        dw      SOURCEID_OFFSET
   260                        
   261                        ; STATE ( -- a-addr )
   262                        ;
   263                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   264                        ; is true when in compilation state, false otherwise. The true value in STATE
   265                        ; is non-zero, but is otherwise implementation-defined.
   266                        
   267 00:04AA: 9C 04 00 05                  HEADER  5,"STATE",NORMAL
       00:04AE: 53 54 41 54 
       00:04B2: 45 
   268 00:04B3: 20 36 14     STATE:          jsr     DO_USER
   269 00:04B6: 0E 00                        dw      STATE_OFFSET
   270                        
   271                        ; TIB ( -- c-addr )
   272                        ;
   273                        ; c-addr is the address of the terminal input buffer.
   274                        
   275 00:04B8: AD 04 00 03                  HEADER  3,"TIB",NORMAL
       00:04BC: 54 49 42 
   276 00:04BF: 20 E4 12     TIB:            jsr     DO_CONSTANT
   277 00:04C2: 00 02                        dw      TIB_AREA
   278                        
  Mon Apr 18 2016 15:06                                                                                                    Page 8


   279                        ;===============================================================================
   280                        ; Constants
   281                        ;-------------------------------------------------------------------------------
   282                        
   283                        ; 0 ( -- 0 )
   284                        ;
   285                        ; Push the constant value zero on the stack
   286                        
   287 00:04C4: BB 04 00 01                  HEADER  1,"0",NORMAL
       00:04C8: 30 
   288                        ZERO:
   289 00:04C9: 7B                           tdc
   290 00:04CA: 3A                           dec     a                       ; Make space on the stack
   291 00:04CB: 3A                           dec     a
   292 00:04CC: 5B                           tcd
   293 00:04CD: 64 01                        stz     <1                      ; And create a zero value
   294 00:04CF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04D3: 00 00 
   295                        
   296                        ; BL ( -- char )
   297                        ;
   298                        ; char is the character value for a space.
   299                        
   300 00:04D5: C7 04 00 02                  HEADER  2,"BL",NORMAL
       00:04D9: 42 4C 
   301                        BL:
   302 00:04DB: 7B                           tdc
   303 00:04DC: 3A                           dec     a                       ; Make space on the stack
   304 00:04DD: 3A                           dec     a
   305 00:04DE: 5B                           tcd
   306 00:04DF: A9 20 00                     lda     #' '                    ; And save a space value
   307 00:04E2: 85 01                        sta     <1
   308 00:04E4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04E8: 00 00 
   309                        
   310                        ; FALSE ( -- false )
   311                        ;
   312                        ; Return a false flag.
   313                        
   314 00:04EA: D8 04 00 05                  HEADER  5,"FALSE",NORMAL
       00:04EE: 46 41 4C 53 
       00:04F2: 45 
   315                        FALSE:
   316 00:04F3: 7B                           tdc
   317 00:04F4: 3A                           dec     a                       ; Make space on the stack
   318 00:04F5: 3A                           dec     a
   319 00:04F6: 5B                           tcd
   320 00:04F7: 64 01                        stz     <1                      ; And create a false value
   321 00:04F9: BB C8 C8 7C                  CONTINUE                        ; Done
       00:04FD: 00 00 
   322                        
   323                        ; TRUE ( -- true )
   324                        ;
   325                        ; Return a true flag, a single-cell value with all bits set.
   326                        
   327 00:04FF: ED 04 00 04                  HEADER  4,"TRUE",NORMAL
       00:0503: 54 52 55 45 
   328                        TRUE:
  Mon Apr 18 2016 15:06                                                                                                    Page 9


   329 00:0507: 7B                           tdc
   330 00:0508: 3A                           dec     a                       ; Make space on the stack
   331 00:0509: 3A                           dec     a
   332 00:050A: 5B                           tcd
   333 00:050B: 64 01                        stz     <1                      ; And create a true value
   334 00:050D: C6 01                        dec     <1
   335 00:050F: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0513: 00 00 
   336                        
   337                        ;===============================================================================
   338                        ; Radix
   339                        ;-------------------------------------------------------------------------------
   340                        
   341                        ; DECIMAL ( -- )
   342                        ;
   343                        ; Set the numeric conversion radix to ten (decimal).
   344                        
   345 00:0515: 02 05 00 07                  HEADER  7,"DECIMAL",NORMAL
       00:0519: 44 45 43 49 
       00:051D: 4D 41 4C 
   346 00:0520: 20 87 12     DECIMAL:        jsr     DO_COLON
   347 00:0523: 67 13 0A 00                  dw      DO_LITERAL,10
   348 00:0527: 64 04                        dw      BASE
   349 00:0529: 46 05                        dw      STORE
   350 00:052B: 02 0D                        dw      EXIT
   351                        
   352                        ; HEX ( -- )
   353                        ;
   354                        ; Set contents of BASE to sixteen.
   355                        
   356 00:052D: 18 05 00 03                  HEADER  3,"HEX",NORMAL
       00:0531: 48 45 58 
   357 00:0534: 20 87 12     HEX:            jsr     DO_COLON
   358 00:0537: 67 13 10 00                  dw      DO_LITERAL,16
   359 00:053B: 64 04                        dw      BASE
   360 00:053D: 46 05                        dw      STORE
   361 00:053F: 02 0D                        dw      EXIT
   362                        
   363                        ;===============================================================================
   364                        ; Memory Operations
   365                        ;-------------------------------------------------------------------------------
   366                        
   367                        ; ! ( x a-addr -- )
   368                        ;
   369                        ; Store x at a-addr.
   370                        
   371 00:0541: 30 05 00 01                  HEADER  1,"!",NORMAL
       00:0545: 21 
   372                        STORE:
   373 00:0546: A5 03                        lda     <3                      ; Fetch data value
   374 00:0548: 92 01                        sta     (1)                     ; .. and store
   375 00:054A: 7B                           tdc                             ; Clean up data stack
   376 00:054B: 1A                           inc     a
   377 00:054C: 1A                           inc     a
   378 00:054D: 1A                           inc     a
   379 00:054E: 1A                           inc     a
   380 00:054F: 5B                           tcd
   381 00:0550: BB C8 C8 7C                  CONTINUE                        ; Done
  Mon Apr 18 2016 15:06                                                                                                    Page 10


       00:0554: 00 00 
   382                        
   383                        ; +! ( n|u a-addr -- )
   384                        ;
   385                        ; Add n|u to the single-cell number at a-addr.
   386                        
   387 00:0556: 44 05 00 02                  HEADER  2,"+!",NORMAL
       00:055A: 2B 21 
   388                        PLUS_STORE:
   389 00:055C: 18                           clc
   390 00:055D: A5 03                        lda     <3                      ; Fetch data value
   391 00:055F: 72 01                        adc     (1)
   392 00:0561: 92 01                        sta     (1)
   393 00:0563: 7B                           tdc                             ; Clean up data stack
   394 00:0564: 1A                           inc     a
   395 00:0565: 1A                           inc     a
   396 00:0566: 1A                           inc     a
   397 00:0567: 1A                           inc     a
   398 00:0568: 5B                           tcd
   399 00:0569: BB C8 C8 7C                  CONTINUE                        ; Done
       00:056D: 00 00 
   400                        
   401                        ; , ( x -- )
   402                        ;
   403                        ; Reserve one cell of data space and store x in the cell. If the data-space
   404                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   405                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   406                        ; is not aligned prior to execution of ,.
   407                        ;
   408                        ;   HERE ! 1 CELLS ALLOT
   409                        
   410 00:056F: 59 05 00                     LINK    NORMAL
   411 00:0572: 01 2C                        db      1,","
   412 00:0574: 20 87 12     COMMA:          jsr     DO_COLON
   413 00:0577: 1F 06                        dw      HERE
   414 00:0579: 46 05                        dw      STORE
   415 00:057B: 67 13 01 00                  dw      DO_LITERAL,1
   416 00:057F: 64 06                        dw      CELLS
   417 00:0581: C7 05                        dw      ALLOT
   418 00:0583: 02 0D                        dw      EXIT
   419                        
   420                        ; 2! ( x1 x2 a-addr -- )
   421                        ;
   422                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   423                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   424                        
   425 00:0585: 72 05 00 02                  HEADER  2,"2!",NORMAL
       00:0589: 32 21 
   426 00:058B: 20 87 12     TWO_STORE:      jsr     DO_COLON
   427 00:058E: EE 07                        dw      SWAP
   428 00:0590: A3 07                        dw      OVER
   429 00:0592: 46 05                        dw      STORE
   430 00:0594: 51 06                        dw      CELL_PLUS
   431 00:0596: 46 05                        dw      STORE
   432 00:0598: 02 0D                        dw      EXIT
   433                        
   434                        ; 2@ ( a-addr -- x1 x2 )
   435                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 11


   436                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   437                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   438                        ; @.
   439                        
   440 00:059A: 88 05 00 02                  HEADER  2,"2@",NORMAL
       00:059E: 32 40 
   441 00:05A0: 20 87 12     TWO_FETCH:      jsr     DO_COLON
   442 00:05A3: 80 07                        dw      DUP
   443 00:05A5: 51 06                        dw      CELL_PLUS
   444 00:05A7: B4 05                        dw      FETCH
   445 00:05A9: EE 07                        dw      SWAP
   446 00:05AB: B4 05                        dw      FETCH
   447 00:05AD: 02 0D                        dw      EXIT
   448                        
   449                        ; @ ( a-addr -- x )
   450                        ;
   451                        ; x is the value stored at a-addr.
   452                        
   453 00:05AF: 9D 05 00 01                  HEADER  1,"@",NORMAL
       00:05B3: 40 
   454                        FETCH:
   455 00:05B4: B2 01                        lda     (1)                     ; Fetch from memory
   456 00:05B6: 85 01                        sta     <1                      ; .. and replace top value
   457 00:05B8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05BC: 00 00 
   458                        
   459                        ; ALLOT ( n -- )
   460                        ;
   461                        ; If n is greater than zero, reserve n address units of data space. If n is
   462                        ; less than zero, release |n| address units of data space. If n is zero, leave
   463                        ; the data-space pointer unchanged.
   464                        ;
   465                        ; In this implementation its is defined as:
   466                        ;
   467                        ;   DP +!
   468                        
   469 00:05BE: B2 05 00 05                  HEADER  5,"ALLOT",NORMAL
       00:05C2: 41 4C 4C 4F 
       00:05C6: 54 
   470 00:05C7: 20 87 12     ALLOT:          jsr     DO_COLON
   471 00:05CA: 80 04                        dw      DP
   472 00:05CC: 5C 05                        dw      PLUS_STORE
   473 00:05CE: 02 0D                        dw      EXIT
   474                        
   475                        ; C! ( char c-addr -- )
   476                        ;
   477                        ; Store char at c-addr. When character size is smaller than cell size, only the
   478                        ; number of low-order bits corresponding to character size are transferred.
   479                        
   480 00:05D0: C1 05 00 02                  HEADER  2,"C!",NORMAL
       00:05D4: 43 21 
   481                        C_STORE:
   482 00:05D6: A5 03                        lda     <3                      ; Fetch the data value
   483 00:05D8: E2 20                        short_a
   484 00:05DA: 92 01                        sta     (1)                     ; And store it
   485 00:05DC: C2 20                        long_a
   486 00:05DE: 7B                           tdc                             ; Clean up the stack
   487 00:05DF: 1A                           inc     a
  Mon Apr 18 2016 15:06                                                                                                    Page 12


   488 00:05E0: 1A                           inc     a
   489 00:05E1: 1A                           inc     a
   490 00:05E2: 1A                           inc     a
   491 00:05E3: 5B                           tcd
   492 00:05E4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:05E8: 00 00 
   493                        
   494                        ; C, ( char -- )
   495                        ;
   496                        ; Reserve space for one character in the data space and store char in the
   497                        ; space. If the data-space pointer is character aligned when C, begins
   498                        ; execution, it will remain character aligned when C, finishes execution.
   499                        ; An ambiguous condition exists if the data-space pointer is not character-
   500                        ; aligned prior to execution of C,
   501                        ;
   502                        ;   HERE C! 1 CHARS ALLOT
   503                        
   504 00:05EA: D3 05 00                     LINK    NORMAL
   505 00:05ED: 02 43 2C                     db      2,"C,"
   506 00:05F0: 20 87 12     C_COMMA:        jsr     DO_COLON
   507 00:05F3: 1F 06                        dw      HERE
   508 00:05F5: D6 05                        dw      C_STORE
   509 00:05F7: 67 13 01 00                  dw      DO_LITERAL,1
   510 00:05FB: 97 06                        dw      CHARS
   511 00:05FD: C7 05                        dw      ALLOT
   512 00:05FF: 02 0D                        dw      EXIT
   513                        
   514                        ; C@ ( c-addr -- char )
   515                        ;
   516                        ; Fetch the character stored at c-addr. When the cell size is greater than
   517                        ; character size, the unused high-order bits are all zeroes.
   518                        
   519 00:0601: ED 05 00 02                  HEADER  2,"C@",NORMAL
       00:0605: 43 40 
   520                        C_FETCH:
   521 00:0607: E2 20                        short_a
   522 00:0609: B2 01                        lda     (1)                     ; Fetch the data byte
   523 00:060B: 85 01                        sta     <1                      ; .. and replace stack value
   524 00:060D: 64 02                        stz     <2
   525 00:060F: C2 20                        long_a
   526 00:0611: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0615: 00 00 
   527                        
   528                        ; HERE ( -- addr )
   529                        ;
   530                        ; addr is the data-space pointer.
   531                        
   532 00:0617: 04 06 00 04                  HEADER  4,"HERE",NORMAL
       00:061B: 48 45 52 45 
   533 00:061F: 20 87 12     HERE:           jsr     DO_COLON
   534 00:0622: 80 04                        dw      DP
   535 00:0624: B4 05                        dw      FETCH
   536 00:0626: 02 0D                        dw      EXIT
   537                        
   538                        ;===============================================================================
   539                        ; Alignment
   540                        ;-------------------------------------------------------------------------------
   541                        
  Mon Apr 18 2016 15:06                                                                                                    Page 13


   542                        ; ALIGN ( -- )
   543                        ;
   544                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   545                        
   546 00:0628: 1A 06 00 05                  HEADER  5,"ALIGN",NORMAL
       00:062C: 41 4C 49 47 
       00:0630: 4E 
   547                        ALIGN:
   548 00:0631: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0635: 00 00 
   549                        
   550                        ; ALIGNED ( addr -- a-addr )
   551                        ;
   552                        ; a-addr is the first aligned address greater than or equal to addr.
   553                        
   554 00:0637: 2B 06 00 07                  HEADER  7,"ALIGNED",NORMAL
       00:063B: 41 4C 49 47 
       00:063F: 4E 45 44 
   555                        ALIGNED:
   556 00:0642: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0646: 00 00 
   557                        
   558                        ; CELL+ ( a-addr1 -- a-addr2 )
   559                        ;
   560                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   561                        
   562 00:0648: 3A 06 00 05                  HEADER  5,"CELL+",NORMAL
       00:064C: 43 45 4C 4C 
       00:0650: 2B 
   563                        CELL_PLUS:
   564 00:0651: E6 01                        inc     <1                      ; Bump the address by two
   565 00:0653: E6 01                        inc     <1
   566 00:0655: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0659: 00 00 
   567                        
   568                        ; CELLS ( n1 -- n2 )
   569                        ;
   570                        ; n2 is the size in address units of n1 cells.
   571                        
   572 00:065B: 4B 06 00 05                  HEADER  5,"CELLS",NORMAL
       00:065F: 43 45 4C 4C 
       00:0663: 53 
   573                        CELLS:
   574 00:0664: 06 01                        asl     <1                      ; Two bytes per cell
   575 00:0666: BB C8 C8 7C                  CONTINUE                        ; Done
       00:066A: 00 00 
   576                        
   577                        ; CHAR+ ( c-addr1 -- c-addr2 )
   578                        ;
   579                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   580                        
   581 00:066C: 5E 06 00 05                  HEADER  5,"CHAR+",NORMAL
       00:0670: 43 48 41 52 
       00:0674: 2B 
   582                        CHAR_PLUS:
   583 00:0675: E6 01                        inc     <1                      ; Bump the address by one
   584 00:0677: BB C8 C8 7C                  CONTINUE                        ; Done
       00:067B: 00 00 
  Mon Apr 18 2016 15:06                                                                                                    Page 14


   585                        
   586                        ; CHAR- ( c-addr1 -- c-addr2 )
   587                        ;
   588                        ; Subtract the size in address units of a character to c-addr1, giving c-addr2.
   589                        
   590 00:067D: 6F 06 00 05                  HEADER  5,"CHAR-",NORMAL
       00:0681: 43 48 41 52 
       00:0685: 2D 
   591                        CHAR_MINUS:
   592 00:0686: C6 01                        dec     <1
   593 00:0688: BB C8 C8 7C                  CONTINUE                        ; Done
       00:068C: 00 00 
   594                        
   595                        ; CHARS ( n1 -- n2 )
   596                        ;
   597                        ; n2 is the size in address units of n1 characters.
   598                        
   599 00:068E: 80 06 00 05                  HEADER  5,"CHARS",NORMAL
       00:0692: 43 48 41 52 
       00:0696: 53 
   600                        CHARS:
   601 00:0697: BB C8 C8 7C                  CONTINUE                        ; Done
       00:069B: 00 00 
   602                        
   603                        ;===============================================================================
   604                        ; Stack Operations
   605                        ;-------------------------------------------------------------------------------
   606                        
   607                        ; 2DROP ( x1 x2 -- )
   608                        ;
   609                        ; Drop cell pair x1 x2 from the stack.
   610                        
   611 00:069D: 91 06 00 05                  HEADER  5,"2DROP",NORMAL
       00:06A1: 32 44 52 4F 
       00:06A5: 50 
   612                        TWO_DROP:
   613 00:06A6: 7B                           tdc                             ; Removed two words from stack
   614 00:06A7: 1A                           inc     a
   615 00:06A8: 1A                           inc     a
   616 00:06A9: 1A                           inc     a
   617 00:06AA: 1A                           inc     a
   618 00:06AB: 5B                           tcd
   619 00:06AC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06B0: 00 00 
   620                        
   621                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   622                        ;
   623                        ; Duplicate cell pair x1 x2.
   624                        
   625 00:06B2: A0 06 00 04                  HEADER  4,"2DUP",NORMAL
       00:06B6: 32 44 55 50 
   626                        TWO_DUP:
   627 00:06BA: 7B                           tdc                             ; Make space for new value
   628 00:06BB: 3A                           dec     a
   629 00:06BC: 3A                           dec     a
   630 00:06BD: 3A                           dec     a
   631 00:06BE: 3A                           dec     a
   632 00:06BF: 5B                           tcd
  Mon Apr 18 2016 15:06                                                                                                    Page 15


   633 00:06C0: A5 05                        lda     <5                      ; Copy top two values
   634 00:06C2: 85 01                        sta     <1
   635 00:06C4: A5 07                        lda     <7
   636 00:06C6: 85 03                        sta     <3
   637 00:06C8: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06CC: 00 00 
   638                        
   639                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   640                        ;
   641                        ; Copy cell pair x1 x2 to the top of the stack.
   642                        
   643 00:06CE: B5 06 00 05                  HEADER  5,"2OVER",NORMAL
       00:06D2: 32 4F 56 45 
       00:06D6: 52 
   644                        TWO_OVER:
   645 00:06D7: 7B                           tdc                             ; Make space for new value
   646 00:06D8: 3A                           dec     a
   647 00:06D9: 3A                           dec     a
   648 00:06DA: 3A                           dec     a
   649 00:06DB: 3A                           dec     a
   650 00:06DC: 5B                           tcd
   651 00:06DD: A5 09                        lda     <9                      ; Ciopy top two values
   652 00:06DF: 85 01                        sta     <1
   653 00:06E1: A5 0B                        lda     <11
   654 00:06E3: 85 03                        sta     <3
   655 00:06E5: BB C8 C8 7C                  CONTINUE                        ; Done
       00:06E9: 00 00 
   656                        
   657                        ; 2ROT ( x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2 )
   658                        ;
   659                        ; Rotate the top three cell pairs on the stack bringing cell pair x1 x2 to
   660                        ; the top of the stack.
   661                        
   662 00:06EB: D1 06 00 04                  HEADER  4,"2ROT",NORMAL
       00:06EF: 32 52 4F 54 
   663 00:06F3: 20 87 12     TWO_ROT:        jsr     DO_COLON
   664 00:06F6: A5 0B                        lda     <11                     ; Save x1
   665 00:06F8: 48                           pha
   666 00:06F9: A5 09                        lda     <9                      ; Save x2
   667 00:06FB: 48                           pha
   668 00:06FC: A5 07                        lda     <7                      ; Move x3
   669 00:06FE: 85 0B                        sta     <11
   670 00:0700: A5 05                        lda     <5                      ; Move x4
   671 00:0702: 85 09                        sta     <9
   672 00:0704: A5 03                        lda     <3                      ; Move x5
   673 00:0706: 85 07                        sta     <7
   674 00:0708: A5 01                        lda     <1                      ; Move x6
   675 00:070A: 85 05                        sta     <5
   676 00:070C: 68                           pla                             ; Restore x2
   677 00:070D: 85 01                        sta     <1
   678 00:070F: 68                           pla                             ; Restore x1
   679 00:0710: 85 03                        sta     <3
   680 00:0712: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0716: 00 00 
   681                        
   682                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   683                        ;
   684                        ; Exchange the top two cell pairs.
  Mon Apr 18 2016 15:06                                                                                                    Page 16


   685                        
   686 00:0718: EE 06 00 05                  HEADER  5,"2SWAP",NORMAL
       00:071C: 32 53 57 41 
       00:0720: 50 
   687                        TWO_SWAP:
   688 00:0721: A5 03                        lda     <3                      ; Save x3
   689 00:0723: 48                           pha
   690 00:0724: A5 01                        lda     <1                      ; Save x4
   691 00:0726: 48                           pha
   692 00:0727: A5 07                        lda     <7                      ; Move x1
   693 00:0729: 85 03                        sta     <3
   694 00:072B: A5 05                        lda     <5                      ; Move x2
   695 00:072D: 85 01                        sta     <1
   696 00:072F: 68                           pla                             ; Move x4
   697 00:0730: 85 05                        sta     <5
   698 00:0732: 68                           pla                             ; Move x3
   699 00:0733: 85 07                        sta     <7
   700 00:0735: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0739: 00 00 
   701                        
   702                        ; ?DUP ( x -- 0 | x x )
   703                        ;
   704                        ; Duplicate x if it is non-zero.
   705                        
   706 00:073B: 1B 07 00 04                  HEADER  4,"?DUP",NORMAL
       00:073F: 3F 44 55 50 
   707                        QUERY_DUP:
   708 00:0743: A5 01                        lda     <1                      ; Fetch top value
   709 00:0745: D0 39                        bne     DUP                     ; Non-zero value?
   710 00:0747: BB C8 C8 7C                  CONTINUE                        ; Done
       00:074B: 00 00 
   711                        
   712                        ; DEPTH ( -- n )
   713                        
   714 00:074D: 3E 07 00 05  		HEADER	5,"DEPTH",NORMAL
       00:0751: 44 45 50 54 
       00:0755: 48 
   715 00:0756: 20 87 12     DEPTH:		jsr	DO_COLON
   716 00:0759: 37 16        		dw	AT_DP
   717 00:075B: 67 13 80 01  		dw	DO_LITERAL,DSTACK_END
   718 00:075F: EE 07        		dw	SWAP
   719 00:0761: FB 08        		dw	MINUS
   720 00:0763: 58 09        		dw	TWO_SLASH
   721 00:0765: 02 0D        		dw	EXIT
   722                        
   723                        ; DROP ( x -- )
   724                        ;
   725                        ; Remove x from the stack.
   726                        
   727 00:0767: 50 07 00 04                  HEADER  4,"DROP",NORMAL
       00:076B: 44 52 4F 50 
   728                        DROP:
   729 00:076F: 7B                           tdc                             ; Drop the top value
   730 00:0770: 1A                           inc     a
   731 00:0771: 1A                           inc     a
   732 00:0772: 5B                           tcd
   733 00:0773: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0777: 00 00 
  Mon Apr 18 2016 15:06                                                                                                    Page 17


   734                        
   735                        ; DUP ( x -- x x )
   736                        ;
   737                        ; Duplicate x.
   738                        
   739 00:0779: 6A 07 00 03                  HEADER  3,"DUP",NORMAL
       00:077D: 44 55 50 
   740                        DUP:
   741 00:0780: 7B                           tdc
   742 00:0781: 3A                           dec     a
   743 00:0782: 3A                           dec     a
   744 00:0783: 5B                           tcd
   745 00:0784: A5 03                        lda     <3                      ; Fetch top value
   746 00:0786: 85 01                        sta     <1                      ; And make a copy
   747 00:0788: BB C8 C8 7C                  CONTINUE                        ; Done
       00:078C: 00 00 
   748                        
   749                        ; NIP ( x1 x2 -- x2 )
   750                        ;
   751                        ; Drop the first item below the top of stack.
   752                        
   753 00:078E: 7C 07 00 03                  HEADER  3,"NIP",NORMAL
       00:0792: 4E 49 50 
   754                        NIP:
   755 00:0795: A5 01                        lda     <1                      ; Copy x2 over x1
   756 00:0797: 85 03                        sta     <3
   757 00:0799: 80 D4                        bra     DROP
   758                        
   759                        ; OVER ( x1 x2 -- x1 x2 x1 )
   760                        ;
   761                        ; Place a copy of x1 on top of the stack.
   762                        
   763 00:079B: 91 07 00 04                  HEADER  4,"OVER",NORMAL
       00:079F: 4F 56 45 52 
   764                        OVER:
   765 00:07A3: 7B                           tdc
   766 00:07A4: 3A                           dec     a
   767 00:07A5: 3A                           dec     a
   768 00:07A6: 5B                           tcd
   769 00:07A7: A5 05                        lda     <5                      ; Fetch second value
   770 00:07A9: 85 01                        sta     <1                      ; And make a copy
   771 00:07AB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07AF: 00 00 
   772                        
   773                        ; PICK ( xu ... x1 x0 u -- xu ... x1 x0 xu )
   774                        ;
   775                        ; Remove u. Copy the xu to the top of the stack. An ambiguous condition exists
   776                        ; if there are less than u+2 items on the stack before PICK is executed.
   777                        
   778                        ; TODO
   779 00:07B1: 9E 07 00 04                  HEADER  4,"PICK",NORMAL
       00:07B5: 50 49 43 4B 
   780                        PICK:
   781 00:07B9: BB C8 C8 7C                  CONTINUE
       00:07BD: 00 00 
   782                        
   783                        ; ROLL ( xu xu-1 ... x0 u -- xu-1 ... x0 xu )
   784                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 18


   785                        ; Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition
   786                        ; exists if there are less than u+2 items on the stack before ROLL is executed.
   787                        
   788                        ; TODO
   789                        
   790 00:07BF: B4 07 00 04                  HEADER  4,"ROLL",NORMAL
       00:07C3: 52 4F 4C 4C 
   791                        ROLL:
   792 00:07C7: BB C8 C8 7C                  CONTINUE
       00:07CB: 00 00 
   793                        
   794                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   795                        ;
   796                        ; Rotate the top three stack entries.
   797                        
   798 00:07CD: C2 07 00 03                  HEADER  3,"ROT",NORMAL
       00:07D1: 52 4F 54 
   799                        ROT:
   800 00:07D4: A6 05                        ldx     <5                      ; Save x1
   801 00:07D6: A5 03                        lda     <3                      ; Move x2
   802 00:07D8: 85 05                        sta     <5
   803 00:07DA: A5 01                        lda     <1                      ; Move x3
   804 00:07DC: 85 03                        sta     <3
   805 00:07DE: 86 01                        stx     <1                      ; Restore x1
   806 00:07E0: BB C8 C8 7C                  CONTINUE
       00:07E4: 00 00 
   807                        
   808                        ; SWAP ( x1 x2 -- x2 x1 )
   809                        ;
   810                        ; Exchange the top two stack items.
   811                        
   812 00:07E6: D0 07 00 04                  HEADER  4,"SWAP",NORMAL
       00:07EA: 53 57 41 50 
   813                        SWAP:
   814 00:07EE: A5 01                        lda     <1                      ; Switch top two words
   815 00:07F0: A6 03                        ldx     <3
   816 00:07F2: 85 03                        sta     <3
   817 00:07F4: 86 01                        stx     <1
   818 00:07F6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:07FA: 00 00 
   819                        
   820                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   821                        ;
   822                        ; Copy the first (top) stack item below the second stack item.
   823                        
   824 00:07FC: E9 07 00 04                  HEADER  4,"TUCK",NORMAL
       00:0800: 54 55 43 4B 
   825 00:0804: 20 87 12     TUCK:           jsr     DO_COLON
   826 00:0807: EE 07                        dw      SWAP
   827 00:0809: A3 07                        dw      OVER
   828 00:080B: 02 0D                        dw      EXIT
   829                        
   830                        ;===============================================================================
   831                        ; Return Stack Operations
   832                        ;-------------------------------------------------------------------------------
   833                        
   834                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   835                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 19


   836                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   837                        ; SWAP >R >R.
   838                        
   839 00:080D: FF 07 00 03                  HEADER  3,"2>R",NORMAL
       00:0811: 32 3E 52 
   840                        TWO_TO_R:
   841 00:0814: A5 03                        lda     <3                      ; Transfer x1
   842 00:0816: 48                           pha
   843 00:0817: A5 01                        lda     <1                      ; Transfer x2
   844 00:0819: 48                           pha
   845 00:081A: 7B                           tdc
   846 00:081B: 1A                           inc     a                       ; Clean up data stack
   847 00:081C: 1A                           inc     a
   848 00:081D: 1A                           inc     a
   849 00:081E: 1A                           inc     a
   850 00:081F: 5B                           tcd
   851 00:0820: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0824: 00 00 
   852                        
   853                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   854                        ;
   855                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   856                        ; R> SWAP.
   857                        
   858 00:0826: 10 08 00 03                  HEADER  3,"2R>",NORMAL
       00:082A: 32 52 3E 
   859                        TWO_R_FROM:
   860 00:082D: 7B                           tdc
   861 00:082E: 3A                           dec     a                       ; Make space for values
   862 00:082F: 3A                           dec     a
   863 00:0830: 3A                           dec     a
   864 00:0831: 3A                           dec     a
   865 00:0832: 5B                           tcd
   866 00:0833: 68                           pla                             ; Transfer x2
   867 00:0834: 85 01                        sta     <1
   868 00:0836: 68                           pla                             ; Transfer x1
   869 00:0837: 85 03                        sta     <3
   870 00:0839: BB C8 C8 7C                  CONTINUE                        ; Done
       00:083D: 00 00 
   871                        
   872                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
   873                        ;
   874                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   875                        ; 2DUP >R >R SWAP.
   876                        
   877 00:083F: 29 08 00 03                  HEADER  3,"2R@",NORMAL
       00:0843: 32 52 40 
   878                        TWO_R_FETCH:
   879 00:0846: 7B                           tdc
   880 00:0847: 3A                           dec     a                       ; Make space for values
   881 00:0848: 3A                           dec     a
   882 00:0849: 3A                           dec     a
   883 00:084A: 3A                           dec     a
   884 00:084B: 5B                           tcd
   885 00:084C: A3 01                        lda     1,s                     ; Transfer x2
   886 00:084E: 85 01                        sta     <1
   887 00:0850: A3 03                        lda     3,s                     ; Transfer x1
   888 00:0852: 85 03                        sta     <3
  Mon Apr 18 2016 15:06                                                                                                    Page 20


   889 00:0854: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0858: 00 00 
   890                        
   891                        ; >R ( x -- ) ( R: -- x )
   892                        ;
   893                        ; Move x to the return stack.
   894                        
   895 00:085A: 42 08 00 02                  HEADER  2,">R",NORMAL
       00:085E: 3E 52 
   896                        TO_R:
   897 00:0860: A5 01                        lda     <1                      ; Transfer top value
   898 00:0862: 48                           pha                             ; .. to return stack
   899 00:0863: 7B                           tdc
   900 00:0864: 1A                           inc     a
   901 00:0865: 1A                           inc     a
   902 00:0866: 5B                           tcd
   903 00:0867: BB C8 C8 7C                  CONTINUE                        ; Done
       00:086B: 00 00 
   904                        
   905                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   906                        ;
   907                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   908                        ; exists if the loop control parameters are unavailable.
   909                        
   910 00:086D: 5D 08 00 01                  HEADER  1,"I",NORMAL
       00:0871: 49 
   911                        I:
   912 00:0872: 7B                           tdc
   913 00:0873: 3A                           dec     a
   914 00:0874: 3A                           dec     a
   915 00:0875: 5B                           tcd
   916 00:0876: A3 01                        lda     1,s
   917 00:0878: 85 01                        sta     <1
   918 00:087A: BB C8 C8 7C                  CONTINUE
       00:087E: 00 00 
   919                        
   920                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   921                        ;
   922                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   923                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   924                        ; unavailable.
   925                        
   926 00:0880: 70 08 00 01                  HEADER  1,"J",NORMAL
       00:0884: 4A 
   927                        J:
   928 00:0885: 7B                           tdc
   929 00:0886: 3A                           dec     a
   930 00:0887: 3A                           dec     a
   931 00:0888: 5B                           tcd
   932 00:0889: A3 05                        lda     5,s
   933 00:088B: 85 01                        sta     <1
   934 00:088D: BB C8 C8 7C                  CONTINUE
       00:0891: 00 00 
   935                        
   936                        ; R> ( -- x ) ( R: x -- )
   937                        ;
   938                        ; Move x from the return stack to the data stack.
   939                        
  Mon Apr 18 2016 15:06                                                                                                    Page 21


   940 00:0893: 83 08 00 02                  HEADER  2,"R>",NORMAL
       00:0897: 52 3E 
   941                        R_FROM:
   942 00:0899: 7B                           tdc
   943 00:089A: 3A                           dec     a
   944 00:089B: 3A                           dec     a
   945 00:089C: 5B                           tcd
   946 00:089D: 68                           pla                             ; Fetch return stack value
   947 00:089E: 85 01                        sta     <1
   948 00:08A0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08A4: 00 00 
   949                        
   950                        ; R@ ( -- x ) ( R: x -- x )
   951                        ;
   952                        ; Copy x from the return stack to the data stack.
   953                        
   954 00:08A6: 96 08 00 02                  HEADER  2,"R@",NORMAL
       00:08AA: 52 40 
   955                        R_FETCH:
   956 00:08AC: 7B                           tdc
   957 00:08AD: 3A                           dec     a
   958 00:08AE: 3A                           dec     a
   959 00:08AF: 5B                           tcd
   960 00:08B0: A3 01                        lda     1,s
   961 00:08B2: 85 01                        sta     <1
   962 00:08B4: BB C8 C8 7C                  CONTINUE
       00:08B8: 00 00 
   963                        
   964                        ;===============================================================================
   965                        ; Single Precision Arithmetic
   966                        ;-------------------------------------------------------------------------------
   967                        
   968                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   969                        ;
   970                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   971                        
   972 00:08BA: A9 08 00 01                  HEADER  1,"*",NORMAL
       00:08BE: 2A 
   973                        STAR:
   974 00:08BF: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08C3: 00 00 
   975                        
   976                        ; */
   977                        
   978 00:08C5: BD 08 00 02                  HEADER  2,"*/",NORMAL
       00:08C9: 2A 2F 
   979                        STAR_SLASH:
   980 00:08CB: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08CF: 00 00 
   981                        
   982                        ; */MOD
   983                        
   984 00:08D1: C8 08 00 05                  HEADER  5,"*/MOD",NORMAL
       00:08D5: 2A 2F 4D 4F 
       00:08D9: 44 
   985                        STAR_SLASH_MOD:
   986 00:08DA: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08DE: 00 00 
  Mon Apr 18 2016 15:06                                                                                                    Page 22


   987                        
   988                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   989                        ;
   990                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   991                        
   992 00:08E0: D4 08 00 01                  HEADER  1,"+",NORMAL
       00:08E4: 2B 
   993                        PLUS:
   994 00:08E5: 18                           clc                             ; Add top two values
   995 00:08E6: A5 03                        lda     <3
   996 00:08E8: 65 01                        adc     <1
   997 00:08EA: 85 03                        sta     <3                      ; Save result
   998 00:08EC: 7B                           tdc
   999 00:08ED: 1A                           inc     a                       ; Clean up data stack
  1000 00:08EE: 1A                           inc     a
  1001 00:08EF: 5B                           tcd
  1002 00:08F0: BB C8 C8 7C                  CONTINUE                        ; Done
       00:08F4: 00 00 
  1003                        
  1004                        ; - ( n1|u1 n2|u2 -- n3|u3 )
  1005                        ;
  1006                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
  1007                        
  1008 00:08F6: E3 08 00 01                  HEADER  1,"-",NORMAL
       00:08FA: 2D 
  1009                        MINUS:
  1010 00:08FB: 38                           sec                             ; Subtract top two values
  1011 00:08FC: A5 03                        lda     <3
  1012 00:08FE: E5 01                        sbc     <1
  1013 00:0900: 85 03                        sta     <3                      ; Save result
  1014 00:0902: 7B                           tdc
  1015 00:0903: 1A                           inc     a                       ; Clean up data stack
  1016 00:0904: 1A                           inc     a
  1017 00:0905: 5B                           tcd
  1018 00:0906: BB C8 C8 7C                  CONTINUE                        ; Done
       00:090A: 00 00 
  1019                        
  1020                        ; /
  1021                        
  1022 00:090C: F9 08 00 01                  HEADER  1,"/",NORMAL
       00:0910: 2F 
  1023 00:0911: 20 87 12     SLASH:          jsr     DO_COLON
  1024 00:0914: 22 09                        dw      SLASH_MOD
  1025 00:0916: 95 07                        dw      NIP
  1026 00:0918: 02 0D                        dw      EXIT
  1027                        
  1028                        ; /MOD
  1029                        
  1030 00:091A: 0F 09 00 04                  HEADER  4,"/MOD",NORMAL
       00:091E: 2F 4D 4F 44 
  1031                        SLASH_MOD:
  1032 00:0922: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0926: 00 00 
  1033                        
  1034                        ; 1+ ( n1|u1 -- n2|u2 )
  1035                        ;
  1036                        ; Add one (1) to n1|u1 giving the sum n2|u2.
  1037                        
  Mon Apr 18 2016 15:06                                                                                                    Page 23


  1038 00:0928: 1D 09 00 02                  HEADER  2,"1+",NORMAL
       00:092C: 31 2B 
  1039                        ONE_PLUS:
  1040 00:092E: E6 01                        inc     <1                      ; Increment top of stack
  1041 00:0930: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0934: 00 00 
  1042                        
  1043                        ; 1- ( n1|u1 -- n2|u2 )
  1044                        ;
  1045                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
  1046                        
  1047 00:0936: 2B 09 00 02                  HEADER  2,"1-",NORMAL
       00:093A: 31 2D 
  1048                        ONE_MINUS:
  1049 00:093C: C6 01                        dec     <1                      ; Decrement top of stack
  1050 00:093E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0942: 00 00 
  1051                        
  1052                        ; 2* ( x1 -- x2 )
  1053                        ;
  1054                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  1055                        ; filling the vacated least-significant bit with zero.
  1056                        
  1057 00:0944: 39 09 00 02                  HEADER  2,"2*",NORMAL
       00:0948: 32 2A 
  1058                        TWO_STAR:
  1059 00:094A: 06 01                        asl     <1                      ; Multiply top value by two
  1060 00:094C: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0950: 00 00 
  1061                        
  1062                        ; 2/ ( x1 -- x2 )
  1063                        ;
  1064                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
  1065                        ; leaving the most-significant bit unchanged.
  1066                        
  1067 00:0952: 47 09 00 02                  HEADER  2,"2/",NORMAL
       00:0956: 32 2F 
  1068                        TWO_SLASH:
  1069 00:0958: A5 01                        lda     <1                      ; Load the top value
  1070 00:095A: 2A                           rol     a                       ; Extract the top bit
  1071 00:095B: 66 01                        ror     <1                      ; And shift back into value
  1072 00:095D: BB C8 C8 7C                  CONTINUE
       00:0961: 00 00 
  1073                        
  1074                        ; ABS ( n -- u )
  1075                        ;
  1076                        ; u is the absolute value of n.
  1077                        
  1078 00:0963: 55 09 00 03                  HEADER  3,"ABS",NORMAL
       00:0967: 41 42 53 
  1079                        ABS:
  1080 00:096A: A5 01                        lda     <1
  1081 00:096C: 30 50                        bmi     NEGATE
  1082 00:096E: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0972: 00 00 
  1083                        
  1084                        ; MAX
  1085                        
  Mon Apr 18 2016 15:06                                                                                                    Page 24


  1086 00:0974: 66 09 00 03                  HEADER  3,"MAX",NORMAL
       00:0978: 4D 41 58 
  1087 00:097B: 20 87 12     MAX:            jsr     DO_COLON
  1088 00:097E: BA 06                        dw      TWO_DUP
  1089 00:0980: 5B 0B                        dw      LESS
  1090 00:0982: 30 12 88 09                  dw      QUERY_BRANCH,MAX_1
  1091 00:0986: EE 07                        dw      SWAP
  1092 00:0988: 6F 07        MAX_1:          dw      DROP
  1093 00:098A: 02 0D                        dw      EXIT
  1094                        
  1095                        ; MIN
  1096                        
  1097 00:098C: 77 09 00 03                  HEADER  3,"MIN",NORMAL
       00:0990: 4D 49 4E 
  1098 00:0993: 20 87 12     MIN:            jsr     DO_COLON
  1099 00:0996: BA 06                        dw      TWO_DUP
  1100 00:0998: AF 0B                        dw      GREATER
  1101 00:099A: 30 12 A0 09                  dw      QUERY_BRANCH,MIN_1
  1102 00:099E: EE 07                        dw      SWAP
  1103 00:09A0: 6F 07        MIN_1:          dw      DROP
  1104 00:09A2: 02 0D                        dw      EXIT
  1105                        
  1106                        ; MOD
  1107                        
  1108 00:09A4: 8F 09 00 03                  HEADER  3,"MOD",NORMAL
       00:09A8: 4D 4F 44 
  1109 00:09AB: 20 87 12     MOD:            jsr     DO_COLON
  1110 00:09AE: 22 09                        dw      SLASH_MOD
  1111 00:09B0: 6F 07                        dw      DROP
  1112 00:09B2: 02 0D                        dw      EXIT
  1113                        
  1114                        ; NEGATE ( n1 -- n2 )
  1115                        ;
  1116                        ; Negate n1, giving its arithmetic inverse n2.
  1117                        
  1118 00:09B4: A7 09 00 06                  HEADER  6,"NEGATE",NORMAL
       00:09B8: 4E 45 47 41 
       00:09BC: 54 45 
  1119                        NEGATE:
  1120 00:09BE: 38                           sec                             ; Negate the top of stack
  1121 00:09BF: A9 00 00                     lda     #0
  1122 00:09C2: E5 01                        sbc     <1
  1123 00:09C4: 85 01                        sta     <1
  1124 00:09C6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:09CA: 00 00 
  1125                        
  1126                        ; UMAX ( x1 x2 -- x1|x2 )
  1127                        
  1128 00:09CC: B7 09 00 04                  HEADER  4,"UMAX",NORMAL
       00:09D0: 55 4D 41 58 
  1129                        UMAX:
  1130 00:09D4: A5 01                        lda     <1                      ; Compare the top values
  1131 00:09D6: C5 03                        cmp     <3
  1132 00:09D8: B0 03                        bcs     UMAX_EXIT               ; Is x2 biggest?
  1133 00:09DA: 4C 6F 07                     jmp     DROP                    ; No, x1 is
  1134 00:09DD: 4C 95 07     UMAX_EXIT:      jmp     NIP
  1135                        
  1136                        ; UMIN ( x1 x2 -- x1|x2 )
  Mon Apr 18 2016 15:06                                                                                                    Page 25


  1137                        
  1138 00:09E0: CF 09 00 04                  HEADER  4,"UMIN",NORMAL
       00:09E4: 55 4D 49 4E 
  1139                        UMIN:
  1140 00:09E8: A5 01                        lda     <1                      ; Compare the top values
  1141 00:09EA: C5 03                        cmp     <3
  1142 00:09EC: 90 03                        bcc     UMIN_EXIT               ; Is x2 smallest?
  1143 00:09EE: 4C 6F 07                     jmp     DROP                    ; No, x1 is
  1144 00:09F1: 4C 95 07     UMIN_EXIT:      jmp     NIP
  1145                        
  1146                        ;===============================================================================
  1147                        ; Double Precision Arithmetic
  1148                        ;-------------------------------------------------------------------------------
  1149                        
  1150                        ; D+ ( d1|ud1 d2|ud2 -- d3|ud3 )
  1151                        ;
  1152                        ; Add d2|ud2 to d1|ud1, giving the sum d3|ud3.
  1153                        
  1154 00:09F4: E3 09 00 02                  HEADER  2,"D+",NORMAL
       00:09F8: 44 2B 
  1155                        D_PLUS:
  1156 00:09FA: 18                           clc
  1157 00:09FB: A5 07                        lda     <7                      ; Add low words
  1158 00:09FD: 65 03                        adc     <3
  1159 00:09FF: 85 07                        sta     <7
  1160 00:0A01: A5 05                        lda     <5                      ; Then the high words
  1161 00:0A03: 65 01                        adc     <1
  1162 00:0A05: 85 05                        sta     <5
  1163 00:0A07: 7B                           tdc                             ; Drop top double
  1164 00:0A08: 1A                           inc     a
  1165 00:0A09: 1A                           inc     a
  1166 00:0A0A: 1A                           inc     a
  1167 00:0A0B: 1A                           inc     a
  1168 00:0A0C: 5B                           tcd
  1169 00:0A0D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A11: 00 00 
  1170                        
  1171                        ; D- ( d1|ud1 d2|ud2 -- d3|ud3 )
  1172                        ;
  1173                        ; Subtract d2|ud2 from d1|ud1, giving the difference d3|ud3.
  1174                        
  1175 00:0A13: F7 09 00 02                  HEADER  2,"D-",NORMAL
       00:0A17: 44 2D 
  1176                        D_MINUS:
  1177 00:0A19: 38                           sec
  1178 00:0A1A: A5 07                        lda     <7                      ; Subtract low words
  1179 00:0A1C: E5 03                        sbc     <3
  1180 00:0A1E: 85 07                        sta     <7
  1181 00:0A20: A5 05                        lda     <5                      ; Then the high words
  1182 00:0A22: E5 01                        sbc     <1
  1183 00:0A24: 85 05                        sta     <5
  1184 00:0A26: 7B                           tdc                             ; Drop top double
  1185 00:0A27: 1A                           inc     a
  1186 00:0A28: 1A                           inc     a
  1187 00:0A29: 1A                           inc     a
  1188 00:0A2A: 1A                           inc     a
  1189 00:0A2B: 5B                           tcd
  1190 00:0A2C: BB C8 C8 7C                  CONTINUE                        ; Done
  Mon Apr 18 2016 15:06                                                                                                    Page 26


       00:0A30: 00 00 
  1191                        
  1192                        ; D2* ( xd1 -- xd2 )
  1193                        ;
  1194                        ; xd2 is the result of shifting xd1 one bit toward the most-significant bit,
  1195                        ; filling the vacated least-significant bit with zero.
  1196                        
  1197 00:0A32: 16 0A 00 03                  HEADER  3,"D2*",NORMAL
       00:0A36: 44 32 2A 
  1198                        D_TWO_STAR:
  1199 00:0A39: 06 03                        asl     <3
  1200 00:0A3B: 26 01                        rol     <1
  1201 00:0A3D: BB C8 C8 7C                  CONTINUE
       00:0A41: 00 00 
  1202                        
  1203                        ; D2/ ( xd1 -- xd2 )
  1204                        ;
  1205                        ; xd2 is the result of shifting xd1 one bit toward the least-significant bit,
  1206                        ; leaving the most-significant bit unchanged.
  1207                        
  1208 00:0A43: 35 0A 00 03                  HEADER  3,"D2/",NORMAL
       00:0A47: 44 32 2F 
  1209                        D_TWO_SLASH:
  1210 00:0A4A: A5 01                        lda     <1
  1211 00:0A4C: 2A                           rol     a
  1212 00:0A4D: 66 01                        ror     <1
  1213 00:0A4F: 66 03                        ror     <3
  1214 00:0A51: BB C8 C8 7C                  CONTINUE
       00:0A55: 00 00 
  1215                        
  1216                        ; DABS
  1217                        ; DMAX
  1218                        ; DMIN
  1219                        
  1220                        ; DNEGATE ( d1 -- d2 )
  1221                        ;
  1222                        ; d2 is the negation of d1.
  1223                        
  1224 00:0A57: 46 0A 00 07                  HEADER  7,"DNEGATE",NORMAL
       00:0A5B: 44 4E 45 47 
       00:0A5F: 41 54 45 
  1225                        DNEGATE:
  1226 00:0A62: 38                           sec
  1227 00:0A63: A9 00 00                     lda     #0                      ; Subtract low word from zero
  1228 00:0A66: E5 03                        sbc     <3
  1229 00:0A68: 85 03                        sta     <3
  1230 00:0A6A: A9 00 00                     lda     #0                      ; Then the high word
  1231 00:0A6D: E5 01                        sbc     <1
  1232 00:0A6F: 85 01                        sta     <1
  1233 00:0A71: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0A75: 00 00 
  1234                        
  1235                        ; UD* ( ud1 d2 -- ud3)
  1236                        ;
  1237                        ; 32*16->32 multiply
  1238                        ;
  1239                        ;   DUP >R UM* DROP  SWAP R> UM* ROT + ;
  1240                        
  Mon Apr 18 2016 15:06                                                                                                    Page 27


  1241 00:0A77: 5A 0A 00 03                  HEADER  3,"UD*",NORMAL
       00:0A7B: 55 44 2A 
  1242 00:0A7E: 20 87 12     UD_STAR:        jsr     DO_COLON
  1243 00:0A81: 80 07                        dw      DUP
  1244 00:0A83: 60 08                        dw      TO_R
  1245 00:0A85: E1 0A                        dw      UM_STAR
  1246 00:0A87: 6F 07                        dw      DROP
  1247 00:0A89: EE 07                        dw      SWAP
  1248 00:0A8B: 99 08                        dw      R_FROM
  1249 00:0A8D: E1 0A                        dw      UM_STAR
  1250 00:0A8F: D4 07                        dw      ROT
  1251 00:0A91: E5 08                        dw      PLUS
  1252 00:0A93: 02 0D                        dw      EXIT
  1253                        
  1254                        ;===============================================================================
  1255                        ; Mixed Arithmetic
  1256                        ;-------------------------------------------------------------------------------
  1257                        
  1258                        
  1259                        ; D>S ( d -- n )
  1260                        ;
  1261                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1262                        ; range of a signed single-cell number.
  1263                        
  1264 00:0A95: 7A 0A 00 03                  HEADER  3,"D>S",NORMAL
       00:0A99: 44 3E 53 
  1265                        D_TO_S:
  1266 00:0A9C: 7B                           tdc
  1267 00:0A9D: 1A                           inc     a                       ; Drop the high word
  1268 00:0A9E: 1A                           inc     a
  1269 00:0A9F: 5B                           tcd
  1270 00:0AA0: BB C8 C8 7C                  CONTINUE
       00:0AA4: 00 00 
  1271                        
  1272                        ; M*/
  1273                        
  1274                        ; M+ ( d1|ud1 n -- d2|ud2 )
  1275                        ;
  1276                        ; Add n to d1|ud1, giving the sum d2|ud2.
  1277                        
  1278 00:0AA6: 98 0A 00 02                  HEADER  2,"M+",NORMAL
       00:0AAA: 4D 2B 
  1279                        M_PLUS:
  1280 00:0AAC: 18                           clc
  1281 00:0AAD: A5 01                        lda     <1
  1282 00:0AAF: 65 05                        adc     <5
  1283 00:0AB1: 85 05                        sta     <5
  1284 00:0AB3: 90 02                        bcc     $+4
  1285 00:0AB5: E6 03                        inc     <3
  1286 00:0AB7: 7B                           tdc
  1287 00:0AB8: 1A                           inc     a
  1288 00:0AB9: 1A                           inc     a
  1289 00:0ABA: 5B                           tcd
  1290 00:0ABB: BB C8 C8 7C                  CONTINUE
       00:0ABF: 00 00 
  1291                        
  1292                        ; S>D ( n -- d )
  1293                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 28


  1294                        ; Convert the number n to the double-cell number d with the same numerical
  1295                        ; value.
  1296                        
  1297 00:0AC1: A9 0A 00 03                  HEADER  3,"S>D",NORMAL
       00:0AC5: 53 3E 44 
  1298                        S_TO_D:
  1299 00:0AC8: 7B                           tdc
  1300 00:0AC9: 3A                           dec     a                       ; Assume n is positive
  1301 00:0ACA: 3A                           dec     a
  1302 00:0ACB: 5B                           tcd
  1303 00:0ACC: 64 01                        stz     <1                      ; .. push a zero value
  1304 00:0ACE: A5 03                        lda     <3                      ; Test the number
  1305 00:0AD0: 10 02                        bpl     S_TO_D_1
  1306 00:0AD2: C6 01                        dec     <1                      ; Make top -1 if negative
  1307 00:0AD4: BB C8 C8 7C  S_TO_D_1        CONTINUE                        ; Done
       00:0AD8: 00 00 
  1308                        
  1309                        ; UM* ( n1 n2 -- d )
  1310                        
  1311 00:0ADA: C4 0A 00 03                  HEADER  3,"UM*",NORMAL
       00:0ADE: 55 4D 2A 
  1312                        UM_STAR:
  1313 00:0AE1: A5 01                        lda     <1                      ; Fetch multiplier
  1314 00:0AE3: 48                           pha
  1315 00:0AE4: 64 01                        stz     <1                      ; Clear the result
  1316 00:0AE6: A2 10 00                     ldx     #16
  1317 00:0AE9: A5 03        UM_STAR_1:      lda     <3                      ; Shift multiplier one bit
  1318 00:0AEB: 4A                           lsr     a
  1319 00:0AEC: 90 07                        bcc     UM_STAR_2               ; Not set, no add
  1320 00:0AEE: A3 01                        lda     1,s                     ; Fetch multiplicand
  1321 00:0AF0: 18                           clc
  1322 00:0AF1: 65 01                        adc     <1
  1323 00:0AF3: 85 01                        sta     <1
  1324 00:0AF5: 66 01        UM_STAR_2:      ror     <1                      ; Rotate high word down
  1325 00:0AF7: 66 03                        ror     <3
  1326 00:0AF9: CA                           dex
  1327 00:0AFA: D0 ED                        bne     UM_STAR_1
  1328 00:0AFC: 68                           pla
  1329 00:0AFD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0B01: 00 00 
  1330                        
  1331                        ;===============================================================================
  1332                        ; Comparisons
  1333                        ;-------------------------------------------------------------------------------
  1334                        
  1335                        ; 0< ( n -- flag )
  1336                        ;
  1337                        ; flag is true if and only if n is less than zero.
  1338                        
  1339 00:0B03: DD 0A 00 02                  HEADER  2,"0<",NORMAL
       00:0B07: 30 3C 
  1340                        ZERO_LESS:
  1341 00:0B09: A5 01                        lda     <1                      ; Test top of stack
  1342 00:0B0B: 64 01                        stz     <1                      ; Assume false result
  1343 00:0B0D: 10 02                        bpl     ZERO_LT_1               ; Was the value negative?
  1344 00:0B0F: C6 01                        dec     <1                      ; Yes, make true result
  1345 00:0B11: BB C8 C8 7C  ZERO_LT_1:      CONTINUE                        ; Done
       00:0B15: 00 00 
  Mon Apr 18 2016 15:06                                                                                                    Page 29


  1346                        
  1347                        ; 0<> ( x -- flag )
  1348                        ;
  1349                        ; flag is true if and only if x is not equal to zero.
  1350                        
  1351 00:0B17: 06 0B 00 03                  HEADER  3,"0<>",NORMAL
       00:0B1B: 30 3C 3E 
  1352                        ZERO_NOT_EQUAL:
  1353 00:0B1E: A5 01                        lda     <1                      ; Test top of stack
  1354 00:0B20: 64 01                        stz     <1                      ; Assume false result
  1355 00:0B22: F0 02                        beq     ZERO_NE_1               ; Was the value non-zero?
  1356 00:0B24: C6 01                        dec     <1                      ; Yes, make true result
  1357 00:0B26: BB C8 C8 7C  ZERO_NE_1:      CONTINUE                        ; Done
       00:0B2A: 00 00 
  1358                        
  1359                        ; 0= ( x -- flag )
  1360                        ;
  1361                        ; flag is true if and only if x is equal to zero.
  1362                        
  1363 00:0B2C: 1A 0B 00 02                  HEADER  2,"0=",NORMAL
       00:0B30: 30 3D 
  1364                        ZERO_EQUAL:
  1365 00:0B32: A5 01                        lda     <1                      ; Test top of stack
  1366 00:0B34: 64 01                        stz     <1                      ; Assume false result
  1367 00:0B36: D0 02                        bne     ZERO_EQ_1               ; Was the value zero?
  1368 00:0B38: C6 01                        dec     <1                      ; Yes, make true result
  1369 00:0B3A: BB C8 C8 7C  ZERO_EQ_1:      CONTINUE                        ; Done
       00:0B3E: 00 00 
  1370                        
  1371                        ; 0> ( n -- flag )
  1372                        ;
  1373                        ; flag is true if and only if n is greater than zero.
  1374                        
  1375 00:0B40: 2F 0B 00 02                  HEADER  2,"0>",NORMAL
       00:0B44: 30 3E 
  1376                        ZERO_GREATER:
  1377 00:0B46: A5 01                        lda     <1                      ; Test top of stack
  1378 00:0B48: 64 01                        stz     <1                      ; Assume false result
  1379 00:0B4A: 30 04                        bmi     ZERO_GT_EXIT            ; Was the value positive?
  1380 00:0B4C: F0 02                        beq     ZERO_GT_EXIT            ; .. but not zero
  1381 00:0B4E: C6 01                        dec     <1                      ; Yes, make true result
  1382 00:0B50: BB C8 C8 7C  ZERO_GT_EXIT:   CONTINUE                        ; Done
       00:0B54: 00 00 
  1383                        
  1384                        ; <
  1385                        
  1386 00:0B56: 43 0B 00 01                  HEADER  1,"<",NORMAL
       00:0B5A: 3C 
  1387                        LESS:
  1388 00:0B5B: A6 01                        ldx     <1                      ; Pull x2 from stack
  1389 00:0B5D: 7B                           tdc
  1390 00:0B5E: 1A                           inc     a
  1391 00:0B5F: 1A                           inc     a
  1392 00:0B60: 5B                           tcd
  1393 00:0B61: 8A                           txa
  1394 00:0B62: 38                           sec                             ; Compare with x1
  1395 00:0B63: E5 01                        sbc     <1
  1396 00:0B65: 64 01                        stz     <1                      ; Assume false result
  Mon Apr 18 2016 15:06                                                                                                    Page 30


  1397 00:0B67: 70 04                        bvs     LESS_1
  1398 00:0B69: 10 04                        bpl     LESS_2                  ; V == 0 && N == 0
  1399 00:0B6B: 80 04                        bra     LESS_3
  1400 00:0B6D: 10 02        LESS_1:         bpl     LESS_3                  ; V == 1 && N == 1
  1401 00:0B6F: C6 01        LESS_2:         dec     <1
  1402 00:0B71: BB C8 C8 7C  LESS_3:         CONTINUE
       00:0B75: 00 00 
  1403                        
  1404                        ; <>
  1405                        
  1406 00:0B77: 59 0B 00 02                  HEADER  2,"<>",NORMAL
       00:0B7B: 3C 3E 
  1407                        NOT_EQUAL:
  1408 00:0B7D: A6 01                        ldx     <1                      ; Pull x2 from stack
  1409 00:0B7F: 7B                           tdc
  1410 00:0B80: 1A                           inc     a
  1411 00:0B81: 1A                           inc     a
  1412 00:0B82: 5B                           tcd
  1413 00:0B83: E4 01                        cpx     <1                      ; Compare with x1
  1414 00:0B85: 64 01                        stz     <1                      ; Assume equal
  1415 00:0B87: F0 02                        beq     NE_EXIT                 ; Test flags
  1416 00:0B89: C6 01                        dec     <1                      ; Make result true
  1417 00:0B8B: BB C8 C8 7C  NE_EXIT:        CONTINUE                        ; Done
       00:0B8F: 00 00 
  1418                        
  1419                        ; = ( x1 x2 -- flag )
  1420                        ;
  1421                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1422                        
  1423 00:0B91: 7A 0B 00 01                  HEADER  1,"=",NORMAL
       00:0B95: 3D 
  1424                        EQUAL:
  1425 00:0B96: A6 01                        ldx     <1                      ; Pull x2 from stack
  1426 00:0B98: 7B                           tdc
  1427 00:0B99: 1A                           inc     a
  1428 00:0B9A: 1A                           inc     a
  1429 00:0B9B: 5B                           tcd
  1430 00:0B9C: E4 01                        cpx     <1                      ; Compare with x1
  1431 00:0B9E: 64 01                        stz     <1                      ; Assume not equal
  1432 00:0BA0: D0 02                        bne     EQ_EXIT                 ; Test the flags
  1433 00:0BA2: C6 01                        dec     <1                      ; Make result true
  1434 00:0BA4: BB C8 C8 7C  EQ_EXIT:        CONTINUE                        ; Done
       00:0BA8: 00 00 
  1435                        
  1436                        ; >
  1437                        
  1438 00:0BAA: 94 0B 00 01                  HEADER  1,">",NORMAL
       00:0BAE: 3E 
  1439 00:0BAF: 20 87 12     GREATER:        jsr     DO_COLON
  1440 00:0BB2: EE 07                        dw      SWAP
  1441 00:0BB4: 5B 0B                        dw      LESS
  1442 00:0BB6: 02 0D                        dw      EXIT
  1443                        
  1444                        ; U<
  1445                        
  1446 00:0BB8: AD 0B 00 02                  HEADER  2,"U<",NORMAL
       00:0BBC: 55 3C 
  1447                        U_LESS:
  Mon Apr 18 2016 15:06                                                                                                    Page 31


  1448 00:0BBE: A6 01                        ldx     <1                      ; Pull x2
  1449 00:0BC0: 7B                           tdc                             ; Drop from stack
  1450 00:0BC1: 1A                           inc     a
  1451 00:0BC2: 1A                           inc     a
  1452 00:0BC3: 5B                           tcd
  1453 00:0BC4: E4 01                        cpx     <1                      ; Compare with x1
  1454 00:0BC6: 64 01                        stz     <1                      ; Assume false
  1455 00:0BC8: F0 04                        beq     U_LESS_1                ; Equal
  1456 00:0BCA: 90 02                        bcc     U_LESS_1                ; Less
  1457 00:0BCC: C6 01                        dec     <1
  1458 00:0BCE: BB C8 C8 7C  U_LESS_1:       CONTINUE
       00:0BD2: 00 00 
  1459                        
  1460                        ; U>
  1461                        
  1462 00:0BD4: BB 0B 00 02                  HEADER  2,"U>",NORMAL
       00:0BD8: 55 3E 
  1463 00:0BDA: 20 87 12     U_GREATER:      jsr     DO_COLON
  1464 00:0BDD: EE 07                        dw      SWAP
  1465 00:0BDF: BE 0B                        dw      U_LESS
  1466 00:0BE1: 02 0D                        dw      EXIT
  1467                        
  1468                        ;===============================================================================
  1469                        ; Logical Operations
  1470                        ;-------------------------------------------------------------------------------
  1471                        
  1472                        ; AND ( x1 x2 -- x3 )
  1473                        ;
  1474                        ; x3 is the bit-by-bit logical “and” of x1 with x2.
  1475                        
  1476 00:0BE3: D7 0B 00 03                  HEADER  3,"AND",NORMAL
       00:0BE7: 41 4E 44 
  1477                        AND:
  1478 00:0BEA: A5 01                        lda     <1
  1479 00:0BEC: 25 03                        and     <3
  1480 00:0BEE: 85 03                        sta     <3
  1481 00:0BF0: 7B                           tdc
  1482 00:0BF1: 1A                           inc     a
  1483 00:0BF2: 1A                           inc     a
  1484 00:0BF3: 5B                           tcd
  1485 00:0BF4: BB C8 C8 7C                  CONTINUE
       00:0BF8: 00 00 
  1486                        
  1487                        ; INVERT ( x1 -- x2 )
  1488                        ;
  1489                        ; Invert all bits of x1, giving its logical inverse x2.
  1490                        
  1491 00:0BFA: E6 0B 00 06                  HEADER  6,"INVERT",NORMAL
       00:0BFE: 49 4E 56 45 
       00:0C02: 52 54 
  1492                        INVERT:
  1493 00:0C04: A5 01                        lda     <1                      ; Fetch top value
  1494 00:0C06: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1495 00:0C09: 85 01                        sta     <1                      ; .. and write back
  1496 00:0C0B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C0F: 00 00 
  1497                        
  1498                        ; LSHIFT ( x1 u -- x2 )
  Mon Apr 18 2016 15:06                                                                                                    Page 32


  1499                        ;
  1500                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1501                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1502                        ; exists if u is greater than or equal to the number of bits in a cell.
  1503                        
  1504 00:0C11: FD 0B 00 06                  HEADER  6,"LSHIFT",NORMAL
       00:0C15: 4C 53 48 49 
       00:0C19: 46 54 
  1505                        LSHIFT:
  1506 00:0C1B: A6 01                        ldx     <1                      ; Pull bit count
  1507 00:0C1D: 08                           php
  1508 00:0C1E: 7B                           tdc
  1509 00:0C1F: 1A                           inc     a                       ; .. from the stack
  1510 00:0C20: 1A                           inc     a
  1511 00:0C21: 5B                           tcd
  1512 00:0C22: 28                           plp
  1513 00:0C23: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1514 00:0C25: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1515 00:0C28: B0 0B                        bcs     LSHIFT_2                ; Yes, result will be zero
  1516 00:0C2A: 06 01        LSHIFT_1        asl     <1                      ; Shift one bit left
  1517 00:0C2C: CA                           dex                             ; Update count
  1518 00:0C2D: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1519 00:0C2F: BB C8 C8 7C  LSHIFT_0        CONTINUE                        ; Done
       00:0C33: 00 00 
  1520 00:0C35: 64 01        LSHIFT_2        stz     <1                      ; Clear top value
  1521 00:0C37: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C3B: 00 00 
  1522                        
  1523                        ; OR ( x1 x2 -- x3 )
  1524                        ;
  1525                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1526                        
  1527 00:0C3D: 14 0C 00 02                  HEADER  2,"OR",NORMAL
       00:0C41: 4F 52 
  1528                        OR:
  1529 00:0C43: A5 01                        lda     <1
  1530 00:0C45: 05 03                        ora     <3
  1531 00:0C47: 85 03                        sta     <3
  1532 00:0C49: 7B                           tdc
  1533 00:0C4A: 1A                           inc     a
  1534 00:0C4B: 1A                           inc     a
  1535 00:0C4C: 5B                           tcd
  1536 00:0C4D: BB C8 C8 7C                  CONTINUE
       00:0C51: 00 00 
  1537                        
  1538                        ; RSHIFT ( x1 u -- x2 )
  1539                        ;
  1540                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1541                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1542                        ; exists if u is greater than or equal to the number of bits in a cell.
  1543                        
  1544 00:0C53: 40 0C 00 06                  HEADER  6,"RSHIFT",NORMAL
       00:0C57: 52 53 48 49 
       00:0C5B: 46 54 
  1545                        RSHIFT:
  1546 00:0C5D: A6 01                        ldx     <1                      ; Pull bit count
  1547 00:0C5F: 08                           php
  1548 00:0C60: 7B                           tdc
  Mon Apr 18 2016 15:06                                                                                                    Page 33


  1549 00:0C61: 1A                           inc     a                       ; .. from the stack
  1550 00:0C62: 1A                           inc     a
  1551 00:0C63: 5B                           tcd
  1552 00:0C64: 28                           plp
  1553 00:0C65: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1554 00:0C67: E0 10 00                     cpx     #16                     ; Shifting by 16+ bits
  1555 00:0C6A: B0 0B                        bcs     RSHIFT_2                ; Yes, result will be zero
  1556 00:0C6C: 46 01        RSHIFT_1        lsr     <1                      ; Shift one bit left
  1557 00:0C6E: CA                           dex                             ; Update count
  1558 00:0C6F: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1559 00:0C71: BB C8 C8 7C  RSHIFT_0        CONTINUE                        ; Done
       00:0C75: 00 00 
  1560 00:0C77: 64 01        RSHIFT_2        stz     <1                      ; Clear top value
  1561 00:0C79: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0C7D: 00 00 
  1562                        
  1563                        ; XOR ( x1 x2 -- x3 )
  1564                        ;
  1565                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1566                        
  1567 00:0C7F: 56 0C 00 03                  HEADER  3,"XOR",NORMAL
       00:0C83: 58 4F 52 
  1568                        XOR:
  1569 00:0C86: A5 01                        lda     <1
  1570 00:0C88: 45 03                        eor     <3
  1571 00:0C8A: 85 03                        sta     <3
  1572 00:0C8C: 7B                           tdc
  1573 00:0C8D: 1A                           inc     a
  1574 00:0C8E: 1A                           inc     a
  1575 00:0C8F: 5B                           tcd
  1576 00:0C90: BB C8 C8 7C                  CONTINUE
       00:0C94: 00 00 
  1577                        
  1578                        ;===============================================================================
  1579                        ; Control Words
  1580                        ;-------------------------------------------------------------------------------
  1581                        
  1582                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1583                        ;
  1584                        ; Empty the data stack and perform the function of QUIT, which includes
  1585                        ; emptying the return stack, without displaying a message.
  1586                        
  1587 00:0C96: 82 0C 00 05                  HEADER  5,"ABORT",NORMAL
       00:0C9A: 41 42 4F 52 
       00:0C9E: 54 
  1588 00:0C9F: 20 87 12     ABORT:          jsr     DO_COLON
  1589 00:0CA2: A6 0C                        dw      DO_ABORT
  1590 00:0CA4: 11 0D                        dw      QUIT
  1591                        
  1592                        DO_ABORT:
  1593 00:0CA6: A9 7F 01                     lda     #DSTACK_END-1
  1594 00:0CA9: 5B                           tcd
  1595 00:0CAA: BB C8 C8 7C                  CONTINUE
       00:0CAE: 00 00 
  1596                        
  1597                        ; (BUILD) ( dtc-addr -- )
  1598                        ;
  1599                        ; Adds a jump the to exection function for the new word.
  Mon Apr 18 2016 15:06                                                                                                    Page 34


  1600                        
  1601                        ;               HEADER  7,"(BUILD)",NORMAL
  1602 00:0CB0: 20 87 12     BUILD:          jsr     DO_COLON
  1603 00:0CB3: 67 13 20 00                  dw      DO_LITERAL,$20
  1604 00:0CB7: F0 05                        dw      C_COMMA
  1605 00:0CB9: 74 05                        dw      COMMA
  1606 00:0CBB: 02 0D                        dw      EXIT
  1607                        
  1608                        ; CREATE ( -- ) [TODO]
  1609                        ;
  1610                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1611                        ; definition for name with the execution semantics defined below. If the data-
  1612                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1613                        ; data-space pointer defines name’s data field. CREATE does not allocate data
  1614                        ; space in name’s data field.
  1615                        
  1616 00:0CBD: 99 0C 00 06                  HEADER  6,"CREATE",NORMAL
       00:0CC1: 43 52 45 41 
       00:0CC5: 54 45 
  1617 00:0CC7: 20 87 12     CREATE:         jsr     DO_COLON
  1618 00:0CCA: 8F 04                        dw      LATEST
  1619 00:0CCC: B4 05                        dw      FETCH
  1620 00:0CCE: 74 05                        dw      COMMA
  1621 00:0CD0: C9 04                        dw      ZERO
  1622 00:0CD2: F0 05                        dw      C_COMMA
  1623 00:0CD4: 1F 06                        dw      HERE
  1624 00:0CD6: 8F 04                        dw      LATEST
  1625 00:0CD8: 46 05                        dw      STORE
  1626 00:0CDA: DB 04                        dw      BL
  1627 00:0CDC: D0 10                        dw      WORD
  1628 00:0CDE: 07 06                        dw      C_FETCH
  1629 00:0CE0: 2E 09                        dw      ONE_PLUS
  1630 00:0CE2: C7 05                        dw      ALLOT
  1631 00:0CE4: 02 0D                        dw      EXIT
  1632                        
  1633                        ; EXECUTE ( i*x xt -- j*x )
  1634                        ;
  1635                        ; Remove xt from the stack and perform the semantics identified by it. Other
  1636                        ; stack effects are due to the word EXECUTEd.
  1637                        
  1638 00:0CE6: C0 0C 00 07                  HEADER  7,"EXECUTE",NORMAL
       00:0CEA: 45 58 45 43 
       00:0CEE: 55 54 45 
  1639                        EXECUTE:
  1640 00:0CF1: A6 01                        ldx     <1
  1641 00:0CF3: 7B                           tdc
  1642 00:0CF4: 1A                           inc     a
  1643 00:0CF5: 1A                           inc     a
  1644 00:0CF6: 5B                           tcd
  1645 00:0CF7: CA                           dex
  1646 00:0CF8: DA                           phx
  1647 00:0CF9: 60                           rts
  1648                        
  1649                        ; EXIT ( -- ) ( R: nest-sys -- )
  1650                        ;
  1651                        ; Return control to the calling definition specified by nest-sys. Before
  1652                        ; executing EXIT within a do-loop, a program shall discard the loop-control
  1653                        ; parameters by executing UNLOOP.
  Mon Apr 18 2016 15:06                                                                                                    Page 35


  1654                        
  1655 00:0CFA: E9 0C 00 04                  HEADER  4,"EXIT",NORMAL
       00:0CFE: 45 58 49 54 
  1656                        EXIT:
  1657 00:0D02: 7A                           ply
  1658 00:0D03: BB C8 C8 7C                  CONTINUE
       00:0D07: 00 00 
  1659                        
  1660                        ; QUIT ( -- ) ( R: i*x -- )
  1661                        ;
  1662                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1663                        ; user input device the input source, and enter interpretation state. Do not
  1664                        ; display a message. Repeat the following:
  1665                        ; – Accept a line from the input source into the input buffer, set >IN to zero,
  1666                        ;   and interpret.
  1667                        ; – Display the implementation-defined system prompt if in interpretation state,
  1668                        ;   all processing has been completed, and no ambiguous condition exists.
  1669                        ;
  1670                        ; In this implementation it is defined as:
  1671                        ;
  1672                        ;   DO_QUIT 0 STATE !
  1673                        ;   0 (SOURCE-ID) !
  1674                        ;   BEGIN
  1675                        ;     REFILL
  1676                        ;     WHILE SOURCE EVALUATE
  1677                        ;     STATE @ 0= IF S" Ok" CR TYPE THEN
  1678                        ;   AGAIN ;
  1679                        
  1680 00:0D09: FD 0C 00 04                  HEADER  4,"QUIT",NORMAL
       00:0D0D: 51 55 49 54 
  1681 00:0D11: 20 87 12     QUIT:           jsr     DO_COLON
  1682 00:0D14: 41 0D                        dw      DO_QUIT
  1683 00:0D16: C9 04                        dw      ZERO
  1684 00:0D18: B3 04                        dw      STATE
  1685 00:0D1A: 46 05                        dw      STORE
  1686 00:0D1C: C9 04                        dw      ZERO
  1687 00:0D1E: A5 04                        dw      SOURCEID
  1688 00:0D20: 46 05                        dw      STORE
  1689 00:0D22: CB 0F        QUIT_1:         dw      REFILL
  1690 00:0D24: 30 12 2A 0D                  dw      QUERY_BRANCH,QUIT_2
  1691 00:0D28: 02 0F                        dw      INTERPRET
  1692 00:0D2A: B3 04        QUIT_2:         dw      STATE
  1693 00:0D2C: B4 05                        dw      FETCH
  1694 00:0D2E: 32 0B                        dw      ZERO_EQUAL
  1695 00:0D30: 30 12 3D 0D                  dw      QUERY_BRANCH,QUIT_3
  1696 00:0D34: CD 13                        dw      DO_S_QUOTE
  1697 00:0D36: 02 4F 6B                     db      2,"Ok"
  1698 00:0D39: 58 15                        dw      TYPE
  1699 00:0D3B: DB 14                        dw      CR
  1700 00:0D3D: 26 12 22 0D  QUIT_3:         dw      BRANCH,QUIT_1
  1701                        
  1702                        DO_QUIT:
  1703 00:0D41: A9 FF 01                     lda     #RSTACK_END-1           ; Reset the return stack
  1704 00:0D44: 1B                           tcs
  1705 00:0D45: BB C8 C8 7C                  CONTINUE                        ; Done
       00:0D49: 00 00 
  1706                        
  1707                        ;===============================================================================
  Mon Apr 18 2016 15:06                                                                                                    Page 36


  1708                        ; Parser & Interpreter
  1709                        ;-------------------------------------------------------------------------------
  1710                        
  1711                        ; ?NUMBER
  1712                        ;
  1713                        ;   DUP  0 0 ROT COUNT      -- ca ud adr n
  1714                        ;   ?SIGN >R  >NUMBER       -- ca ud adr' n'
  1715                        ;   IF   R> 2DROP 2DROP 0   -- ca 0   (error)
  1716                        ;   ELSE 2DROP NIP R>
  1717                        ;       IF NEGATE THEN  -1  -- n -1   (ok)
  1718                        ;   THEN ;
  1719                        
  1720 00:0D4B: 0C 0D 00 07                  HEADER  7,"?NUMBER",NORMAL
       00:0D4F: 3F 4E 55 4D 
       00:0D53: 42 45 52 
  1721 00:0D56: 20 87 12     QUERY_NUMBER:   jsr     DO_COLON
  1722 00:0D59: 80 07                        dw      DUP
  1723 00:0D5B: C9 04                        dw      ZERO
  1724 00:0D5D: C9 04                        dw      ZERO
  1725 00:0D5F: D4 07                        dw      ROT
  1726 00:0D61: DF 11                        dw      COUNT
  1727 00:0D63: 94 0D                        dw      QUERY_SIGN
  1728 00:0D65: 60 08                        dw      TO_R
  1729 00:0D67: DB 0D                        dw      TO_NUMBER
  1730 00:0D69: 30 12 79 0D                  dw      QUERY_BRANCH,QNUM_1
  1731 00:0D6D: 99 08                        dw      R_FROM
  1732 00:0D6F: A6 06                        dw      TWO_DROP
  1733 00:0D71: A6 06                        dw      TWO_DROP
  1734 00:0D73: C9 04                        dw      ZERO
  1735 00:0D75: 26 12 89 0D                  dw      BRANCH,QNUM_3
  1736 00:0D79: A6 06        QNUM_1:         dw      TWO_DROP
  1737 00:0D7B: 95 07                        dw      NIP
  1738 00:0D7D: 99 08                        dw      R_FROM
  1739 00:0D7F: 30 12 85 0D                  dw      QUERY_BRANCH,QNUM_2
  1740 00:0D83: BE 09                        dw      NEGATE
  1741 00:0D85: 67 13 FF FF  QNUM_2:         dw      DO_LITERAL,-1
  1742 00:0D89: 02 0D        QNUM_3:         dw      EXIT
  1743                        
  1744                        ; ?SIGN ( c-addr n -- adr' n' f )
  1745                        ;
  1746                        ;   OVER C@                 -- adr n c
  1747                        ;   2C - DUP ABS 1 = AND    -- +=-1, -=+1, else 0
  1748                        ;   DUP IF 1+               -- +=0, -=+2
  1749                        ;       >R 1 /STRING R>     -- adr' n' f
  1750                        ;   THEN ;
  1751                        
  1752 00:0D8B: 4E 0D 00 05                  HEADER  5,"?SIGN",NORMAL
       00:0D8F: 3F 53 49 47 
       00:0D93: 4E 
  1753 00:0D94: 20 87 12     QUERY_SIGN:     jsr     DO_COLON
  1754 00:0D97: A3 07                        dw      OVER
  1755 00:0D99: 07 06                        dw      C_FETCH
  1756 00:0D9B: 67 13 2D 00                  dw      DO_LITERAL,'-'
  1757 00:0D9F: FB 08                        dw      MINUS
  1758 00:0DA1: 80 07                        dw      DUP
  1759 00:0DA3: 6A 09                        dw      ABS
  1760 00:0DA5: 67 13 01 00                  dw      DO_LITERAL,1
  1761 00:0DA9: 96 0B                        dw      EQUAL
  Mon Apr 18 2016 15:06                                                                                                    Page 37


  1762 00:0DAB: EA 0B                        dw      AND
  1763 00:0DAD: 80 07                        dw      DUP
  1764 00:0DAF: 30 12 BF 0D                  dw      QUERY_BRANCH,QSIGN_1
  1765 00:0DB3: 2E 09                        dw      ONE_PLUS
  1766 00:0DB5: 60 08                        dw      TO_R
  1767 00:0DB7: 67 13 01 00                  dw      DO_LITERAL,1
  1768 00:0DBB: 34 11                        dw      SLASH_STRING
  1769 00:0DBD: 99 08                        dw      R_FROM
  1770 00:0DBF: 02 0D        QSIGN_1:        dw      EXIT
  1771                        
  1772                        ; >COUNTED ( c-addr n -- )
  1773                        ;
  1774                        ;   2DUP C! CHAR+ SWAP CMOVE
  1775                        
  1776 00:0DC1: 20 87 12     TO_COUNTED:     jsr     DO_COLON
  1777 00:0DC4: BA 06                        dw      TWO_DUP
  1778 00:0DC6: D6 05                        dw      C_STORE
  1779 00:0DC8: 75 06                        dw      CHAR_PLUS
  1780 00:0DCA: EE 07                        dw      SWAP
  1781 00:0DCC: 78 11                        dw      CMOVE
  1782 00:0DCE: 02 0D                        dw      EXIT
  1783                        
  1784                        ; >NUMBER ( ud adr u -- ud' adr' u' )
  1785                        ;
  1786                        ;
  1787                        ;   BEGIN
  1788                        ;   DUP WHILE
  1789                        ;       OVER C@ DIGIT?
  1790                        ;       0= IF DROP EXIT THEN
  1791                        ;       >R 2SWAP BASE @ UD*
  1792                        ;       R> M+ 2SWAP
  1793                        ;       1 /STRING
  1794                        ;   REPEAT ;
  1795                        
  1796 00:0DD0: 8E 0D 00 07                  HEADER  7,">NUMBER",NORMAL
       00:0DD4: 3E 4E 55 4D 
       00:0DD8: 42 45 52 
  1797 00:0DDB: 20 87 12     TO_NUMBER:      jsr     DO_COLON
  1798 00:0DDE: 80 07        TO_NUM_1:       dw      DUP
  1799 00:0DE0: 30 12 0E 0E                  dw      QUERY_BRANCH,TO_NUM_3
  1800 00:0DE4: A3 07                        dw      OVER
  1801 00:0DE6: 07 06                        dw      C_FETCH
  1802 00:0DE8: 8D 0E                        dw      DIGIT_QUERY
  1803 00:0DEA: 32 0B                        dw      ZERO_EQUAL
  1804 00:0DEC: 30 12 F4 0D                  dw      QUERY_BRANCH,TO_NUM_2
  1805 00:0DF0: 6F 07                        dw      DROP
  1806 00:0DF2: 02 0D                        dw      EXIT
  1807 00:0DF4: 60 08        TO_NUM_2:       dw      TO_R
  1808 00:0DF6: 21 07                        dw      TWO_SWAP
  1809 00:0DF8: 64 04                        dw      BASE
  1810 00:0DFA: B4 05                        dw      FETCH
  1811 00:0DFC: 7E 0A                        dw      UD_STAR
  1812 00:0DFE: 99 08                        dw      R_FROM
  1813 00:0E00: AC 0A                        dw      M_PLUS
  1814 00:0E02: 21 07                        dw      TWO_SWAP
  1815 00:0E04: 67 13 01 00                  dw      DO_LITERAL,1
  1816 00:0E08: 34 11                        dw      SLASH_STRING
  1817 00:0E0A: 26 12 DE 0D                  dw      BRANCH,TO_NUM_1
  Mon Apr 18 2016 15:06                                                                                                    Page 38


  1818 00:0E0E: 02 0D        TO_NUM_3:       dw      EXIT
  1819                        
  1820                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1821                        ;
  1822                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1823                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1824                        ; received. A program that depends on the presence or absence of non-graphic
  1825                        ; characters in the string has an environmental dependency. The editing
  1826                        ; functions, if any, that the system performs in order to construct the string
  1827                        ; are implementation-defined.
  1828                        ;
  1829                        ; Input terminates when an implementation-defined line terminator is received.
  1830                        ; When input terminates, nothing is appended to the string, and the display is
  1831                        ; maintained in an implementation-defined way.
  1832                        ;
  1833                        ; +n2 is the length of the string stored at c-addr.
  1834                        ;
  1835                        ;   OVER + 1- OVER      -- sa ea a
  1836                        ;   BEGIN KEY           -- sa ea a c
  1837                        ;   DUP 0D <> WHILE
  1838                        ;     DUP 8 = OVER 127 = OR IF
  1839                        ;       DROP 1-
  1840                        ;       >R OVER R> UMAX
  1841                        ;       8 EMIT SPACE 8 EMIT
  1842                        ;     ELSE
  1843                        ;       DUP EMIT        -- sa ea a c
  1844                        ;       OVER C! 1+ OVER UMIN
  1845                        ;     THEN              -- sa ea a
  1846                        ;   REPEAT              -- sa ea a c
  1847                        ;   DROP NIP SWAP - ;
  1848                        
  1849 00:0E10: D3 0D 00 06                  HEADER  6,"ACCEPT",NORMAL
       00:0E14: 41 43 43 45 
       00:0E18: 50 54 
  1850 00:0E1A: 20 87 12     ACCEPT:         jsr     DO_COLON
  1851 00:0E1D: A3 07                        dw      OVER
  1852 00:0E1F: E5 08                        dw      PLUS
  1853 00:0E21: 3C 09                        dw      ONE_MINUS
  1854 00:0E23: A3 07                        dw      OVER
  1855 00:0E25: 0A 15        ACCEPT_1:       dw      KEY
  1856 00:0E27: 80 07                        dw      DUP
  1857 00:0E29: 67 13 0D 00                  dw      DO_LITERAL,$0D
  1858 00:0E2D: 7D 0B                        dw      NOT_EQUAL
  1859 00:0E2F: 30 12 79 0E                  dw      QUERY_BRANCH,ACCEPT_4
  1860 00:0E33: 80 07                        dw      DUP
  1861 00:0E35: 67 13 08 00                  dw      DO_LITERAL,$08
  1862 00:0E39: 96 0B                        dw      EQUAL
  1863 00:0E3B: A3 07                        dw      OVER
  1864 00:0E3D: 67 13 7F 00                  dw      DO_LITERAL,$7f
  1865 00:0E41: 96 0B                        dw      EQUAL
  1866 00:0E43: 43 0C                        dw      OR
  1867 00:0E45: 30 12 67 0E                  dw      QUERY_BRANCH,ACCEPT_2
  1868 00:0E49: 6F 07                        dw      DROP
  1869 00:0E4B: 3C 09                        dw      ONE_MINUS
  1870 00:0E4D: 60 08                        dw      TO_R
  1871 00:0E4F: A3 07                        dw      OVER
  1872 00:0E51: 99 08                        dw      R_FROM
  1873 00:0E53: D4 09                        dw      UMAX
  Mon Apr 18 2016 15:06                                                                                                    Page 39


  1874 00:0E55: 67 13 08 00                  dw      DO_LITERAL,8
  1875 00:0E59: F4 14                        dw      EMIT
  1876 00:0E5B: 26 15                        dw      SPACE
  1877 00:0E5D: 67 13 08 00                  dw      DO_LITERAL,8
  1878 00:0E61: F4 14                        dw      EMIT
  1879 00:0E63: 26 12 75 0E                  dw      BRANCH,ACCEPT_3
  1880 00:0E67: 80 07        ACCEPT_2:       dw      DUP
  1881 00:0E69: F4 14                        dw      EMIT
  1882 00:0E6B: A3 07                        dw      OVER
  1883 00:0E6D: D6 05                        dw      C_STORE
  1884 00:0E6F: 2E 09                        dw      ONE_PLUS
  1885 00:0E71: A3 07                        dw      OVER
  1886 00:0E73: E8 09                        dw      UMIN
  1887 00:0E75: 26 12 25 0E  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1888 00:0E79: 6F 07        ACCEPT_4:       dw      DROP
  1889 00:0E7B: 95 07                        dw      NIP
  1890 00:0E7D: EE 07                        dw      SWAP
  1891 00:0E7F: FB 08                        dw      MINUS
  1892 00:0E81: 02 0D                        dw      EXIT
  1893                        
  1894                        ; DIGIT?
  1895                        ;
  1896                        ;   [ HEX ] DUP 39 > 100 AND +     silly looking
  1897                        ;   DUP 140 > 107 AND -   30 -     but it works!
  1898                        ;   DUP BASE @ U< ;
  1899                        
  1900 00:0E83: 13 0E 00 06                  HEADER  6,"DIGIT?",NORMAL
       00:0E87: 44 49 47 49 
       00:0E8B: 54 3F 
  1901 00:0E8D: 20 87 12     DIGIT_QUERY:    jsr     DO_COLON
  1902 00:0E90: 80 07                        dw      DUP
  1903 00:0E92: 67 13 39 00                  dw      DO_LITERAL,'9'
  1904 00:0E96: AF 0B                        dw      GREATER
  1905 00:0E98: 67 13 00 01                  dw      DO_LITERAL,$100
  1906 00:0E9C: EA 0B                        dw      AND
  1907 00:0E9E: E5 08                        dw      PLUS
  1908 00:0EA0: 80 07                        dw      DUP
  1909 00:0EA2: 67 13 40 01                  dw      DO_LITERAL,$140
  1910 00:0EA6: AF 0B                        dw      GREATER
  1911 00:0EA8: 67 13 07 01                  dw      DO_LITERAL,$107
  1912 00:0EAC: EA 0B                        dw      AND
  1913 00:0EAE: FB 08                        dw      MINUS
  1914 00:0EB0: 67 13 30 00                  dw      DO_LITERAL,'0'
  1915 00:0EB4: FB 08                        dw      MINUS
  1916 00:0EB6: 80 07                        dw      DUP
  1917 00:0EB8: 64 04                        dw      BASE
  1918 00:0EBA: B4 05                        dw      FETCH
  1919 00:0EBC: BE 0B                        dw      U_LESS
  1920 00:0EBE: 02 0D                        dw      EXIT
  1921                        
  1922                        ; EVALUATE ( i*x c-addr u -- j*x )
  1923                        ;
  1924                        ; Save the current input source specification. Store minus-one (-1) in
  1925                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1926                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1927                        ; parse area is empty, restore the prior input source specification. Other
  1928                        ; stack effects are due to the words EVALUATEd.
  1929                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 40


  1930                        ;   >R >R SAVE-INPUT
  1931                        ;   -1 (SOURCE-ID) !
  1932                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1933                        ;   INTERPRET
  1934                        ;   RESTORE-INPUT DROP
  1935                        
  1936 00:0EC0: 86 0E 00 08                  HEADER  8,"EVALUATE",NORMAL
       00:0EC4: 45 56 41 4C 
       00:0EC8: 55 41 54 45 
  1937 00:0ECC: 20 87 12     EVALUATE:       jsr     DO_COLON
  1938 00:0ECF: 60 08                        dw      TO_R
  1939 00:0ED1: 60 08                        dw      TO_R
  1940 00:0ED3: 58 10                        dw      SAVE_INPUT
  1941 00:0ED5: 99 08                        dw      R_FROM
  1942 00:0ED7: 99 08                        dw      R_FROM
  1943 00:0ED9: 07 05                        dw      TRUE
  1944 00:0EDB: A5 04                        dw      SOURCEID
  1945 00:0EDD: 46 05                        dw      STORE
  1946 00:0EDF: C9 04                        dw      ZERO
  1947 00:0EE1: 57 04                        dw      TO_IN
  1948 00:0EE3: 46 05                        dw      STORE
  1949 00:0EE5: 94 04                        dw      LENGTH
  1950 00:0EE7: 46 05                        dw      STORE
  1951 00:0EE9: 75 04                        dw      BUFFER
  1952 00:0EEB: 46 05                        dw      STORE
  1953 00:0EED: 02 0F                        dw      INTERPRET
  1954 00:0EEF: 09 10                        dw      RESTORE_INPUT
  1955 00:0EF1: 6F 07                        dw      DROP
  1956 00:0EF3: 02 0D                        dw      EXIT
  1957                        
  1958                        ; INTERPRET ( -- )
  1959                        ;
  1960                        ;
  1961                        ;   BEGIN
  1962                        ;   BL WORD DUP C@ WHILE        -- textadr
  1963                        ;       FIND                    -- a 0/1/-1
  1964                        ;       ?DUP IF                 -- xt 1/-1
  1965                        ;           1+ STATE @ 0= OR    immed or interp?
  1966                        ;           IF EXECUTE ELSE , THEN
  1967                        ;       ELSE                    -- textadr
  1968                        ;           ?NUMBER
  1969                        ;           IF STATE @
  1970                        ;               IF POSTPONE LITERAL THEN     converted ok
  1971                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1972                        ;           THEN
  1973                        ;       THEN
  1974                        ;   REPEAT DROP ;
  1975                        
  1976 00:0EF5: C3 0E 00 09                  HEADER  9,"INTERPRET",NORMAL
       00:0EF9: 49 4E 54 45 
       00:0EFD: 52 50 52 45 
       00:0F01: 54 
  1977 00:0F02: 20 87 12     INTERPRET:      jsr     DO_COLON
  1978 00:0F05: DB 04        INTERPRET_1:    dw      BL
  1979 00:0F07: D0 10                        dw      WORD
  1980 00:0F09: 80 07                        dw      DUP
  1981 00:0F0B: 07 06                        dw      C_FETCH
  1982 00:0F0D: 30 12 59 0F                  dw      QUERY_BRANCH,INTERPRET_7
  Mon Apr 18 2016 15:06                                                                                                    Page 41


  1983 00:0F11: 65 0F                        dw      FIND
  1984 00:0F13: 43 07                        dw      QUERY_DUP
  1985 00:0F15: 30 12 33 0F                  dw      QUERY_BRANCH,INTERPRET_4
  1986 00:0F19: 2E 09                        dw      ONE_PLUS
  1987 00:0F1B: B3 04                        dw      STATE
  1988 00:0F1D: B4 05                        dw      FETCH
  1989 00:0F1F: 32 0B                        dw      ZERO_EQUAL
  1990 00:0F21: 43 0C                        dw      OR
  1991 00:0F23: 30 12 2D 0F                  dw      QUERY_BRANCH,INTERPRET_2
  1992 00:0F27: F1 0C                        dw      EXECUTE
  1993 00:0F29: 26 12 2F 0F                  dw      BRANCH,INTERPRET_3
  1994 00:0F2D: 74 05        INTERPRET_2:    dw      COMMA
  1995 00:0F2F: 26 12 55 0F  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1996 00:0F33: 56 0D        INTERPRET_4:    dw      QUERY_NUMBER
  1997 00:0F35: 30 12 47 0F                  dw      QUERY_BRANCH,INTERPRET_5
  1998 00:0F39: B3 04                        dw      STATE
  1999 00:0F3B: B4 05                        dw      FETCH
  2000 00:0F3D: 30 12 55 0F                  dw      QUERY_BRANCH,INTERPRET_6
  2001 00:0F41: 5A 13                        dw      LITERAL
  2002 00:0F43: 26 12 55 0F                  dw      BRANCH,INTERPRET_6
  2003 00:0F47: DF 11        INTERPRET_5:    dw      COUNT
  2004 00:0F49: 58 15                        dw      TYPE
  2005 00:0F4B: 67 13 3F 00                  dw      DO_LITERAL,$3f
  2006 00:0F4F: F4 14                        dw      EMIT
  2007 00:0F51: DB 14                        dw      CR
  2008 00:0F53: 9F 0C                        dw      ABORT
  2009 00:0F55: 26 12 05 0F  INTERPRET_6     dw      BRANCH,INTERPRET_1
  2010 00:0F59: 6F 07        INTERPRET_7:    dw      DROP
  2011 00:0F5B: 02 0D                        dw      EXIT
  2012                        
  2013                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  2014                        ;
  2015                        ; Find the definition named in the counted string at c-addr. If the definition
  2016                        ; is not found, return c-addr and zero. If the definition is found, return its
  2017                        ; execution token xt. If the definition is immediate, also return one (1),
  2018                        ; otherwise also return minus-one (-1). For a given string, the values returned
  2019                        ; by FIND while compiling may differ from those returned while not compiling.
  2020                        ;
  2021                        ;   LATEST @ BEGIN             -- a nfa
  2022                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  2023                        ;       S=                     -- a nfa f
  2024                        ;       DUP IF
  2025                        ;           DROP
  2026                        ;           NFA>LFA @ DUP      -- a link link
  2027                        ;       THEN
  2028                        ;   0= UNTIL                   -- a nfa  OR  a 0
  2029                        ;   DUP IF
  2030                        ;       NIP DUP NFA>CFA        -- nfa xt
  2031                        ;       SWAP IMMED?            -- xt iflag
  2032                        ;       0= 1 OR                -- xt 1/-1
  2033                        ;   THEN ;
  2034                        
  2035 00:0F5D: F8 0E 00 04                  HEADER  4,"FIND",NORMAL
       00:0F61: 46 49 4E 44 
  2036 00:0F65: 20 87 12     FIND:           jsr     DO_COLON
  2037 00:0F68: 8F 04                        dw      LATEST
  2038 00:0F6A: B4 05                        dw      FETCH
  2039 00:0F6C: BA 06        FIND1:          dw      TWO_DUP
  Mon Apr 18 2016 15:06                                                                                                    Page 42


  2040 00:0F6E: A3 07                        dw      OVER
  2041 00:0F70: 07 06                        dw      C_FETCH
  2042 00:0F72: 75 06                        dw      CHAR_PLUS
  2043 00:0F74: 20 10                        dw      S_EQUAL
  2044 00:0F76: 80 07                        dw      DUP
  2045 00:0F78: 30 12 84 0F                  dw      QUERY_BRANCH,FIND2
  2046 00:0F7C: 6F 07                        dw      DROP
  2047 00:0F7E: B6 0F                        dw      NFA_TO_LFA
  2048 00:0F80: B4 05                        dw      FETCH
  2049 00:0F82: 80 07                        dw      DUP
  2050 00:0F84: 32 0B        FIND2:          dw      ZERO_EQUAL
  2051 00:0F86: 30 12 6C 0F                  dw      QUERY_BRANCH,FIND1
  2052 00:0F8A: 80 07                        dw      DUP
  2053 00:0F8C: 30 12 A2 0F                  dw      QUERY_BRANCH,FIND3
  2054 00:0F90: 95 07                        dw      NIP
  2055 00:0F92: 80 07                        dw      DUP
  2056 00:0F94: AD 0F                        dw      NFA_TO_CFA
  2057 00:0F96: EE 07                        dw      SWAP
  2058 00:0F98: A4 0F                        dw      IMMED_QUERY
  2059 00:0F9A: 32 0B                        dw      ZERO_EQUAL
  2060 00:0F9C: 67 13 01 00                  dw      DO_LITERAL,1
  2061 00:0FA0: 43 0C                        dw      OR
  2062 00:0FA2: 02 0D        FIND3:          dw      EXIT
  2063                        
  2064                        ; IMMED? ( nfa -- f )
  2065                        
  2066                        ;               HEADER  6,"IMMED?",NORMAL
  2067 00:0FA4: 20 87 12     IMMED_QUERY:    jsr     DO_COLON
  2068 00:0FA7: 3C 09                        dw      ONE_MINUS
  2069 00:0FA9: 07 06                        dw      C_FETCH
  2070 00:0FAB: 02 0D                        dw      EXIT
  2071                        
  2072                        ; NFA>CFA ( nfa -- cfa )
  2073                        
  2074                        ;               HEADER  7,"NFA>CFA",NORMAL
  2075 00:0FAD: 20 87 12     NFA_TO_CFA:     jsr     DO_COLON
  2076 00:0FB0: DF 11                        dw      COUNT
  2077 00:0FB2: E5 08                        dw      PLUS
  2078 00:0FB4: 02 0D                        dw      EXIT
  2079                        
  2080                        ; NFA>LFA ( nfa -- lfa )
  2081                        
  2082                        ;               HEADER  7,"NFA>LFA",NORMAL
  2083 00:0FB6: 20 87 12     NFA_TO_LFA:     jsr     DO_COLON
  2084 00:0FB9: 67 13 03 00                  dw      DO_LITERAL,3
  2085 00:0FBD: FB 08                        dw      MINUS
  2086 00:0FBF: 02 0D                        dw      EXIT
  2087                        
  2088                        ; REFILL ( -- flag )
  2089                        ;
  2090                        ; Attempt to fill the input buffer from the input source, returning a true flag
  2091                        ; if successful.
  2092                        ;
  2093                        ; When the input source is the user input device, attempt to receive input into
  2094                        ; the terminal input buffer. If successful, make the result the input buffer,
  2095                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  2096                        ; is considered successful. If there is no input available from the current
  2097                        ; input source, return false.
  Mon Apr 18 2016 15:06                                                                                                    Page 43


  2098                        ;
  2099                        ; When the input source is a string from EVALUATE, return false and perform no
  2100                        ; other action.
  2101                        ;
  2102                        ; In this implementation it is defined as:
  2103                        ;
  2104                        ;   SOURCE-ID 0= IF
  2105                        ;     TIB DUP #TIB @ ACCEPT SPACE
  2106                        ;     LENGTH ! BUFFER !
  2107                        ;     0 >IN ! TRUE EXIT
  2108                        ;   THEN
  2109                        ;   FALSE
  2110                        
  2111 00:0FC1: 60 0F 00 06                  HEADER  6,"REFILL",NORMAL
       00:0FC5: 52 45 46 49 
       00:0FC9: 4C 4C 
  2112 00:0FCB: 20 87 12     REFILL:         jsr     DO_COLON
  2113 00:0FCE: BF 10                        dw      SOURCE_ID
  2114 00:0FD0: 32 0B                        dw      ZERO_EQUAL
  2115 00:0FD2: 30 12 F4 0F                  dw      QUERY_BRANCH,REFILL_1
  2116 00:0FD6: BF 04                        dw      TIB
  2117 00:0FD8: 80 07                        dw      DUP
  2118 00:0FDA: 49 04                        dw      HASH_TIB
  2119 00:0FDC: B4 05                        dw      FETCH
  2120 00:0FDE: 1A 0E                        dw      ACCEPT
  2121 00:0FE0: 26 15                        dw      SPACE
  2122 00:0FE2: 94 04                        dw      LENGTH
  2123 00:0FE4: 46 05                        dw      STORE
  2124 00:0FE6: 75 04                        dw      BUFFER
  2125 00:0FE8: 46 05                        dw      STORE
  2126 00:0FEA: C9 04                        dw      ZERO
  2127 00:0FEC: 57 04                        dw      TO_IN
  2128 00:0FEE: 46 05                        dw      STORE
  2129 00:0FF0: 07 05                        dw      TRUE
  2130 00:0FF2: 02 0D                        dw      EXIT
  2131 00:0FF4: F3 04        REFILL_1:       dw      FALSE
  2132 00:0FF6: 02 0D                        dw      EXIT
  2133                        
  2134                        ; RESTORE-INPUT ( xn ... x1 n -- flag )
  2135                        ;
  2136                        ; Attempt to restore the input source specification to the state described by
  2137                        ; x1 through xn. flag is true if the input source specification cannot be so
  2138                        ; restored.
  2139                        ;
  2140                        ; An ambiguous condition exists if the input source represented by the
  2141                        ; arguments is not the same as the current input source.
  2142                        ;
  2143                        ; In this implementation it is defined as:
  2144                        ;
  2145                        ;   >IN ! (LENGTH) ! BUFFER !
  2146                        ;   SOURCEID !
  2147                        ;   TRUE
  2148                        
  2149 00:0FF8: C4 0F 00 0D                  HEADER  13,"RESTORE-INPUT",NORMAL
       00:0FFC: 52 45 53 54 
       00:1000: 4F 52 45 2D 
       00:1004: 49 4E 50 55 
       00:1008: 54 
  Mon Apr 18 2016 15:06                                                                                                    Page 44


  2150 00:1009: 20 87 12     RESTORE_INPUT   jsr     DO_COLON
  2151 00:100C: 57 04                        dw      TO_IN
  2152 00:100E: 46 05                        dw      STORE
  2153 00:1010: 94 04                        dw      LENGTH
  2154 00:1012: 46 05                        dw      STORE
  2155 00:1014: 75 04                        dw      BUFFER
  2156 00:1016: 46 05                        dw      STORE
  2157 00:1018: A5 04                        dw      SOURCEID
  2158 00:101A: 46 05                        dw      STORE
  2159 00:101C: 07 05                        dw      TRUE
  2160 00:101E: 02 0D                        dw      EXIT
  2161                        
  2162                        ; S= ( c-addr1 caddr2 u -- n)
  2163                        ;
  2164                        ; Misnamed, more like C's strncmp. Note that counted length bytes are compared!
  2165                        
  2166                        S_EQUAL:
  2167 00:1020: 5A                           phy
  2168 00:1021: A6 01                        ldx     <1                      ; Fetch maximum length
  2169 00:1023: F0 14                        beq     S_EQUAL_3
  2170 00:1025: A0 00 00                     ldy     #0
  2171 00:1028: E2 20                        short_a
  2172                        S_EQUAL_1:
  2173 00:102A: B1 05                        lda     (5),y                   ; Compare bytes
  2174 00:102C: D1 03                        cmp     (3),y
  2175 00:102E: D0 06                        bne     S_EQUAL_2
  2176 00:1030: C8                           iny
  2177 00:1031: CA                           dex                             ; End of strings?
  2178 00:1032: D0 F6                        bne     S_EQUAL_1               ; No
  2179 00:1034: 80 03                        bra     S_EQUAL_3               ; Yes. must be the same
  2180                        S_EQUAL_2:
  2181 00:1036: A2 FF FF                     ldx     #$ffff                  ; Difference found
  2182                        S_EQUAL_3:
  2183 00:1039: C2 20                        long_a
  2184 00:103B: 7B                           tdc                             ; Clean up the stack
  2185 00:103C: 1A                           inc     a
  2186 00:103D: 1A                           inc     a
  2187 00:103E: 1A                           inc     a
  2188 00:103F: 1A                           inc     a
  2189 00:1040: 5B                           tcd
  2190 00:1041: 86 01                        stx     <1                      ; Save the flag
  2191 00:1043: 7A                           ply
  2192 00:1044: BB C8 C8 7C                  CONTINUE
       00:1048: 00 00 
  2193                        
  2194                        ; SAVE-INPUT ( -- xn ... x1 n )
  2195                        ;
  2196                        ; x1 through xn describe the current state of the input source specification
  2197                        ; for later use by RESTORE-INPUT.
  2198                        
  2199 00:104A: FB 0F 00 0A                  HEADER  10,"SAVE-INPUT",NORMAL
       00:104E: 53 41 56 45 
       00:1052: 2D 49 4E 50 
       00:1056: 55 54 
  2200 00:1058: 20 87 12     SAVE_INPUT:     jsr     DO_COLON
  2201 00:105B: A5 04                        dw      SOURCEID
  2202 00:105D: B4 05                        dw      FETCH
  2203 00:105F: 75 04                        dw      BUFFER
  Mon Apr 18 2016 15:06                                                                                                    Page 45


  2204 00:1061: B4 05                        dw      FETCH
  2205 00:1063: 94 04                        dw      LENGTH
  2206 00:1065: B4 05                        dw      FETCH
  2207 00:1067: 57 04                        dw      TO_IN
  2208 00:1069: B4 05                        dw      FETCH
  2209 00:106B: 02 0D                        dw      EXIT
  2210                        
  2211                        ; SCAN ( c-addr n c == c-addr' n' )
  2212                        
  2213                        SCAN:
  2214                        SCAN_1:
  2215 00:106D: A5 03                        lda     <3                      ; Any data left to scan?
  2216 00:106F: F0 10                        beq     SCAN_2                  ; No.
  2217 00:1071: A5 01                        lda     <1                      ; Fetch and compare with scan
  2218 00:1073: E2 20                        short_a
  2219 00:1075: D2 05                        cmp     (5)
  2220 00:1077: C2 20                        long_a
  2221 00:1079: F0 06                        beq     SCAN_2
  2222 00:107B: E6 05                        inc     <5
  2223 00:107D: C6 03                        dec     <3
  2224 00:107F: 80 EC                        bra     SCAN_1
  2225                        SCAN_2:
  2226 00:1081: 4C 6F 07                     jmp     DROP                    ; Drop the character
  2227                        
  2228                        ; SKIP ( c-addr n c == c-addr' n' )
  2229                        ;
  2230                        
  2231                        SKIP:
  2232 00:1084: A5 03        SKIP_1:         lda     <3                      ; Any data left to skip over?
  2233 00:1086: F0 10                        beq     SKIP_2                  ; No.
  2234 00:1088: A5 01                        lda     <1                      ; Fetch and compare with skip
  2235 00:108A: E2 20                        short_a
  2236 00:108C: D2 05                        cmp     (5)
  2237 00:108E: C2 20                        long_a
  2238 00:1090: D0 06                        bne     SKIP_2                  ; Cannot be skipped
  2239 00:1092: E6 05                        inc     <5                      ; Bump data address
  2240 00:1094: C6 03                        dec     <3                      ; and update length
  2241 00:1096: 80 EC                        bra     SKIP_1                  ; And repeat
  2242                        SKIP_2:
  2243 00:1098: 4C 6F 07                     jmp     DROP                    ; Drop the character
  2244                        
  2245                        ; SOURCE ( -- c-addr u )
  2246                        ;
  2247                        ; c-addr is the address of, and u is the number of characters in, the input
  2248                        ; buffer.
  2249                        ;
  2250                        ; In this implementation it is defined as
  2251                        ;
  2252                        ;   BUFFER @ LENGTH @
  2253                        
  2254 00:109B: 4D 10 00 06                  HEADER  6,"SOURCE",NORMAL
       00:109F: 53 4F 55 52 
       00:10A3: 43 45 
  2255 00:10A5: 20 87 12     SOURCE:         jsr     DO_COLON
  2256 00:10A8: 75 04                        dw      BUFFER
  2257 00:10AA: B4 05                        dw      FETCH
  2258 00:10AC: 94 04                        dw      LENGTH
  2259 00:10AE: B4 05                        dw      FETCH
  Mon Apr 18 2016 15:06                                                                                                    Page 46


  2260 00:10B0: 02 0D                        dw      EXIT
  2261                        
  2262                        ; SOURCE-ID ( -- 0 | -1 )
  2263                        ;
  2264                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  2265                        ; device.
  2266                        
  2267 00:10B2: 9E 10 00 09                  HEADER  9,"SOURCE-ID",NORMAL
       00:10B6: 53 4F 55 52 
       00:10BA: 43 45 2D 49 
       00:10BE: 44 
  2268 00:10BF: 20 87 12     SOURCE_ID:      jsr     DO_COLON
  2269 00:10C2: A5 04                        dw      SOURCEID
  2270 00:10C4: B4 05                        dw      FETCH
  2271 00:10C6: 02 0D                        dw      EXIT
  2272                        
  2273                        ; WORD ( char “<chars>ccc<char>” -- c-addr )
  2274                        ;
  2275                        ; Skip leading delimiters. Parse characters ccc delimited by char. An
  2276                        ; ambiguous condition exists if the length of the parsed string is greater
  2277                        ; than the implementation-defined length of a counted string.
  2278                        ;
  2279                        ; c-addr is the address of a transient region containing the parsed word as
  2280                        ; a counted string. If the parse area was empty or contained no characters
  2281                        ; other than the delimiter, the resulting string has a zero length. A space,
  2282                        ; not included in the length, follows the string. A program may replace
  2283                        ; characters within the string.
  2284                        ;
  2285                        ; In this implementation it is defined as:
  2286                        ;
  2287                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  2288                        ;   DUP >R   ROT SKIP           -- c adr' n'
  2289                        ;   OVER >R  ROT SCAN           -- adr" n"
  2290                        ;   DUP IF CHAR- THEN        skip trailing delim.
  2291                        ;   R> R> ROT -   >IN +!        update >IN offset
  2292                        ;   TUCK -                      -- adr' N
  2293                        ;   HERE >counted               --
  2294                        ;   HERE                        -- a
  2295                        ;   BL OVER COUNT + C! ;    append trailing blank
  2296                        
  2297 00:10C8: B5 10 00 04                  HEADER  4,"WORD",NORMAL
       00:10CC: 57 4F 52 44 
  2298 00:10D0: 20 87 12     WORD:           jsr     DO_COLON
  2299 00:10D3: 80 07                        dw      DUP
  2300 00:10D5: A5 10                        dw      SOURCE
  2301 00:10D7: 57 04                        dw      TO_IN
  2302 00:10D9: B4 05                        dw      FETCH
  2303 00:10DB: 34 11                        dw      SLASH_STRING
  2304 00:10DD: 80 07                        dw      DUP
  2305 00:10DF: 60 08                        dw      TO_R
  2306 00:10E1: D4 07                        dw      ROT
  2307 00:10E3: 84 10                        dw      SKIP
  2308 00:10E5: A3 07                        dw      OVER
  2309 00:10E7: 60 08                        dw      TO_R
  2310 00:10E9: D4 07                        dw      ROT
  2311 00:10EB: 6D 10                        dw      SCAN
  2312 00:10ED: 80 07                        dw      DUP
  2313 00:10EF: 30 12 F5 10                  dw      QUERY_BRANCH,WORD_1
  Mon Apr 18 2016 15:06                                                                                                    Page 47


  2314 00:10F3: 86 06                        dw      CHAR_MINUS
  2315 00:10F5: 99 08        WORD_1:         dw      R_FROM
  2316 00:10F7: 99 08                        dw      R_FROM
  2317 00:10F9: D4 07                        dw      ROT
  2318 00:10FB: FB 08                        dw      MINUS
  2319 00:10FD: 57 04                        dw      TO_IN
  2320 00:10FF: 5C 05                        dw      PLUS_STORE
  2321 00:1101: 04 08                        dw      TUCK
  2322 00:1103: FB 08                        dw      MINUS
  2323 00:1105: 1F 06                        dw      HERE
  2324 00:1107: C1 0D                        dw      TO_COUNTED
  2325 00:1109: 1F 06                        dw      HERE
  2326 00:110B: DB 04                        dw      BL
  2327 00:110D: A3 07                        dw      OVER
  2328 00:110F: DF 11                        dw      COUNT
  2329 00:1111: E5 08                        dw      PLUS
  2330 00:1113: D6 05                        dw      C_STORE
  2331 00:1115: 02 0D                        dw      EXIT
  2332                        
  2333                        ;===============================================================================
  2334                        ; String Words
  2335                        ;-------------------------------------------------------------------------------
  2336                        
  2337                        ; -TRAILING ( c-addr u1 -- c-addr u2 )
  2338                        ;
  2339                        ; If u1 is greater than zero, u2 is equal to u1 less the number of spaces at
  2340                        ; the end of the character string specified by c-addr u1. If u1 is zero or the
  2341                        ; entire string consists of spaces, u2 is zero.
  2342                        
  2343 00:1117: CB 10 00 09                  HEADER  9,"-TRAILING",NORMAL
       00:111B: 2D 54 52 41 
       00:111F: 49 4C 49 4E 
       00:1123: 47 
  2344 00:1124: 20 87 12     DASH_TRAILING:  jsr     DO_COLON
  2345                        ; TODO
  2346 00:1127: 02 0D                        dw      EXIT
  2347                        
  2348                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  2349                        ;
  2350                        ; Adjust the character string at c-addr1 by n characters. The resulting
  2351                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  2352                        ; characters and is u1 minus n characters long.
  2353                        ;
  2354                        ;   ROT OVER + ROT ROT -
  2355                        
  2356 00:1129: 1A 11 00 07                  HEADER  7,"/STRING",NORMAL
       00:112D: 2F 53 54 52 
       00:1131: 49 4E 47 
  2357 00:1134: 20 87 12     SLASH_STRING:   jsr     DO_COLON
  2358 00:1137: D4 07                        dw      ROT
  2359 00:1139: A3 07                        dw      OVER
  2360 00:113B: E5 08                        dw      PLUS
  2361 00:113D: D4 07                        dw      ROT
  2362 00:113F: D4 07                        dw      ROT
  2363 00:1141: FB 08                        dw      MINUS
  2364 00:1143: 02 0D                        dw      EXIT
  2365                        
  2366                        ; BLANK ( c-addr u -- )
  Mon Apr 18 2016 15:06                                                                                                    Page 48


  2367                        ;
  2368                        ; If u is greater than zero, store the character value for space in u
  2369                        ; consecutive character positions beginning at c-addr.
  2370                        ;
  2371                        ; In this implementation it is defined as
  2372                        ;
  2373                        ;   ?DUP IF OVER + SWAP DO BL I C! LOOP ELSE DROP THEN
  2374                        
  2375 00:1145: 2C 11 00 05                  HEADER  5,"BLANK",NORMAL
       00:1149: 42 4C 41 4E 
       00:114D: 4B 
  2376 00:114E: 20 87 12     BLANK:          jsr     DO_COLON
  2377 00:1151: 43 07                        dw      QUERY_DUP
  2378 00:1153: 30 12 6B 11                  dw      QUERY_BRANCH,BLANK_2
  2379 00:1157: A3 07                        dw      OVER
  2380 00:1159: E5 08                        dw      PLUS
  2381 00:115B: EE 07                        dw      SWAP
  2382 00:115D: 07 13                        dw      DO_DO
  2383 00:115F: DB 04        BLANK_1:        dw      BL
  2384 00:1161: 72 08                        dw      I
  2385 00:1163: D6 05                        dw      C_STORE
  2386 00:1165: 8D 13 5F 11                  dw      DO_LOOP,BLANK_1
  2387 00:1169: 02 0D                        dw      EXIT
  2388 00:116B: 6F 07        BLANK_2:        dw      DROP
  2389 00:116D: 02 0D                        dw      EXIT
  2390                        
  2391                        ; CMOVE ( c-addr1 c-addr2 u -- )
  2392                        ;
  2393                        ; If u is greater than zero, copy u consecutive characters from the data space
  2394                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2395                        ; character from lower addresses to higher addresses.
  2396                        
  2397 00:116F: 48 11 00 05                  HEADER  5,"CMOVE",NORMAL
       00:1173: 43 4D 4F 56 
       00:1177: 45 
  2398                        CMOVE:
  2399 00:1178: 5A                           phy
  2400 00:1179: A6 01                        ldx     <1                      ; Any characters to move?
  2401 00:117B: F0 0F                        beq     CMOVE_2                 ; No
  2402 00:117D: A0 00 00                     ldy     #0
  2403 00:1180: E2 20                        short_a
  2404                        CMOVE_1:                                        ; Transfer a byte
  2405 00:1182: B1 05                        lda     (5),y
  2406 00:1184: 91 03                        sta     (3),y
  2407 00:1186: C8                           iny
  2408 00:1187: CA                           dex                             ; Decrement count
  2409 00:1188: D0 F8                        bne     CMOVE_1                 ; .. and repeat until done
  2410 00:118A: C2 20                        long_a
  2411                        CMOVE_2:
  2412 00:118C: 7B                           tdc                             ; Clean up the stack
  2413 00:118D: 18                           clc
  2414 00:118E: 69 06 00                     adc     #6
  2415 00:1191: 5B                           tcd
  2416 00:1192: 7A                           ply
  2417 00:1193: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1197: 00 00 
  2418                        
  2419                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  Mon Apr 18 2016 15:06                                                                                                    Page 49


  2420                        ;
  2421                        ; If u is greater than zero, copy u consecutive characters from the data space
  2422                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  2423                        ; character from higher addresses to lower addresses.
  2424                        
  2425 00:1199: 72 11 00 06                  HEADER  6,"CMOVE>",NORMAL
       00:119D: 43 4D 4F 56 
       00:11A1: 45 3E 
  2426                        CMOVE_GREATER:
  2427 00:11A3: 5A                           phy
  2428 00:11A4: A6 01                        ldx     <1                      ; Any characters to move?
  2429 00:11A6: F0 0E                        beq     CMOVE_GT_2              ; No.
  2430 00:11A8: A4 01                        ldy     <1
  2431 00:11AA: E2 20                        short_a
  2432                        CMOVE_GT_1:
  2433 00:11AC: 88                           dey                             ; Transfer a byte
  2434 00:11AD: B1 05                        lda     (5),y
  2435 00:11AF: 91 03                        sta     (3),y
  2436 00:11B1: CA                           dex                             ; Decrement length
  2437 00:11B2: D0 F8                        bne     CMOVE_GT_1              ; .. and repeat until done
  2438 00:11B4: C2 20                        long_a
  2439                        CMOVE_GT_2:
  2440 00:11B6: 7B                           tdc                             ; Clean up the stack
  2441 00:11B7: 18                           clc
  2442 00:11B8: 69 06 00                     adc     #6
  2443 00:11BB: 5B                           tcd
  2444 00:11BC: BB C8 C8 7C                  CONTINUE                        ; Done
       00:11C0: 00 00 
  2445                        
  2446                        ; COMPARE ( c-addr1 u1 c-addr2 u2 -- n )
  2447                        ;
  2448                        ; Compare the string specified by c-addr1 u1 to the string specified by c-addr2
  2449                        ; u2. The strings are compared, beginning at the given addresses, character by
  2450                        ; character, up to the length of the shorter string or until a difference is
  2451                        ; found. If the two strings are identical, n is zero. If the two strings are
  2452                        ; identical up to the length of the shorter string, n is minus-one (-1) if u1
  2453                        ; is less than u2 and one (1) otherwise. If the two strings are not identical
  2454                        ; up to the length of the shorter string, n is minus-one (-1) if the first
  2455                        ; non-matching character in the string specified by c-addr1 u1 has a lesser
  2456                        ; numeric value than the corresponding character in the string specified by
  2457                        ; c-addr2 u2 and one (1) otherwise.
  2458                        
  2459 00:11C2: 9C 11 00 07                  HEADER  7,"COMPARE",NORMAL
       00:11C6: 43 4F 4D 50 
       00:11CA: 41 52 45 
  2460 00:11CD: 20 87 12     COMPARE:        jsr     DO_COLON
  2461                        ; TODO
  2462 00:11D0: BB C8 C8 7C                  CONTINUE
       00:11D4: 00 00 
  2463                        
  2464                        ; COUNT ( c-addr1 -- c-addr2 u )
  2465                        ;
  2466                        ; Return the character string specification for the counted string stored at
  2467                        ; c-addr1. c-addr2 is the address of the first character after c-addr1. u is
  2468                        ; the contents of the character at c-addr1, which is the length in characters
  2469                        ; of the string at c-addr2.
  2470                        ;
  2471                        ; In this implementation it is defined as
  Mon Apr 18 2016 15:06                                                                                                    Page 50


  2472                        ;
  2473                        ;   DUP CHAR+ SWAP C@
  2474                        
  2475 00:11D6: C5 11 00 05                  HEADER  5,"COUNT",NORMAL
       00:11DA: 43 4F 55 4E 
       00:11DE: 54 
  2476 00:11DF: 20 87 12     COUNT:          jsr     DO_COLON
  2477 00:11E2: 80 07                        dw      DUP
  2478 00:11E4: 75 06                        dw      CHAR_PLUS
  2479 00:11E6: EE 07                        dw      SWAP
  2480 00:11E8: 07 06                        dw      C_FETCH
  2481 00:11EA: 02 0D                        dw      EXIT
  2482                        
  2483                        ; SEARCH ( c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag )
  2484                        ;
  2485                        ; Search the string specified by c-addr1 u1 for the string specified by c-addr2
  2486                        ; u2. If flag is true, a match was found at c-addr3 with u3 characters
  2487                        ; remaining. If flag is false there was no match and c-addr3 is c-addr1 and u3
  2488                        ; is u1.
  2489                        
  2490 00:11EC: D9 11 00 06                  HEADER  6,"SEARCH",NORMAL
       00:11F0: 53 45 41 52 
       00:11F4: 43 48 
  2491 00:11F6: 20 87 12     SEARCH:         jsr     DO_COLON
  2492                        ; TODO
  2493 00:11F9: BB C8 C8 7C                  CONTINUE
       00:11FD: 00 00 
  2494                        
  2495                        ;===============================================================================
  2496                        ; Compiling Words
  2497                        ;-------------------------------------------------------------------------------
  2498                        
  2499                        ; ( ( -- )
  2500                        ;
  2501                        ; Parse ccc delimited by ) (right parenthesis). ( is an immediate word.
  2502                        ;
  2503                        ; The number of characters in ccc may be zero to the number of characters in the
  2504                        ; parse area.
  2505                        ;
  2506                        ; In this implementation it is defined as:
  2507                        ;
  2508                        ;  [ HEX ] 29 WORD DROP ; IMMEDIATE
  2509                        
  2510 00:11FF: EF 11 80 01                  HEADER  1,"(",IMMEDIATE
       00:1203: 28 
  2511 00:1204: 20 87 12                     jsr     DO_COLON
  2512 00:1207: 67 13 29 00                  dw      DO_LITERAL,')'
  2513 00:120B: D0 10                        dw      WORD
  2514 00:120D: 6F 07                        dw      DROP
  2515 00:120F: 02 0D                        dw      EXIT
  2516                        
  2517                        ; .(
  2518                        
  2519 00:1211: 02 12 80 02  		HEADER	2,".(",IMMEDIATE
       00:1215: 2E 28 
  2520 00:1217: 20 87 12     DOT_PAREN:	jsr	DO_COLON
  2521 00:121A: 67 13 29 00  		dw	DO_LITERAL,')'
  2522 00:121E: D0 10        		dw	WORD
  Mon Apr 18 2016 15:06                                                                                                    Page 51


  2523 00:1220: DF 11        		dw	COUNT
  2524 00:1222: 58 15        		dw	TYPE
  2525 00:1224: 02 0D        		dw	EXIT
  2526                        
  2527                        ; (BRANCH) ( -- )
  2528                        ;
  2529                        ; Cause the IP to be loaded with the word following the link to this word.
  2530                        
  2531                        ;               HEADER  8,"(BRANCH)",NORMAL
  2532                        BRANCH:
  2533 00:1226: B9 00 00                     lda     !0,y                    ; Load branch address into IP
  2534 00:1229: A8                           tay
  2535 00:122A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:122E: 00 00 
  2536                        
  2537                        ; (?BRANCH) ( flag -- )
  2538                        ;
  2539                        ; If flag is false then cause the IP to be loaded with the word following the
  2540                        ; link to this word, otherwise skip over it.
  2541                        
  2542                        ;               HEADER  9,"(?BRANCH)",NORMAL
  2543                        QUERY_BRANCH:
  2544 00:1230: A6 01                        ldx     <1                      ; Pull the top of stack value
  2545 00:1232: 7B                           tdc
  2546 00:1233: 1A                           inc     a                       ; Drop top item
  2547 00:1234: 1A                           inc     a
  2548 00:1235: 5B                           tcd
  2549 00:1236: 8A                           txa
  2550 00:1237: F0 ED                        beq     BRANCH                  ; Branch if top was zero
  2551 00:1239: C8                           iny                             ; Otherwise skip address
  2552 00:123A: C8                           iny
  2553 00:123B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:123F: 00 00 
  2554                        
  2555                        ; +LOOP ( -- )
  2556                        
  2557 00:1241: 14 12 80 05                  HEADER  5,"+LOOP",IMMEDIATE
       00:1245: 2B 4C 4F 4F 
       00:1249: 50 
  2558 00:124A: 20 87 12     PLUS_LOOP:      jsr     DO_COLON
  2559                        
  2560 00:124D: 02 0D                        dw      EXIT
  2561                        
  2562                        ; (+LOOP)
  2563                        
  2564                        ;               HEADER  7,"(+LOOP)",NORMAL
  2565                        DO_PLUS_LOOP:
  2566 00:124F: A6 01        		ldx	<1			; Fetch increment
  2567 00:1251: 7B           		tdc				; And drop
  2568 00:1252: 1A           		inc	a
  2569 00:1253: 1A           		inc	a
  2570 00:1254: 5B           		tcd
  2571 00:1255: 18           		clc				; Add to loop counter
  2572 00:1256: 8A           		txa
  2573 00:1257: 63 01                        adc     1,s
  2574 00:1259: 83 01                        sta     1,s
  2575 00:125B: C3 03                        cmp     3,s                     ; Reached limit?
  2576 00:125D: B0 0A                        bcs     DO_PLOOP_END            ; Yes
  Mon Apr 18 2016 15:06                                                                                                    Page 52


  2577 00:125F: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2578 00:1262: A8                           tay
  2579 00:1263: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1267: 00 00 
  2580                        
  2581 00:1269: C8           DO_PLOOP_END:   iny                             ; Skip over address
  2582 00:126A: C8                           iny
  2583 00:126B: 68                           pla                             ; Drop loop variables
  2584 00:126C: 68                           pla
  2585 00:126D: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1271: 00 00 
  2586                        
  2587                        ; : ( -- )
  2588                        
  2589 00:1273: 44 12 00 01                  HEADER  1,":",NORMAL
       00:1277: 3A 
  2590 00:1278: 20 87 12     COLON:          jsr     DO_COLON
  2591 00:127B: C7 0C                        dw      CREATE
  2592 00:127D: 67 13 87 12                  dw      DO_LITERAL,DO_COLON
  2593 00:1281: B0 0C                        dw      BUILD
  2594 00:1283: C8 14                        dw      RIGHT_BRACKET
  2595 00:1285: 02 0D                        dw      EXIT
  2596                        
  2597                        DO_COLON:
  2598 00:1287: FA                           plx                             ; Pull new word IP-1
  2599 00:1288: 5A                           phy                             ; Save the old IP
  2600 00:1289: E8                           inx                             ; Work out new IP
  2601 00:128A: 9B                           txy
  2602 00:128B: BB C8 C8 7C                  CONTINUE                        ; Done
       00:128F: 00 00 
  2603                        
  2604                        ; ; ( -- )
  2605                        
  2606 00:1291: 76 12 80                     LINK    IMMEDIATE
  2607 00:1294: 01 3B                        db      1,";"
  2608 00:1296: 20 87 12     SEMICOLON:      jsr     DO_COLON
  2609 00:1299: 67 13 02 0D                  dw      DO_LITERAL,EXIT
  2610 00:129D: 74 05                        dw      COMMA
  2611 00:129F: A6 14                        dw      LEFT_BRACKET
  2612 00:12A1: 02 0D                        dw      EXIT
  2613                        
  2614                        ; AGAIN ( -- )
  2615                        
  2616 00:12A3: 94 12 80 05                  HEADER  5,"AGAIN",IMMEDIATE
       00:12A7: 41 47 41 49 
       00:12AB: 4E 
  2617 00:12AC: 20 87 12     AGAIN:          jsr     DO_COLON
  2618 00:12AF: 67 13 26 12                  dw      DO_LITERAL,BRANCH
  2619 00:12B3: 74 05                        dw      COMMA
  2620 00:12B5: 74 05                        dw      COMMA
  2621 00:12B7: 02 0D                        dw      EXIT
  2622                        
  2623                        ; BEGIN ( -- )
  2624                        
  2625 00:12B9: A6 12 80 05                  HEADER  5,"BEGIN",IMMEDIATE
       00:12BD: 42 45 47 49 
       00:12C1: 4E 
  2626 00:12C2: 20 87 12     BEGIN:          jsr     DO_COLON
  Mon Apr 18 2016 15:06                                                                                                    Page 53


  2627 00:12C5: 1F 06                        dw      HERE
  2628 00:12C7: 02 0D                        dw      EXIT
  2629                        
  2630                        ; CONSTANT ( x “<spaces>name” -- )
  2631                        ;
  2632                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2633                        ; definition for name with the execution semantics defined below.
  2634                        
  2635 00:12C9: BC 12 00 08                  HEADER  8,"CONSTANT",NORMAL
       00:12CD: 43 4F 4E 53 
       00:12D1: 54 41 4E 54 
  2636 00:12D5: 20 87 12     CONSTANT:       jsr     DO_COLON
  2637 00:12D8: C7 0C                        dw      CREATE
  2638 00:12DA: 67 13 E4 12                  dw      DO_LITERAL,DO_CONSTANT
  2639 00:12DE: B0 0C                        dw      BUILD
  2640 00:12E0: 74 05                        dw      COMMA
  2641 00:12E2: 02 0D                        dw      EXIT
  2642                        
  2643                        ; (CONSTANT) ( -- x )
  2644                        
  2645                        ;               HEADER  10,"(CONSTANT)",NORMAL
  2646                        DO_CONSTANT:
  2647 00:12E4: FA                           plx
  2648 00:12E5: 7B                           tdc
  2649 00:12E6: 3A                           dec     a
  2650 00:12E7: 3A                           dec     a
  2651 00:12E8: 5B                           tcd
  2652 00:12E9: BD 01 00                     lda     !1,x
  2653 00:12EC: 85 01                        sta     <1
  2654 00:12EE: BB C8 C8 7C                  CONTINUE                        ; Done
       00:12F2: 00 00 
  2655                        
  2656                        ; DO ( -- )
  2657                        
  2658 00:12F4: CC 12 80 02                  HEADER  2,"DO",IMMEDIATE
       00:12F8: 44 4F 
  2659 00:12FA: 20 87 12     DO:             jsr     DO_COLON
  2660 00:12FD: 67 13 07 13                  dw      DO_LITERAL,DO_DO
  2661 00:1301: 74 05                        dw      COMMA
  2662 00:1303: 1F 06                        dw      HERE
  2663 00:1305: 02 0D                        dw      EXIT
  2664                        
  2665                        ; (DO) ( -- )
  2666                        
  2667                        ;               HEADER  4,"(DO)",NORMAL
  2668                        DO_DO:
  2669 00:1307: A5 03                        lda     <3
  2670 00:1309: 48                           pha
  2671 00:130A: A5 01                        lda     <1
  2672 00:130C: 48                           pha
  2673 00:130D: 7B                           tdc
  2674 00:130E: 1A                           inc     a
  2675 00:130F: 1A                           inc     a
  2676 00:1310: 1A                           inc     a
  2677 00:1311: 1A                           inc     a
  2678 00:1312: 5B                           tcd
  2679 00:1313: BB C8 C8 7C                  CONTINUE
       00:1317: 00 00 
  Mon Apr 18 2016 15:06                                                                                                    Page 54


  2680                        
  2681                        ; ELSE ( -- )
  2682                        
  2683 00:1319: F7 12 80 04                  HEADER  4,"ELSE",IMMEDIATE
       00:131D: 45 4C 53 45 
  2684 00:1321: 20 87 12     ELSE:           jsr     DO_COLON
  2685 00:1324: 67 13 26 12                  dw      DO_LITERAL,BRANCH
  2686 00:1328: 74 05                        dw      COMMA
  2687 00:132A: 1F 06                        dw      HERE
  2688 00:132C: C9 04                        dw      ZERO
  2689 00:132E: 74 05                        dw      COMMA
  2690 00:1330: 1F 06                        dw      HERE
  2691 00:1332: EE 07                        dw      SWAP
  2692 00:1334: 46 05                        dw      STORE
  2693 00:1336: 02 0D                        dw      EXIT
  2694                        
  2695                        ; IF ( -- )
  2696                        
  2697 00:1338: 1C 13 80 02                  HEADER  2,"IF",IMMEDIATE
       00:133C: 49 46 
  2698 00:133E: 20 87 12     IF:             jsr     DO_COLON
  2699 00:1341: 67 13 30 12                  dw      DO_LITERAL,QUERY_BRANCH
  2700 00:1345: 74 05                        dw      COMMA
  2701 00:1347: 1F 06                        dw      HERE
  2702 00:1349: C9 04                        dw      ZERO
  2703 00:134B: 74 05                        dw      COMMA
  2704 00:134D: 02 0D                        dw      EXIT
  2705                        
  2706                        ; LITERAL ( x -- )
  2707                        ;
  2708                        ; Append the run-time semantics given below to the current definition.
  2709                        
  2710 00:134F: 3B 13 80 07                  HEADER  7,"LITERAL",IMMEDIATE
       00:1353: 4C 49 54 45 
       00:1357: 52 41 4C 
  2711 00:135A: 20 87 12     LITERAL:        jsr     DO_COLON
  2712 00:135D: 67 13 67 13                  dw      DO_LITERAL,DO_LITERAL
  2713 00:1361: 74 05                        dw      COMMA
  2714 00:1363: 74 05                        dw      COMMA
  2715 00:1365: 02 0D                        dw      EXIT
  2716                        
  2717                        ; (LITERAL) ( -- x )
  2718                        ;
  2719                        ; Place x on the stack.
  2720                        
  2721                        ;               HEADER  9,"(LITERAL)",NORMAL
  2722                        DO_LITERAL:
  2723 00:1367: 7B                           tdc
  2724 00:1368: 3A                           dec     a
  2725 00:1369: 3A                           dec     a
  2726 00:136A: 5B                           tcd
  2727 00:136B: B9 00 00                     lda     !0,y                    ; Fetch constant from IP
  2728 00:136E: C8                           iny
  2729 00:136F: C8                           iny
  2730 00:1370: 85 01                        sta     <1
  2731 00:1372: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1376: 00 00 
  2732                        
  Mon Apr 18 2016 15:06                                                                                                    Page 55


  2733                        ; LOOP
  2734                        
  2735 00:1378: 52 13 80 04                  HEADER  4,"LOOP",IMMEDIATE
       00:137C: 4C 4F 4F 50 
  2736 00:1380: 20 87 12     LOOP:           jsr     DO_COLON
  2737 00:1383: 67 13 8D 13                  dw      DO_LITERAL,DO_LOOP
  2738 00:1387: 74 05                        dw      COMMA
  2739 00:1389: 74 05                        dw      COMMA
  2740 00:138B: 02 0D                        dw      EXIT
  2741                        
  2742                        ; (LOOP)
  2743                        
  2744                        ;               HEADER  6,"(LOOP)",NORMAL
  2745                        DO_LOOP
  2746 00:138D: A3 01                        lda     1,s                     ; Add one to loop counter
  2747 00:138F: 1A                           inc     a
  2748 00:1390: 83 01                        sta     1,s
  2749 00:1392: C3 03                        cmp     3,s                     ; Reached limit?
  2750 00:1394: B0 0A                        bcs     DO_LOOP_END             ; Yes
  2751 00:1396: B9 00 00                     lda     !0,y                    ; No, branch back to start
  2752 00:1399: A8                           tay
  2753 00:139A: BB C8 C8 7C                  CONTINUE                        ; Done
       00:139E: 00 00 
  2754                        
  2755 00:13A0: C8           DO_LOOP_END:    iny                             ; Skip over address
  2756 00:13A1: C8                           iny
  2757 00:13A2: 68                           pla                             ; Drop loop variables
  2758 00:13A3: 68                           pla
  2759 00:13A4: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13A8: 00 00 
  2760                        
  2761                        ; RECURSE ( -- )
  2762                        
  2763 00:13AA: 7B 13 80 07                  HEADER  7,"RECURSE",IMMEDIATE
       00:13AE: 52 45 43 55 
       00:13B2: 52 53 45 
  2764 00:13B5: 20 87 12     RECURSE:        jsr     DO_COLON
  2765 00:13B8: 8F 04                        dw      LATEST
  2766 00:13BA: B4 05                        dw      FETCH
  2767 00:13BC: AD 0F                        dw      NFA_TO_CFA
  2768 00:13BE: 74 05                        dw      COMMA
  2769 00:13C0: 02 0D                        dw      EXIT
  2770                        
  2771                        ; S"
  2772                        
  2773 00:13C2: AD 13 80                     LINK    IMMEDIATE
  2774 00:13C5: 02 53 22                     db      2,"S",'"'
  2775 00:13C8: 20 87 12     S_QUOTE:        jsr     DO_COLON
  2776 00:13CB: 02 0D                        dw      EXIT
  2777                        
  2778                        ; (S") ( -- c-addr u )
  2779                        
  2780                        DO_S_QUOTE:
  2781 00:13CD: 7B                           tdc
  2782 00:13CE: 3A                           dec     a                       ; Reserve space for values
  2783 00:13CF: 3A                           dec     a
  2784 00:13D0: 3A                           dec     a
  2785 00:13D1: 3A                           dec     a
  Mon Apr 18 2016 15:06                                                                                                    Page 56


  2786 00:13D2: 5B                           tcd
  2787 00:13D3: E2 20                        short_a
  2788 00:13D5: B9 00 00                     lda     !0,y                    ; Fetch the length
  2789 00:13D8: 85 01                        sta     <1
  2790 00:13DA: 64 02                        stz     <2
  2791 00:13DC: C2 20                        long_a
  2792 00:13DE: C8                           iny
  2793 00:13DF: 98                           tya                             ; Save the text address
  2794 00:13E0: 85 03                        sta     <3
  2795 00:13E2: 18                           clc                             ; And update IP
  2796 00:13E3: 65 01                        adc     <1
  2797 00:13E5: A8                           tay
  2798 00:13E6: BB C8 C8 7C                  CONTINUE                        ; Done
       00:13EA: 00 00 
  2799                        
  2800                        ; THEN ( -- )
  2801                        
  2802 00:13EC: C5 13 80 04                  HEADER  4,"THEN",IMMEDIATE
       00:13F0: 54 48 45 4E 
  2803 00:13F4: 20 87 12     THEN:           jsr     DO_COLON
  2804 00:13F7: 1F 06                        dw      HERE
  2805 00:13F9: EE 07                        dw      SWAP
  2806 00:13FB: 46 05                        dw      STORE
  2807 00:13FD: 02 0D                        dw      EXIT
  2808                        
  2809                        ; UNTIL ( -- )
  2810                        
  2811 00:13FF: EF 13 80 05                  HEADER  5,"UNTIL",IMMEDIATE
       00:1403: 55 4E 54 49 
       00:1407: 4C 
  2812 00:1408: 20 87 12     UNTIL:          jsr     DO_COLON
  2813 00:140B: 67 13 30 12                  dw      DO_LITERAL,QUERY_BRANCH
  2814 00:140F: 74 05                        dw      COMMA
  2815 00:1411: 74 05                        dw      COMMA
  2816 00:1413: 02 0D                        dw      EXIT
  2817                        
  2818                        ; USER
  2819                        
  2820 00:1415: 02 14 00 04                  HEADER  4,"USER",NORMAL
       00:1419: 55 53 45 52 
  2821 00:141D: 20 87 12     USER:           jsr     DO_COLON
  2822 00:1420: C7 0C                        dw      CREATE
  2823 00:1422: 67 13 36 14                  dw      DO_LITERAL,DO_USER
  2824 00:1426: B0 0C                        dw      BUILD
  2825 00:1428: 74 05                        dw      COMMA
  2826 00:142A: 02 0D                        dw      EXIT
  2827                        
  2828 00:142C: 18 14 00 06                  HEADER  6,"(USER)",NORMAL
       00:1430: 28 55 53 45 
       00:1434: 52 29 
  2829                        DO_USER:
  2830 00:1436: 7B                           tdc
  2831 00:1437: 3A                           dec     a                       ; Push on data stack
  2832 00:1438: 3A                           dec     a
  2833 00:1439: 5B                           tcd
  2834 00:143A: FA                           plx
  2835 00:143B: 18                           clc
  2836 00:143C: BD 01 00                     lda     !1,x
  Mon Apr 18 2016 15:06                                                                                                    Page 57


  2837 00:143F: 69 00 00                     adc     #USER_AREA
  2838 00:1442: 85 01                        sta     <1
  2839 00:1444: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1448: 00 00 
  2840                        
  2841                        ; VARIABLE ( “<spaces>name” -- )
  2842                        ;
  2843                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  2844                        ; definition for name with the execution semantics defined below. Reserve one
  2845                        ; cell of data space at an aligned address.
  2846                        
  2847 00:144A: 2F 14 00                     LINK    NORMAL
  2848 00:144D: 08 56 41 52                  db      8,"VARIABLE"
       00:1451: 49 41 42 4C 
       00:1455: 45 
  2849 00:1456: 20 87 12     VARIABLE:       jsr     DO_COLON
  2850 00:1459: C7 0C                        dw      CREATE
  2851 00:145B: 67 13 6B 14                  dw      DO_LITERAL,DO_VARIABLE
  2852 00:145F: B0 0C                        dw      BUILD
  2853 00:1461: 67 13 01 00                  dw      DO_LITERAL,1
  2854 00:1465: 64 06                        dw      CELLS
  2855 00:1467: C7 05                        dw      ALLOT
  2856 00:1469: 02 0D                        dw      EXIT
  2857                        
  2858                        DO_VARIABLE:
  2859 00:146B: 7B                           tdc
  2860 00:146C: 3A                           dec     a
  2861 00:146D: 3A                           dec     a
  2862 00:146E: 5B                           tcd
  2863 00:146F: 68                           pla
  2864 00:1470: 1A                           inc     a
  2865 00:1471: 85 01                        sta     <1
  2866 00:1473: BB C8 C8 7C                  CONTINUE
       00:1477: 00 00 
  2867                        
  2868                        ; WORDS ( -- )
  2869                        ;
  2870                        ;   LATEST @ BEGIN
  2871                        ;       DUP COUNT TYPE SPACE
  2872                        ;       NFA>LFA @
  2873                        ;   DUP 0= UNTIL
  2874                        ;   DROP ;
  2875                        
  2876 00:1479: 4D 14 00 05                  HEADER  5,"WORDS",NORMAL
       00:147D: 57 4F 52 44 
       00:1481: 53 
  2877 00:1482: 20 87 12                     jsr     DO_COLON
  2878 00:1485: 8F 04                        dw      LATEST
  2879 00:1487: B4 05                        dw      FETCH
  2880 00:1489: 80 07        WORDS_1:        dw      DUP
  2881 00:148B: DF 11                        dw      COUNT
  2882 00:148D: 58 15                        dw      TYPE
  2883 00:148F: 26 15                        dw      SPACE
  2884 00:1491: B6 0F                        dw      NFA_TO_LFA
  2885 00:1493: B4 05                        dw      FETCH
  2886 00:1495: 80 07                        dw      DUP
  2887 00:1497: 32 0B                        dw      ZERO_EQUAL
  2888 00:1499: 30 12 89 14                  dw      QUERY_BRANCH,WORDS_1
  Mon Apr 18 2016 15:06                                                                                                    Page 58


  2889 00:149D: 6F 07                        dw      DROP
  2890 00:149F: 02 0D                        dw      EXIT
  2891                        
  2892                        ; [
  2893                        ;
  2894                        ; In this implementation it is defined as
  2895                        ;
  2896                        ;   0 STATE !
  2897                        
  2898 00:14A1: 7C 14 80 01                  HEADER  1,"[",IMMEDIATE
       00:14A5: 5B 
  2899 00:14A6: 20 87 12     LEFT_BRACKET:   jsr     DO_COLON
  2900 00:14A9: C9 04                        dw      ZERO
  2901 00:14AB: B3 04                        dw      STATE
  2902 00:14AD: 46 05                        dw      STORE
  2903 00:14AF: 02 0D                        dw      EXIT
  2904                        
  2905                        ; \ ( -- )
  2906                        ;
  2907                        ; Parse and discard the remainder of the parse area. \ is an immediate word.
  2908                        ;
  2909                        ; In this implementation it is defined as
  2910                        ;
  2911                        ;   1 WORD DROP
  2912                        
  2913 00:14B1: A4 14 80 01  		HEADER	1,"\",IMMEDIATE
       00:14B5: 5C 
  2914 00:14B6: 20 87 12     BACKSLASH:	jsr	DO_COLON
  2915 00:14B9: 67 13 01 00  		dw	DO_LITERAL,1
  2916 00:14BD: D0 10        		dw	WORD
  2917 00:14BF: 6F 07        		dw	DROP
  2918 00:14C1: 02 0D        		dw	EXIT
  2919                        		
  2920                        ; ]
  2921                        ;
  2922                        ; In this implementation it is defined as
  2923                        ;
  2924                        ;   -1 STATE !
  2925                        
  2926 00:14C3: B4 14 00 01                  HEADER  1,"]",NORMAL
       00:14C7: 5D 
  2927 00:14C8: 20 87 12     RIGHT_BRACKET:  jsr     DO_COLON
  2928 00:14CB: 67 13 FF FF                  dw      DO_LITERAL,-1
  2929 00:14CF: B3 04                        dw      STATE
  2930 00:14D1: 46 05                        dw      STORE
  2931 00:14D3: 02 0D                        dw      EXIT
  2932                        
  2933                        ;===============================================================================
  2934                        ; I/O Operations
  2935                        ;-------------------------------------------------------------------------------
  2936                        
  2937                        ; CR ( -- )
  2938                        ;
  2939                        ; Cause subsequent output to appear at the beginning of the next line.
  2940                        ;
  2941                        ; In this implementation it is defined as
  2942                        ;
  2943                        ;   13 EMIT 10 EMIT
  Mon Apr 18 2016 15:06                                                                                                    Page 59


  2944                        
  2945 00:14D5: C6 14 00 02                  HEADER  2,"CR",NORMAL
       00:14D9: 43 52 
  2946 00:14DB: 20 87 12     CR:             jsr     DO_COLON
  2947 00:14DE: 67 13 0D 00                  dw      DO_LITERAL,13
  2948 00:14E2: F4 14                        dw      EMIT
  2949 00:14E4: 67 13 0A 00                  dw      DO_LITERAL,10
  2950 00:14E8: F4 14                        dw      EMIT
  2951 00:14EA: 02 0D                        dw      EXIT
  2952                        
  2953                        ; EMIT ( x -- )
  2954                        ;
  2955                        ; If x is a graphic character in the implementation-defined character set,
  2956                        ; display x. The effect of EMIT for all other values of x is implementation
  2957                        ; -defined.
  2958                        
  2959 00:14EC: D8 14 00 04                  HEADER  4,"EMIT",NORMAL
       00:14F0: 45 4D 49 54 
  2960                                        extern  UartTx
  2961                        EMIT:
  2962 00:14F4: A5 01                        lda     <1                      ; Fetch character from stack
  2963 00:14F6: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  2964 00:14F9: 7B                           tdc
  2965 00:14FA: 1A                           inc     a                       ; Drop the character
  2966 00:14FB: 1A                           inc     a
  2967 00:14FC: 5B                           tcd
  2968 00:14FD: BB C8 C8 7C                  CONTINUE                        ; Done
       00:1501: 00 00 
  2969                        
  2970                        ; KEY ( -- char )
  2971                        ;
  2972                        ; Receive one character char, a member of the implementation-defined character
  2973                        ; set. Keyboard events that do not correspond to such characters are discarded
  2974                        ; until a valid character is received, and those events are subsequently
  2975                        ; unavailable.
  2976                        ;
  2977                        ; All standard characters can be received. Characters received by KEY are not
  2978                        ; displayed.
  2979                        
  2980 00:1503: EF 14 00 03                  HEADER  3,"KEY",NORMAL
       00:1507: 4B 45 59 
  2981                                        extern  UartRx
  2982                        KEY:
  2983 00:150A: 20 xx xx                     jsr     UartRx                  ; Receive a character
  2984 00:150D: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  2985 00:1510: AA                           tax
  2986 00:1511: 7B                           tdc
  2987 00:1512: 3A                           dec     a                       ; And push to stack
  2988 00:1513: 3A                           dec     a
  2989 00:1514: 5B                           tcd
  2990 00:1515: 86 01                        stx     <1
  2991 00:1517: BB C8 C8 7C                  CONTINUE                        ; Done
       00:151B: 00 00 
  2992                        
  2993                        ; SPACE ( -- )
  2994                        ;
  2995                        ; Display one space.
  2996                        ;
  Mon Apr 18 2016 15:06                                                                                                    Page 60


  2997                        ; In this implementation it is defined as
  2998                        ;
  2999                        ;   BL EMIT
  3000                        
  3001 00:151D: 06 15 00 05                  HEADER  5,"SPACE",NORMAL
       00:1521: 53 50 41 43 
       00:1525: 45 
  3002 00:1526: 20 87 12     SPACE:          jsr     DO_COLON
  3003 00:1529: DB 04                        dw      BL
  3004 00:152B: F4 14                        dw      EMIT
  3005 00:152D: 02 0D                        dw      EXIT
  3006                        
  3007                        ; SPACES ( n -- )
  3008                        ;
  3009                        ; If n is greater than zero, display n spaces.
  3010                        ;
  3011                        ; In this implementation it is defined as
  3012                        ;
  3013                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  3014                        
  3015 00:152F: 20 15 00 06                  HEADER  6,"SPACES",NORMAL
       00:1533: 53 50 41 43 
       00:1537: 45 53 
  3016 00:1539: 20 87 12     SPACES:         jsr     DO_COLON
  3017 00:153C: 80 07        SPACES_1:       dw      DUP
  3018 00:153E: 46 0B                        dw      ZERO_GREATER
  3019 00:1540: 30 12 4C 15                  dw      QUERY_BRANCH,SPACES_2
  3020 00:1544: 26 15                        dw      SPACE
  3021 00:1546: 3C 09                        dw      ONE_MINUS
  3022 00:1548: 26 12 3C 15                  dw      BRANCH,SPACES_1
  3023 00:154C: 6F 07        SPACES_2:       dw      DROP
  3024 00:154E: 02 0D                        dw      EXIT
  3025                        
  3026                        ; TYPE ( c-addr u -- )
  3027                        ;
  3028                        ; If u is greater than zero, display the character string specified by c-addr
  3029                        ; and u.
  3030                        ;
  3031                        ; In this implementation it is defined as
  3032                        ;
  3033                        ;   ?DUP IF
  3034                        ;     OVER + SWAP DO I C@ EMIT LOOP
  3035                        ;   ELSE DROP THEN
  3036                        
  3037 00:1550: 32 15 00 04                  HEADER  4,"TYPE",NORMAL
       00:1554: 54 59 50 45 
  3038 00:1558: 20 87 12     TYPE:           jsr     DO_COLON
  3039 00:155B: 43 07                        dw      QUERY_DUP
  3040 00:155D: 30 12 77 15                  dw      QUERY_BRANCH,TYPE_2
  3041 00:1561: A3 07                        dw      OVER
  3042 00:1563: E5 08                        dw      PLUS
  3043 00:1565: EE 07                        dw      SWAP
  3044 00:1567: 07 13                        dw      DO_DO
  3045 00:1569: 72 08        TYPE_1:         dw      I
  3046 00:156B: 07 06                        dw      C_FETCH
  3047 00:156D: F4 14                        dw      EMIT
  3048 00:156F: 8D 13 69 15                  dw      DO_LOOP,TYPE_1
  3049 00:1573: 26 12 79 15                  dw      BRANCH,TYPE_3
  Mon Apr 18 2016 15:06                                                                                                    Page 61


  3050 00:1577: 6F 07        TYPE_2          dw      DROP
  3051 00:1579: 02 0D        TYPE_3          dw      EXIT
  3052                        
  3053                        ;===============================================================================
  3054                        ;-------------------------------------------------------------------------------
  3055                        
  3056                        ; #
  3057                        ; #>
  3058                        ; #S
  3059                        ; SIGN
  3060                        
  3061                        ;===============================================================================
  3062                        ; Programming Tools
  3063                        ;-------------------------------------------------------------------------------
  3064                        
  3065                        ; .NYBBLE
  3066                        
  3067                        ;               HEADER  7,".NYBBLE",NORMAL
  3068                        DOT_NYBBLE:
  3069 00:157B: A5 01                        lda     <1
  3070 00:157D: 29 0F 00                     and     #$000f
  3071 00:1580: 09 30 00                     ora     #$0030
  3072 00:1583: C9 3A 00                     cmp     #$003a
  3073 00:1586: 90 03                        bcc     $+5
  3074 00:1588: 69 06 00                     adc     #$0006
  3075 00:158B: 20 xx xx                     jsr     UartTx
  3076 00:158E: 4C 6F 07                     jmp     DROP
  3077                        
  3078                        ; .BYTE
  3079                        
  3080 00:1591: 53 15 00 05                  HEADER  5,".BYTE",NORMAL
       00:1595: 2E 42 59 54 
       00:1599: 45 
  3081 00:159A: 20 87 12     DOT_BYTE:       jsr     DO_COLON
  3082 00:159D: 80 07                        dw      DUP
  3083 00:159F: 67 13 04 00                  dw      DO_LITERAL,4
  3084 00:15A3: 5D 0C                        dw      RSHIFT
  3085 00:15A5: 7B 15                        dw      DOT_NYBBLE
  3086 00:15A7: 7B 15                        dw      DOT_NYBBLE
  3087 00:15A9: 26 15                        dw      SPACE
  3088 00:15AB: 02 0D                        dw      EXIT
  3089                        
  3090                        ; .WORD
  3091                        
  3092 00:15AD: 94 15 00 05                  HEADER  5,".WORD",NORMAL
       00:15B1: 2E 57 4F 52 
       00:15B5: 44 
  3093 00:15B6: 20 87 12     DOT_WORD:       jsr     DO_COLON
  3094 00:15B9: 80 07                        dw      DUP
  3095 00:15BB: 67 13 0C 00                  dw      DO_LITERAL,12
  3096 00:15BF: 5D 0C                        dw      RSHIFT
  3097 00:15C1: 7B 15                        dw      DOT_NYBBLE
  3098 00:15C3: 80 07                        dw      DUP
  3099 00:15C5: 67 13 08 00                  dw      DO_LITERAL,8
  3100 00:15C9: 5D 0C                        dw      RSHIFT
  3101 00:15CB: 7B 15                        dw      DOT_NYBBLE
  3102 00:15CD: 80 07                        dw      DUP
  3103 00:15CF: 67 13 04 00                  dw      DO_LITERAL,4
  Mon Apr 18 2016 15:06                                                                                                    Page 62


  3104 00:15D3: 5D 0C                        dw      RSHIFT
  3105 00:15D5: 7B 15                        dw      DOT_NYBBLE
  3106 00:15D7: 7B 15                        dw      DOT_NYBBLE
  3107 00:15D9: 26 15                        dw      SPACE
  3108 00:15DB: 02 0D                        dw      EXIT
  3109                        
  3110                        ; .DP
  3111                        
  3112 00:15DD: B0 15 00 03                  HEADER  3,".DP",NORMAL
       00:15E1: 2E 44 50 
  3113 00:15E4: 20 87 12                     jsr     DO_COLON
  3114 00:15E7: 37 16                        dw      AT_DP
  3115 00:15E9: B6 15                        dw      DOT_WORD
  3116 00:15EB: 02 0D                        dw      EXIT
  3117                        
  3118 00:15ED: E0 15 00 03                  HEADER  3,".RP",NORMAL
       00:15F1: 2E 52 50 
  3119 00:15F4: 20 87 12                     jsr     DO_COLON
  3120 00:15F7: 4C 16                        dw      AT_RP
  3121 00:15F9: B6 15                        dw      DOT_WORD
  3122 00:15FB: 02 0D                        dw      EXIT
  3123                        		
  3124                        ; .S ( -- )
  3125                        
  3126 00:15FD: F0 15 00 02  		HEADER	2,".S",NORMAL
       00:1601: 2E 53 
  3127 00:1603: 20 87 12     		jsr	DO_COLON
  3128 00:1606: 37 16        		dw	AT_DP
  3129 00:1608: 2E 09        		dw	ONE_PLUS
  3130 00:160A: 67 13 80 01  		dw	DO_LITERAL,DSTACK_END
  3131 00:160E: EE 07        		dw	SWAP
  3132 00:1610: 07 13        		dw	DO_DO
  3133 00:1612: 72 08        DOT_S_1:	dw	I
  3134 00:1614: B4 05        		dw	FETCH
  3135 00:1616: B6 15        		dw	DOT_WORD
  3136 00:1618: 67 13 02 00  		dw	DO_LITERAL,2
  3137 00:161C: 4F 12        		dw	DO_PLUS_LOOP
  3138 00:161E: 12 16        		dw	DOT_S_1
  3139 00:1620: 02 0D        		dw	EXIT
  3140                        		
  3141                        ; ? ( a-addr -- )
  3142                        
  3143 00:1622: 00 16 00 01  		HEADER	1,"?",NORMAL
       00:1626: 3F 
  3144 00:1627: 20 87 12     		jsr	DO_COLON
  3145 00:162A: B4 05        		dw	FETCH
  3146 00:162C: B6 15        		dw	DOT_WORD
  3147 00:162E: 02 0D        		dw	EXIT		
  3148                        
  3149 00:1630: 25 16 00 03                  HEADER  3,"@DP",NORMAL
       00:1634: 40 44 50 
  3150                        AT_DP:
  3151 00:1637: 0B                           phd
  3152 00:1638: 7B                           tdc
  3153 00:1639: 3A                           dec     a
  3154 00:163A: 3A                           dec     a
  3155 00:163B: 5B                           tcd
  3156 00:163C: 68                           pla
  Mon Apr 18 2016 15:06                                                                                                    Page 63


  3157 00:163D: 85 01                        sta     <1
  3158 00:163F: BB C8 C8 7C                  CONTINUE
       00:1643: 00 00 
  3159                        
  3160 00:1645: 33 16 00 03                  HEADER  3,"@RP",NORMAL
       00:1649: 40 52 50 
  3161                        AT_RP:
  3162 00:164C: 7B                           tdc
  3163 00:164D: 3A                           dec     a
  3164 00:164E: 3A                           dec     a
  3165 00:164F: 5B                           tcd
  3166 00:1650: BA                           tsx
  3167 00:1651: 86 01                        stx     <1
  3168 00:1653: BB C8 C8 7C                  CONTINUE
       00:1657: 00 00 
  3169                        		
  3170                        		
  3171                        ;-------------------------------------------------------------------------------
  3172                        
  3173                                        include "device.asm"
     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; Device Specific Words for the W65C816SXB
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015-2016 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ;------------------------------------------------------------------------------
    23                        
    24                        ; (TITLE) - ( -- )
    25                        ;
    26                        
    27                        ; 		HEADER	7,"(TITLE)",NORMAL
    28 00:1659: 20 87 12     DO_TITLE:	jsr	DO_COLON	
    29 00:165C: CD 13                        dw      DO_S_QUOTE
    30 00:165E: 1C 57 36 35                  db      28,"W65C816SXB ANS-Forth [16.04]"
       00:1662: 43 38 31 36 
       00:1666: 53 58 42 20 
       00:166A: 41 4E 53 2D 
       00:166E: 46 6F 72 74 
       00:1672: 68 20 5B 31 
       00:1676: 36 2E 30 34 
       00:167A: 5D 
    31 00:167B: 02 0D        		dw	EXIT
  Mon Apr 18 2016 15:06                                                                                                    Page 64


    32                        
    33                        ; BYE ( -- )
    34                        ;
    35                        ; Return control to the host operating system, if any.
    36                        
    37 00:167D: 48 16 00 03  		HEADER	3,"BYE",NORMAL
       00:1681: 42 59 45 
    38                        BYE:
    39 00:1684: 78           		sei
    40 00:1685: D8           		cld
    41 00:1686: 38 FB        		emulate
    42 00:1688: 6C FC FF     		jmp	($fffc)		; Reset the processor
    43                        		
    44                        ; UNUSED ( -- u )
    45                        ;
    46                        ; u is the amount of space remaining in the region addressed by HERE , in
    47                        ; address units.
    48                        
    49 00:168B: 80 16 00 06  		HEADER	6,"UNUSED",NORMAL
       00:168F: 55 4E 55 53 
       00:1693: 45 44 
    50 00:1695: 20 87 12     UNUSED:		jsr	DO_COLON
    51 00:1698: 67 13 00 7E  		dw	DO_LITERAL,$7e00
    52 00:169C: 1F 06        		dw	HERE
    53 00:169E: FB 08        		dw	MINUS
    54 00:16A0: 02 0D        		dw	EXIT
    55                        		
    56                        		
    57                        ;-------------------------------------------------------------------------------
    58                        		
    59 00:16A2: 8E 16 00 08  		HEADER	8,"ACIA$RXD",NORMAL
       00:16A6: 41 43 49 41 
       00:16AA: 24 52 58 44 
    60 00:16AE: 20 E4 12     		jsr	DO_CONSTANT
    61 00:16B1: 80 7F        		dw	$7f80
    62                        		
    63 00:16B3: A5 16 00 08  		HEADER	8,"ACIA$TXD",NORMAL
       00:16B7: 41 43 49 41 
       00:16BB: 24 54 58 44 
    64 00:16BF: 20 E4 12     		jsr	DO_CONSTANT
    65 00:16C2: 80 7F        		dw	$7f80
    66                        		
    67 00:16C4: B6 16 00 07  		HEADER	7,"ACIA$SR",NORMAL
       00:16C8: 41 43 49 41 
       00:16CC: 24 53 52 
    68 00:16CF: 20 E4 12     		jsr	DO_CONSTANT
    69 00:16D2: 81 7F        		dw     	$7f81
    70                        		
    71 00:16D4: C7 16 00 08  		HEADER	8,"ACIA$CMD",NORMAL
       00:16D8: 41 43 49 41 
       00:16DC: 24 43 4D 44 
    72 00:16E0: 20 E4 12     		jsr	DO_CONSTANT
    73 00:16E3: 82 7F        		dw     	$7f82
    74                        		
    75 00:16E5: D7 16 00 08  		HEADER	8,"ACIA$CTL",NORMAL
       00:16E9: 41 43 49 41 
       00:16ED: 24 43 54 4C 
    76 00:16F1: 20 E4 12     		jsr	DO_CONSTANT
  Mon Apr 18 2016 15:06                                                                                                    Page 65


    77 00:16F4: 83 7F        		dw	$7f83
    78                        
    79                        ;-------------------------------------------------------------------------------
    80                        
    81 00:16F6: E8 16 00 07  		HEADER	7,"PIA$PIA",NORMAL
       00:16FA: 50 49 41 24 
       00:16FE: 50 49 41 
    82 00:1701: 20 E4 12     		jsr	DO_CONSTANT
    83 00:1704: A0 7F        		dw      $7fa0
    84                        		
    85 00:1706: F9 16 00 08  		HEADER	8,"PIA$DDRA",NORMAL
       00:170A: 50 49 41 24 
       00:170E: 44 44 52 41 
    86 00:1712: 20 E4 12     		jsr	DO_CONSTANT
    87 00:1715: A0 7F        		dw	$7fa0
    88                        		
    89 00:1717: 09 17 00 07  		HEADER	7,"PIA$CRA",NORMAL
       00:171B: 50 49 41 24 
       00:171F: 43 52 41 
    90 00:1722: 20 E4 12     		jsr	DO_CONSTANT
    91 00:1725: A1 7F        		dw      $7fa1
    92                        		
    93 00:1727: 1A 17 00 07  		HEADER	7,"PIA$PIB",NORMAL
       00:172B: 50 49 41 24 
       00:172F: 50 49 42 
    94 00:1732: 20 E4 12     		jsr	DO_CONSTANT
    95 00:1735: A2 7F        		dw      $7fa2
    96                        		
    97 00:1737: 2A 17 00 08  		HEADER	8,"PIA$DDRB",NORMAL
       00:173B: 50 49 41 24 
       00:173F: 44 44 52 42 
    98 00:1743: 20 E4 12     		jsr	DO_CONSTANT
    99 00:1746: A2 7F        		dw      $7fa2
   100                        		
   101 00:1748: 3A 17 00 07  		HEADER	7,"PIA$CRB",NORMAL
       00:174C: 50 49 41 24 
       00:1750: 43 52 42 
   102 00:1753: 20 E4 12     		jsr	DO_CONSTANT
   103 00:1756: A3 7F        		dw      $7fa3
   104                        
   105                        ;-------------------------------------------------------------------------------
   106                        
   107 00:1758: 4B 17 00 08  		HEADER	8,"VIA1$ORB",NORMAL
       00:175C: 56 49 41 31 
       00:1760: 24 4F 52 42 
   108 00:1764: 20 E4 12     		jsr	DO_CONSTANT
   109 00:1767: C0 7F        		dw      $7fc0
   110                        		
   111 00:1769: 5B 17 00 08  		HEADER	8,"VIA1$IRB",NORMAL
       00:176D: 56 49 41 31 
       00:1771: 24 49 52 42 
   112 00:1775: 20 E4 12     		jsr	DO_CONSTANT
   113 00:1778: C0 7F        		dw      $7fc0
   114                        		
   115 00:177A: 6C 17 00 08  		HEADER	8,"VIA1$ORA",NORMAL
       00:177E: 56 49 41 31 
       00:1782: 24 4F 52 41 
   116 00:1786: 20 E4 12     		jsr	DO_CONSTANT
  Mon Apr 18 2016 15:06                                                                                                    Page 66


   117 00:1789: C1 7F        		dw      $7fc1
   118                        
   119 00:178B: 7D 17 00 08  		HEADER	8,"VIA1$IRA",NORMAL
       00:178F: 56 49 41 31 
       00:1793: 24 49 52 41 
   120 00:1797: 20 E4 12     		jsr	DO_CONSTANT
   121 00:179A: C1 7F        		dw      $7fc1
   122                        
   123 00:179C: 8E 17 00 09  		HEADER	9,"VIA1$DDRB",NORMAL
       00:17A0: 56 49 41 31 
       00:17A4: 24 44 44 52 
       00:17A8: 42 
   124 00:17A9: 20 E4 12     		jsr	DO_CONSTANT
   125 00:17AC: C2 7F        		dw      $7fc2
   126                        		
   127 00:17AE: 9F 17 00 09  		HEADER	9,"VIA1$DDRA",NORMAL
       00:17B2: 56 49 41 31 
       00:17B6: 24 44 44 52 
       00:17BA: 41 
   128 00:17BB: 20 E4 12     		jsr	DO_CONSTANT
   129 00:17BE: C3 7F        		dw      $7fc3
   130                        
   131 00:17C0: B1 17 00 09  		HEADER	9,"VIA1$T1CL",NORMAL
       00:17C4: 56 49 41 31 
       00:17C8: 24 54 31 43 
       00:17CC: 4C 
   132 00:17CD: 20 E4 12     		jsr	DO_CONSTANT
   133 00:17D0: C4 7F        		dw      $7fc4
   134                        		
   135 00:17D2: C3 17 00 09  		HEADER	9,"VIA1$T1CH",NORMAL
       00:17D6: 56 49 41 31 
       00:17DA: 24 54 31 43 
       00:17DE: 48 
   136 00:17DF: 20 E4 12     		jsr	DO_CONSTANT
   137 00:17E2: C5 7F        		dw      $7fc5
   138                        		
   139 00:17E4: D5 17 00 09  		HEADER	9,"VIA1$T1LL",NORMAL
       00:17E8: 56 49 41 31 
       00:17EC: 24 54 31 4C 
       00:17F0: 4C 
   140 00:17F1: 20 E4 12     		jsr	DO_CONSTANT
   141 00:17F4: C6 7F        		dw      $7fc6
   142                        		
   143 00:17F6: E7 17 00 09  		HEADER	9,"VIA1$T1LH",NORMAL
       00:17FA: 56 49 41 31 
       00:17FE: 24 54 31 4C 
       00:1802: 48 
   144 00:1803: 20 E4 12     		jsr	DO_CONSTANT
   145 00:1806: C7 7F        		dw      $7fc7
   146                        		
   147 00:1808: F9 17 00 09  		HEADER	9,"VIA1$T2CL",NORMAL
       00:180C: 56 49 41 31 
       00:1810: 24 54 32 43 
       00:1814: 4C 
   148 00:1815: 20 E4 12     		jsr	DO_CONSTANT
   149 00:1818: C8 7F        		dw      $7fc8
   150                        		
   151 00:181A: 0B 18 00 09  		HEADER	9,"VIA1$T2CH",NORMAL
  Mon Apr 18 2016 15:06                                                                                                    Page 67


       00:181E: 56 49 41 31 
       00:1822: 24 54 32 43 
       00:1826: 48 
   152 00:1827: 20 E4 12     		jsr	DO_CONSTANT
   153 00:182A: C9 7F        		dw      $7fc9
   154                        		
   155 00:182C: 1D 18 00 07  		HEADER	7,"VIA1$SR",NORMAL
       00:1830: 56 49 41 31 
       00:1834: 24 53 52 
   156 00:1837: 20 E4 12     		jsr	DO_CONSTANT
   157 00:183A: CA 7F        		dw      $7fca
   158                        		
   159 00:183C: 2F 18 00 08  		HEADER	8,"VIA1$ACR",NORMAL
       00:1840: 56 49 41 31 
       00:1844: 24 41 43 52 
   160 00:1848: 20 E4 12     		jsr	DO_CONSTANT
   161 00:184B: CB 7F        		dw      $7fcb
   162                        		
   163 00:184D: 3F 18 00 08  		HEADER	8,"VIA1$PCR",NORMAL
       00:1851: 56 49 41 31 
       00:1855: 24 50 43 52 
   164 00:1859: 20 E4 12     		jsr	DO_CONSTANT
   165 00:185C: CC 7F        		dw      $7fcc
   166                        		
   167 00:185E: 50 18 00 08  		HEADER	8,"VIA1$IFR",NORMAL
       00:1862: 56 49 41 31 
       00:1866: 24 49 46 52 
   168 00:186A: 20 E4 12     		jsr	DO_CONSTANT
   169 00:186D: CD 7F        		dw      $7fcd
   170                        		
   171 00:186F: 61 18 00 08  		HEADER	8,"VIA1$IER",NORMAL
       00:1873: 56 49 41 31 
       00:1877: 24 49 45 52 
   172 00:187B: 20 E4 12     		jsr	DO_CONSTANT
   173 00:187E: CE 7F        		dw      $7fce
   174                        		
   175 00:1880: 72 18 00 09  		HEADER	9,"VIA1$ORAN",NORMAL
       00:1884: 56 49 41 31 
       00:1888: 24 4F 52 41 
       00:188C: 4E 
   176 00:188D: 20 E4 12     		jsr	DO_CONSTANT
   177 00:1890: CF 7F        		dw      $7fcf
   178                        		
   179 00:1892: 83 18 00 09  		HEADER	9,"VIA1$IRAN",NORMAL
       00:1896: 56 49 41 31 
       00:189A: 24 49 52 41 
       00:189E: 4E 
   180 00:189F: 20 E4 12     		jsr	DO_CONSTANT
   181 00:18A2: CF 7F        		dw      $7fcf
   182                        
   183                        ;-------------------------------------------------------------------------------
   184                        
   185                        		
   186 00:18A4: 95 18 00 08  		HEADER	8,"VIA2$ORB",NORMAL
       00:18A8: 56 49 41 32 
       00:18AC: 24 4F 52 42 
   187 00:18B0: 20 E4 12     		jsr	DO_CONSTANT
   188 00:18B3: E0 7F        		dw      $7fe0
  Mon Apr 18 2016 15:06                                                                                                    Page 68


   189                        		
   190 00:18B5: A7 18 00 08  		HEADER	8,"VIA2$IRB",NORMAL
       00:18B9: 56 49 41 32 
       00:18BD: 24 49 52 42 
   191 00:18C1: 20 E4 12     		jsr	DO_CONSTANT
   192 00:18C4: E0 7F        		dw      $7fe0
   193                        		
   194 00:18C6: B8 18 00 08  		HEADER	8,"VIA2$ORA",NORMAL
       00:18CA: 56 49 41 32 
       00:18CE: 24 4F 52 41 
   195 00:18D2: 20 E4 12     		jsr	DO_CONSTANT
   196 00:18D5: E1 7F        		dw      $7fe1
   197                        		
   198 00:18D7: C9 18 00 08  		HEADER	8,"VIA2$IRA",NORMAL
       00:18DB: 56 49 41 32 
       00:18DF: 24 49 52 41 
   199 00:18E3: 20 E4 12     		jsr	DO_CONSTANT
   200 00:18E6: E1 7F        		dw      $7fe1
   201                        		
   202 00:18E8: DA 18 00 09  		HEADER	9,"VIA2$DDRB",NORMAL
       00:18EC: 56 49 41 32 
       00:18F0: 24 44 44 52 
       00:18F4: 42 
   203 00:18F5: 20 E4 12     		jsr	DO_CONSTANT
   204 00:18F8: E2 7F        		dw      $7fe2
   205                        		
   206 00:18FA: EB 18 00 09  		HEADER	9,"VIA2$DDRA",NORMAL
       00:18FE: 56 49 41 32 
       00:1902: 24 44 44 52 
       00:1906: 41 
   207 00:1907: 20 E4 12     		jsr	DO_CONSTANT
   208 00:190A: E3 7F        		dw      $7fe3
   209                        		
   210 00:190C: FD 18 00 09  		HEADER	9,"VIA2$T1CL",NORMAL
       00:1910: 56 49 41 32 
       00:1914: 24 54 31 43 
       00:1918: 4C 
   211 00:1919: 20 E4 12     		jsr	DO_CONSTANT
   212 00:191C: E4 7F        		dw      $7fe4
   213                        		
   214 00:191E: 0F 19 00 09  		HEADER	9,"VIA2$T1CH",NORMAL
       00:1922: 56 49 41 32 
       00:1926: 24 54 31 43 
       00:192A: 48 
   215 00:192B: 20 E4 12     		jsr	DO_CONSTANT
   216 00:192E: E5 7F        		dw      $7fe5
   217                        		
   218 00:1930: 21 19 00 09  		HEADER	9,"VIA2$T1LL",NORMAL
       00:1934: 56 49 41 32 
       00:1938: 24 54 31 4C 
       00:193C: 4C 
   219 00:193D: 20 E4 12     		jsr	DO_CONSTANT
   220 00:1940: E6 7F        		dw      $7fe6
   221                        		
   222 00:1942: 33 19 00 09  		HEADER	9,"VIA2$T1LH",NORMAL
       00:1946: 56 49 41 32 
       00:194A: 24 54 31 4C 
       00:194E: 48 
  Mon Apr 18 2016 15:06                                                                                                    Page 69


   223 00:194F: 20 E4 12     		jsr	DO_CONSTANT
   224 00:1952: E7 7F        		dw      $7fe7
   225                        		
   226 00:1954: 45 19 00 09  		HEADER	9,"VIA2$T2CL",NORMAL
       00:1958: 56 49 41 32 
       00:195C: 24 54 32 43 
       00:1960: 4C 
   227 00:1961: 20 E4 12     		jsr	DO_CONSTANT
   228 00:1964: E8 7F        		dw      $7fe8
   229                        		
   230 00:1966: 57 19 00 09  		HEADER	9,"VIA2$T2CH",NORMAL
       00:196A: 56 49 41 32 
       00:196E: 24 54 32 43 
       00:1972: 48 
   231 00:1973: 20 E4 12     		jsr	DO_CONSTANT
   232 00:1976: E9 7F        		dw      $7fe9
   233                        		
   234 00:1978: 69 19 00 07  		HEADER	7,"VIA2$SR",NORMAL
       00:197C: 56 49 41 32 
       00:1980: 24 53 52 
   235 00:1983: 20 E4 12     		jsr	DO_CONSTANT
   236 00:1986: EA 7F        		dw      $7fea
   237                        		
   238 00:1988: 7B 19 00 08  		HEADER	8,"VIA2$ACR",NORMAL
       00:198C: 56 49 41 32 
       00:1990: 24 41 43 52 
   239 00:1994: 20 E4 12     		jsr	DO_CONSTANT
   240 00:1997: EB 7F        		dw      $7feb
   241                        		
   242 00:1999: 8B 19 00 08  		HEADER	8,"VIA2$PCR",NORMAL
       00:199D: 56 49 41 32 
       00:19A1: 24 50 43 52 
   243 00:19A5: 20 E4 12     		jsr	DO_CONSTANT
   244 00:19A8: EC 7F        		dw      $7fec
   245                        		
   246 00:19AA: 9C 19 00 08  		HEADER	8,"VIA2$IFR",NORMAL
       00:19AE: 56 49 41 32 
       00:19B2: 24 49 46 52 
   247 00:19B6: 20 E4 12     		jsr	DO_CONSTANT
   248 00:19B9: ED 7F        		dw      $7fed
   249                        		
   250 00:19BB: AD 19 00 08  		HEADER	8,"VIA2$IER",NORMAL
       00:19BF: 56 49 41 32 
       00:19C3: 24 49 45 52 
   251 00:19C7: 20 E4 12     		jsr	DO_CONSTANT
   252 00:19CA: EE 7F        		dw      $7fee
   253                        		
   254 00:19CC: BE 19 00 09  		HEADER	9,"VIA2$ORAN",NORMAL
       00:19D0: 56 49 41 32 
       00:19D4: 24 4F 52 41 
       00:19D8: 4E 
   255 00:19D9: 20 E4 12     		jsr	DO_CONSTANT
   256 00:19DC: EF 7F        		dw      $7fef
   257                        		
   258 00:19DE: CF 19 00 09  		HEADER	9,"VIA2$IRAN",NORMAL
       00:19E2: 56 49 41 32 
       00:19E6: 24 49 52 41 
       00:19EA: 4E 
  Mon Apr 18 2016 15:06                                                                                                    Page 70


   259 00:19EB: 20 E4 12     		jsr	DO_CONSTANT
   260 00:19EE: EF 7F        		dw      $7fef
  3174                        
  3175                                        TRAILER
  3176                        NEXT_WORD:
  3177                        
  3178                                        end


      Lines assembled: 5280
      Errors: 0
