  Thu Nov 19 2015 21:53                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C816 Macro Assembler   **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        ;==============================================================================
     2                        ;     _    _   _ ____    _____          _   _       _  ___  _  __
     3                        ;    / \  | \ | / ___|  |  ___|__  _ __| |_| |__   ( )( _ )/ |/ /_
     4                        ;   / _ \ |  \| \___ \  | |_ / _ \| '__| __| '_ \  |/ / _ \| | '_ \
     5                        ;  / ___ \| |\  |___) | |  _| (_) | |  | |_| | | |   | (_) | | (_) |
     6                        ; /_/   \_\_| \_|____/  |_|  \___/|_|   \__|_| |_|    \___/|_|\___/
     7                        ;
     8                        ; A Direct Threaded ANS Forth for the WDC 65C816
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; This implementation is designed to run in the 65C816's native mode with both
    23                        ; the accumulator and index registers in 16-bit mode except when the word needs
    24                        ; 8-bit memory access.
    25                        ;
    26                        ; The Forth data stack is indexed using the X register witch values held at
    27                        ; the same index offsets as they would be on the return stack. The Y register
    28                        ; holds the forth instruction pointer.
    29                        ;
    30                        ;==============================================================================
    31                        ;------------------------------------------------------------------------------
    32                        
    33                                        pw      132
    34                                        inclist on
    35                                        maclist off
    36                        
    37                                        chip    65816
    38                                        longi   off
    39                                        longa   off
    40                        
    41                                        include "w65c816.inc"
     1                        ;==============================================================================
     2                        ; __        ____  ____   ____ ___  _  __   
     3                        ; \ \      / / /_| ___| / ___( _ )/ |/ /_  
     4                        ;  \ \ /\ / / '_ \___ \| |   / _ \| | '_ \ 
     5                        ;   \ V  V /| (_) |__) | |__| (_) | | (_) |
     6                        ;    \_/\_/  \___/____/ \____\___/|_|\___/ 
     7                        ;
     8                        ; Western Design Center W65C816 device definitions                                          
     9                        ;------------------------------------------------------------------------------
    10                        ; Copyright (C)2015 HandCoded Software Ltd.
    11                        ; All rights reserved.
  Thu Nov 19 2015 21:53                                                                                                    Page 2


    12                        ;
    13                        ; This work is made available under the terms of the Creative Commons
    14                        ; Attribution-NonCommercial-ShareAlike 4.0 International license. Open the
    15                        ; following URL to see the details.
    16                        ;
    17                        ; http://creativecommons.org/licenses/by-nc-sa/4.0/
    18                        ;
    19                        ;==============================================================================
    20                        ; Notes:
    21                        ;
    22                        ; Various macros and definitions for the W65C816 microprocessor.
    23                        ;
    24                        ;------------------------------------------------------------------------------
    25                        
    26                        ;==============================================================================
    27                        ; Status Register Bits
    28                        ;------------------------------------------------------------------------------
    29                        
    30             00000007   N_FLAG          equ     7
    31             00000006   V_FLAG          equ     6
    32             00000005   M_FLAG          equ     5
    33             00000004   X_FLAG          equ     4
    34             00000004   B_FLAG          equ     4
    35             00000003   D_FLAG          equ     3
    36             00000002   I_FLAG          equ     2
    37             00000001   Z_FLAG          equ     1
    38             00000000   C_FLAG          equ     0
    39                        
    40                        ;==============================================================================
    41                        ; Macros
    42                        ;------------------------------------------------------------------------------
    43                        
    44                        ; Puts the processor into emulation mode. A, X and Y become 8-bits and the
    45                        ; stack is fixed at $0100-$01ff. 
    46                        
    47                        emulate         macro
    48                                        sec
    49                                        xce
    50                                        endm
    51                        
    52                        ; Puts the processor into native mode. The size of the memory and index
    53                        ; register operations is controlled by the M & X bits in the status register.
    54                        
    55                        native          macro
    56                                        clc
    57                                        xce
    58                                        endm
    59                        
    60                        ; Resets the M bit making the accumator and memory accesses 16-bits wide.
    61                         
    62                        long_a          macro
    63                                        rep     #(1<<M_FLAG)
    64                                        longa   on
    65                                        endm
    66                        
    67                        ; Resets the X bit making the index registers 16-bits wide
    68                        
    69                        long_i          macro
  Thu Nov 19 2015 21:53                                                                                                    Page 3


    70                                        rep     #(1<<X_FLAG)
    71                                        longi   on
    72                                        endm
    73                        
    74                        ; Resets the M and X bits making the accumator, memory accesses and index
    75                        ; registers 16-bits wide.
    76                                        
    77                        long_ai         macro
    78                                        rep     #(1<<M_FLAG)|(1<<X_FLAG)
    79                                        longa   on
    80                                        longi   on
    81                                        endm
    82                        
    83                        ; Sets the M bit making the accumator and memory accesses 16-bits wide.
    84                        
    85                        short_a         macro
    86                                        sep     #(1<<M_FLAG)
    87                                        longa   off
    88                                        endm
    89                        
    90                        ; Sets the X bit making the index registers 8-bits wide
    91                        
    92                        short_i         macro
    93                                        sep     #(1<<X_FLAG)
    94                                        longi   off
    95                                        endm
    96                                        
    97                        ; Sets the M and X bits making the accumator, memory accesses and index
    98                        ; registers 8-bits wide.
    99                        
   100                        short_ai        macro
   101                                        sep     #(1<<M_FLAG)|(1<<X_FLAG)
   102                                        longa   off
   103                                        longi   off
   104                                        endm
    42                        
    43                        ;==============================================================================
    44                        ; Macros
    45                        ;------------------------------------------------------------------------------
    46                        
    47             00000000   COUNT           set     0                       ; Word counter
    48             00000000   WORD0           equ     0                       ; Null address for first word
    49                        
    50                        HEADER          macro   TYPE
    51                        WORD@<COUNT+1>:
    52                                        dw      WORD@<COUNT>
    53                                        db      TYPE
    54                        COUNT           set     COUNT+1
    55                                        endm
    56                        
    57             00000000   NORMAL          equ     $00
    58             00000080   IMMEDIATE       equ     $80
    59                        
    60                        TRAILER         macro
    61                        LAST_WORD       equ     WORD@<COUNT>
    62                                        endm
    63                        
    64                        ;==============================================================================
  Thu Nov 19 2015 21:53                                                                                                    Page 4


    65                        ; Definitions
    66                        ;------------------------------------------------------------------------------
    67                        
    68             00000080   DSTACK_SIZE     equ     128
    69             00000081   DSTACK_INIT     equ     DSTACK+DSTACK_SIZE-1
    70             000001FF   RSTACK_INIT     equ     $01ff
    71                        
    72             00000014   USER_SIZE       equ     20
    73                        
    74             00000000   TO_IN_OFFSET    equ     0
    75             00000002   BASE_OFFSET     equ     2
    76             00000004   BLK_OFFSET      equ     4
    77             00000006   DP_OFFSET       equ     6
    78             00000008   LATEST_OFFSET   equ     8
    79             0000000A   SCR_OFFSET      equ     10
    80             0000000C   SOURCEID_OFFSET equ     12                      ; Input source flag
    81             0000000E   STATE_OFFSET    equ     14                      ; Compiling/Interpreting flag
    82             00000010   BUFFER_OFFSET   equ     16                      ; Address of the input buffer
    83             00000012   LENGTH_OFFSET   equ     18                      ; Length of the input buffer
    84                        
    85             00000080   TIB_SIZE        equ     128
    86                        
    87                        ;==============================================================================
    88                        ; Data Areas
    89                        ;------------------------------------------------------------------------------
    90                        
    91                                        page0
    92                                        org     $00
    93                        
    94 00:0000:              WA              ds      2                       ; Word address
    95                        
    96 00:0002:              DSTACK          ds      DSTACK_SIZE             ; The data stack (indexed by X)
    97                        
    98                                        data
    99                                        org     $210
   100                        
   101 00:0210:              USER_AREA       ds      USER_SIZE               ; User Variables
   102                        
   103 00:0224:              TIB_AREA        ds      TIB_SIZE                ; Terminal Input Buffer
   104                        
   105                        ;==============================================================================
   106                        ; Forth Entry Point
   107                        ;------------------------------------------------------------------------------
   108                        
   109                        FORTH           section OFFSET $0400
   110                        
   111                                        public  Start
   112                        Start:
   113 00:0400: 18 FB                        native                          ; Go to native mode
   114 00:0402: C2 30                        long_ai                         ; And all 16-bit registers
   115 00:0404: A9 FF 01                     lda     #RSTACK_INIT            ; Initialise return stack
   116 00:0407: 1B                           tcs
   117 00:0408: A2 81 00                     ldx     #DSTACK_INIT            ; .. and data stack
   118                        
   119 00:040B: A0 11 04                     ldy     #COLD                   ; Then perform COLD start
   120 00:040E: 4C F5 0C                     jmp     NEXT
   121                        
   122                        COLD:
  Thu Nov 19 2015 21:53                                                                                                    Page 5


   123 00:0411: 40 05                        dw      DECIMAL
   124 00:0413: FC 04 7C 04                  dw      ZERO,BLK,STORE
       00:0417: 66 05 
   125 00:0419: 1C 05 E6 04                  dw      FALSE,STATE,STORE
       00:041D: 66 05 
   126 00:041F: 6E 0E 6E 0E                  dw      CR,CR,DO_S_QUOTE
       00:0423: 4E 0E 
   127 00:0425: 23 48 61 6E                  db      35,"HandCoded W65C816 ANS-Forth [15.11]"
       00:0429: 64 43 6F 64 
       00:042D: 65 64 20 57 
       00:0431: 36 35 43 38 
       00:0435: 31 36 20 41 
       00:0439: 4E 53 2D 46 
       00:043D: 6F 72 74 68 
       00:0441: 20 5B 31 35 
       00:0445: 2E 31 31 5D 
   128 00:0449: E0 0E                        dw      TYPE
   129 00:044B: E4 09                        dw      ABORT
   130                        
   131                        ;==============================================================================
   132                        ; System/User Variables
   133                        ;------------------------------------------------------------------------------
   134                        
   135                        ; #TIB ( -- a-addr )
   136                        ;
   137                        ; a-addr is the address of a cell containing the number of characters in the
   138                        ; terminal input buffer.
   139                        
   140 00:044D: 00 00 00                     HEADER  NORMAL
   141 00:0450: 04 23 54 49                  db      4,"#TIB"
       00:0454: 42 
   142 00:0455: 4C 40 0D     HASH_TIB:       jmp     DO_CONSTANT
   143 00:0458: 5A 04                        dw      $+2
   144 00:045A: 7E 00                        dw      TIB_SIZE-2
   145                        
   146                        ; >IN ( -- a-addr )
   147                        ;
   148                        ; a-addr is the address of a cell containing the offset in characters from the
   149                        ; start of the input buffer to the start of the parse area.
   150                        
   151 00:045C: 4D 04 00                     HEADER  NORMAL
   152 00:045F: 03 3E 49 4E                  db      3,">IN"
   153 00:0463: 4C 0D 0E     TO_IN:          jmp     DO_USER
   154 00:0466: 00 00                        dw      TO_IN_OFFSET
   155                        
   156                        ; BASE ( -- a-addr )
   157                        ;
   158                        ; a-addr is the address of a cell containing the current number-conversion
   159                        ; radix {{2...36}}.
   160                        
   161 00:0468: 5C 04 00                     HEADER  NORMAL
   162 00:046B: 04 42 41 53                  db      4,"BASE"
       00:046F: 45 
   163 00:0470: 4C 0D 0E     BASE:           jmp     DO_USER
   164 00:0473: 02 00                        dw      BASE_OFFSET
   165                        
   166                        ; BLK ( -- a-addr )
   167                        ;
  Thu Nov 19 2015 21:53                                                                                                    Page 6


   168                        ; a-addr is the address of a cell containing zero or the number of the mass-
   169                        ; storage block being interpreted. If BLK contains zero, the input source is
   170                        ; not a block and can be identified by SOURCE-ID, if SOURCE-ID is available. An
   171                        ; ambiguous condition exists if a program directly alters the contents of BLK.
   172                        
   173 00:0475: 68 04 00                     HEADER  NORMAL
   174 00:0478: 03 42 4C 4B                  db      3,"BLK"
   175 00:047C: 4C 0D 0E     BLK:            jmp     DO_USER
   176 00:047F: 04 00                        dw      BLK_OFFSET
   177                        
   178                        ; (BUFFER)
   179                        
   180 00:0481: 75 04 00                     HEADER  NORMAL
   181 00:0484: 08 28 42 55                  db      8,"(BUFFER)"
       00:0488: 46 46 45 52 
       00:048C: 29 
   182 00:048D: 4C 0D 0E     BUFFER:         jmp     DO_USER
   183 00:0490: 10 00                        dw      BUFFER_OFFSET
   184                        
   185                        ; DP ( -- a-addr )
   186                        
   187 00:0492: 81 04 00                     HEADER  NORMAL
   188 00:0495: 02 44 50                     db      2,"DP"
   189 00:0498: 4C 0D 0E     DP:             jmp     DO_USER
   190 00:049B: 06 00                        dw      DP_OFFSET
   191                        
   192                        ; LATEST ( -- a-addr )
   193                        
   194 00:049D: 92 04 00                     HEADER  NORMAL
   195 00:04A0: 06 4C 41 54                  db      6,"LATEST"
       00:04A4: 45 53 54 
   196 00:04A7: 4C 0D 0E     LATEST:         jmp     DO_USER
   197 00:04AA: 08 00                        dw      LATEST_OFFSET
   198                        
   199                        ; (LENGTH)
   200                        
   201 00:04AC: 9D 04 00                     HEADER  NORMAL
   202 00:04AF: 08 28 4C 45                  db      8,"(LENGTH)"
       00:04B3: 4E 47 54 48 
       00:04B7: 29 
   203 00:04B8: 4C 0D 0E     LENGTH:         jmp     DO_USER
   204 00:04BB: 12 00                        dw      LENGTH_OFFSET
   205                        
   206                        ; SCR ( -- a-addr )
   207                        ;
   208                        ; a-addr is the address of a cell containing the block number of the block most
   209                        ; recently LISTed.
   210                        
   211 00:04BD: AC 04 00                     HEADER  NORMAL
   212 00:04C0: 03 53 43 52                  db      3,"SCR"
   213 00:04C4: 4C 0D 0E     SCR:            jmp     DO_USER
   214 00:04C7: 0A 00                        dw      SCR_OFFSET
   215                        
   216                        ; (SOURCE-ID)
   217                        
   218 00:04C9: BD 04 00                     HEADER  NORMAL
   219 00:04CC: 0B 28 53 4F                  db      11,"(SOURCE-ID)"
       00:04D0: 55 52 43 45 
  Thu Nov 19 2015 21:53                                                                                                    Page 7


       00:04D4: 2D 49 44 29 
   220 00:04D8: 4C 0D 0E     SOURCEID:       jmp     DO_USER
   221 00:04DB: 0C 00                        dw      SOURCEID_OFFSET
   222                        
   223                        ; STATE ( -- a-addr )
   224                        ;
   225                        ; a-addr is the address of a cell containing the compilation-state flag. STATE
   226                        ; is true when in compilation state, false otherwise. The true value in STATE
   227                        ; is non-zero, but is otherwise implementation-defined.
   228                        
   229 00:04DD: C9 04 00                     HEADER  NORMAL
   230 00:04E0: 05 53 54 41                  db      5,"STATE"
       00:04E4: 54 45 
   231 00:04E6: 4C 0D 0E     STATE:          jmp     DO_USER
   232 00:04E9: 0E 00                        dw      STATE_OFFSET
   233                        
   234                        ; TIB ( -- c-addr )
   235                        ;
   236                        ; c-addr is the address of the terminal input buffer.
   237                        
   238 00:04EB: DD 04 00                     HEADER  NORMAL
   239 00:04EE: 03 54 49 42                  db      3,"TIB"
   240 00:04F2: 4C 40 0D     TIB:            jmp     DO_CONSTANT
   241 00:04F5: 24 02                        dw      TIB_AREA
   242                        
   243                        ;==============================================================================
   244                        ; Constants
   245                        ;------------------------------------------------------------------------------
   246                        
   247                        ; 0 ( -- 0 )
   248                        ;
   249                        ; Push the constant value zero on the stack
   250                        
   251 00:04F7: EB 04 00                     HEADER  NORMAL
   252 00:04FA: 01 30                        db      1,"0"
   253                        ZERO:
   254 00:04FC: CA                           dex                             ; Make space on the stack
   255 00:04FD: CA                           dex
   256 00:04FE: 74 03                        stz     DSTACK+1,X              ; And create a zero value
   257 00:0500: 4C F5 0C                     jmp     NEXT                    ; Done
   258                        
   259                        ; BL ( -- char )
   260                        ;
   261                        ; char is the character value for a space.
   262                        
   263 00:0503: F7 04 00                     HEADER  NORMAL
   264 00:0506: 02 42 4C                     db      2,"BL"
   265                        BL:
   266 00:0509: CA                           dex                             ; Make space on the stack
   267 00:050A: CA                           dex
   268 00:050B: A9 20 00                     lda     #' '                    ; And save a space value
   269 00:050E: 95 03                        sta     DSTACK+1,x
   270 00:0510: 4C F5 0C                     jmp     NEXT                    ; Done
   271                        
   272                        ; FALSE ( -- false )
   273                        ;
   274                        ; Return a false flag.
   275                        
  Thu Nov 19 2015 21:53                                                                                                    Page 8


   276 00:0513: 03 05 00                     HEADER  NORMAL
   277 00:0516: 05 46 41 4C                  db      5,"FALSE"
       00:051A: 53 45 
   278                        FALSE:
   279 00:051C: CA                           dex                             ; Make space on the stack
   280 00:051D: CA                           dex
   281 00:051E: 74 03                        stz     DSTACK+1,X              ; And create a false value
   282 00:0520: 4C F5 0C                     jmp     NEXT                    ; Done
   283                        
   284                        ; TRUE ( -- true )
   285                        ;
   286                        ; Return a true flag, a single-cell value with all bits set.
   287                        
   288 00:0523: 13 05 00                     HEADER  NORMAL
   289 00:0526: 04 54 52 55                  db      4,"TRUE"
       00:052A: 45 
   290                        TRUE:
   291 00:052B: CA                           dex                             ; Make space on the stack
   292 00:052C: CA                           dex
   293 00:052D: A9 FF FF                     lda     #$ffff                  ; And create a true value
   294 00:0530: 95 03                        sta     DSTACK+1,x
   295 00:0532: 4C F5 0C                     jmp     NEXT                    ; Done
   296                        
   297                        ;==============================================================================
   298                        ; Radix
   299                        ;------------------------------------------------------------------------------
   300                        
   301                        ; DECIMAL ( -- )
   302                        ;
   303                        ; Set the numeric conversion radix to ten (decimal).
   304                        
   305 00:0535: 23 05 00                     HEADER  NORMAL
   306 00:0538: 07 44 45 43                  db      7,"DECIMAL"
       00:053C: 49 4D 41 4C 
   307 00:0540: 4C F0 0C     DECIMAL:        jmp     DO_COLON
   308 00:0543: BE 0D 0A 00                  dw      DO_LITERAL,10,BASE,STORE
       00:0547: 70 04 66 05 
   309 00:054B: 42 0A                        dw      EXIT
   310                        
   311                        ; HEX ( -- )
   312                        ;
   313                        ; Set contents of BASE to sixteen.
   314                        
   315 00:054D: 35 05 00                     HEADER  NORMAL
   316 00:0550: 03 48 45 58                  db      3,"HEX"
   317 00:0554: 4C F0 0C     HEX:            jmp     DO_COLON
   318 00:0557: BE 0D 10 00                  dw      DO_LITERAL,16,BASE,STORE
       00:055B: 70 04 66 05 
   319 00:055F: 42 0A                        dw      EXIT
   320                        
   321                        ;==============================================================================
   322                        ; Memory Operations
   323                        ;------------------------------------------------------------------------------
   324                        
   325                        ; ! ( x a-addr -- )
   326                        ;
   327                        ; Store x at a-addr.
   328                        
  Thu Nov 19 2015 21:53                                                                                                    Page 9


   329 00:0561: 4D 05 00                     HEADER  NORMAL
   330 00:0564: 01 21                        db      1,"!"
   331                        STORE:
   332 00:0566: 5A                           phy
   333 00:0567: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   334 00:0569: B5 05                        lda     DSTACK+3,x              ; Fetch the data value
   335 00:056B: 99 00 00                     sta     0,y                     ; Save it
   336 00:056E: E8                           inx                             ; Clean up data stack
   337 00:056F: E8                           inx
   338 00:0570: E8                           inx
   339 00:0571: E8                           inx
   340 00:0572: 7A                           ply
   341 00:0573: 4C F5 0C                     jmp     NEXT                    ; Done
   342                        
   343                        ; +! ( n|u a-addr -- )
   344                        ;
   345                        ; Add n|u to the single-cell number at a-addr.
   346                        
   347 00:0576: 61 05 00                     HEADER  NORMAL
   348 00:0579: 02 2B 21                     db      2,"+!"
   349                        PLUS_STORE:
   350 00:057C: 5A                           phy
   351 00:057D: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   352 00:057F: B5 05                        lda     DSTACK+3,x              ; Fetch the data value
   353 00:0581: 18                           clc                             ; Add data to memory
   354 00:0582: 79 00 00                     adc     0,y
   355 00:0585: 99 00 00                     sta     0,y                     ; And save result
   356 00:0588: E8                           inx                             ; Clean up data stacl
   357 00:0589: E8                           inx
   358 00:058A: E8                           inx
   359 00:058B: E8                           inx
   360 00:058C: 7A                           ply
   361 00:058D: 4C F5 0C                     jmp     NEXT                    ; Done
   362                        
   363                        ; , ( x -- )
   364                        ;
   365                        ; Reserve one cell of data space and store x in the cell. If the data-space
   366                        ; pointer is aligned when , begins execution, it will remain aligned when ,
   367                        ; finishes execution. An ambiguous condition exists if the data-space pointer
   368                        ; is not aligned prior to execution of ,.
   369                        ;
   370                        ;   HERE ! 1 CELLS ALLOT
   371                        
   372 00:0590: 76 05 00                     HEADER  NORMAL
   373 00:0593: 01 2C                        db      1,","
   374 00:0595: 4C F0 0C     COMMA:          jmp     DO_COLON
   375 00:0598: 45 06 66 05                  dw      HERE,STORE
   376 00:059C: BE 0D 01 00                  dw      DO_LITERAL,1,CELLS,ALLOT
       00:05A0: 81 06 EA 05 
   377 00:05A4: 42 0A                        dw      EXIT
   378                        
   379                        ; 2! ( x1 x2 a-addr -- )
   380                        ;
   381                        ; Store the cell pair x1 x2 at a-addr, with x2 at a-addr and x1 at the next
   382                        ; consecutive cell. It is equivalent to the sequence SWAP OVER ! CELL+ !.
   383                        
   384 00:05A6: 90 05 00                     HEADER  NORMAL
   385 00:05A9: 02 32 21                     db      2,"2!"
  Thu Nov 19 2015 21:53                                                                                                    Page 10


   386                        TWO_STORE:
   387 00:05AC: 4C F0 0C                     jmp     DO_COLON
   388 00:05AF: 55 07                        dw      SWAP
   389 00:05B1: 44 07                        dw      OVER
   390 00:05B3: 66 05                        dw      STORE
   391 00:05B5: 71 06                        dw      CELL_PLUS
   392 00:05B7: 66 05                        dw      STORE
   393 00:05B9: 42 0A                        dw      EXIT
   394                        
   395                        ; 2@ ( a-addr -- x1 x2 )
   396                        ;
   397                        ; Fetch the cell pair x1 x2 stored at a-addr. x2 is stored at a-addr and x1 at
   398                        ; the next consecutive cell. It is equivalent to the sequence DUP CELL+ @ SWAP
   399                        ; @.
   400                        
   401 00:05BB: A6 05 00                     HEADER  NORMAL
   402 00:05BE: 02 32 40                     db      2,"2@"
   403                        TWO_FETCH:
   404 00:05C1: 4C F0 0C                     jmp     DO_COLON
   405 00:05C4: 23 07                        dw      DUP
   406 00:05C6: 71 06                        dw      CELL_PLUS
   407 00:05C8: D5 05                        dw      FETCH
   408 00:05CA: 55 07                        dw      SWAP
   409 00:05CC: D5 05                        dw      FETCH
   410 00:05CE: 42 0A                        dw      EXIT
   411                        
   412                        ; @ ( a-addr -- x )
   413                        ;
   414                        ; x is the value stored at a-addr.
   415                        
   416 00:05D0: BB 05 00                     HEADER  NORMAL
   417 00:05D3: 01 40                        db      1,"@"
   418                        FETCH:
   419 00:05D5: 5A                           phy
   420 00:05D6: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   421 00:05D8: B9 00 00                     lda     0,y                     ; Load the actual data
   422 00:05DB: 95 03                        sta     DSTACK+1,x              ; And replace the top value
   423 00:05DD: 7A                           ply
   424 00:05DE: 4C F5 0C                     jmp     NEXT                    ; Done
   425                        
   426                        ; ALLOT ( n -- )
   427                        ;
   428                        ; If n is greater than zero, reserve n address units of data space. If n is
   429                        ; less than zero, release |n| address units of data space. If n is zero, leave
   430                        ; the data-space pointer unchanged.
   431                        ;
   432                        ; In this implementation its is defined as:
   433                        ;
   434                        ;   DP +!
   435                        
   436 00:05E1: D0 05 00                     HEADER  NORMAL
   437 00:05E4: 05 41 4C 4C                  db      5,"ALLOT"
       00:05E8: 4F 54 
   438 00:05EA: 4C F0 0C     ALLOT:          jmp     DO_COLON
   439 00:05ED: 98 04 7C 05                  dw      DP,PLUS_STORE
   440 00:05F1: 42 0A                        dw      EXIT
   441                        
   442                        ; C! ( char c-addr -- )
  Thu Nov 19 2015 21:53                                                                                                    Page 11


   443                        ;
   444                        ; Store char at c-addr. When character size is smaller than cell size, only the
   445                        ; number of low-order bits corresponding to character size are transferred.
   446                        
   447 00:05F3: E1 05 00                     HEADER  NORMAL
   448 00:05F6: 02 43 21                     db      2,"C!"
   449                        C_STORE:
   450 00:05F9: 5A                           phy
   451 00:05FA: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   452 00:05FC: B5 05                        lda     DSTACK+3,x              ; Fetch the data value
   453 00:05FE: E2 20                        short_a
   454 00:0600: 99 00 00                     sta     0,y                     ; Save it
   455 00:0603: C2 20                        long_a
   456 00:0605: E8                           inx
   457 00:0606: E8                           inx
   458 00:0607: E8                           inx
   459 00:0608: E8                           inx
   460 00:0609: 7A                           ply
   461 00:060A: 4C F5 0C                     jmp     NEXT                    ; Done
   462                        
   463                        ; C, ( char -- )
   464                        ;
   465                        ; Reserve space for one character in the data space and store char in the
   466                        ; space. If the data-space pointer is character aligned when C, begins
   467                        ; execution, it will remain character aligned when C, finishes execution.
   468                        ; An ambiguous condition exists if the data-space pointer is not character-
   469                        ; aligned prior to execution of C,
   470                        ;
   471                        ;   HERE C! 1 CHARS ALLOT
   472                        
   473 00:060D: F3 05 00                     HEADER  NORMAL
   474 00:0610: 02 43 2C                     db      2,"C,"
   475 00:0613: 4C F0 0C     C_COMMA:        jmp     DO_COLON
   476 00:0616: 45 06 F9 05                  dw      HERE,C_STORE
   477 00:061A: BE 0D 01 00                  dw      DO_LITERAL,1,CHARS,ALLOT
       00:061E: 9D 06 EA 05 
   478 00:0622: 42 0A                        dw      EXIT
   479                        
   480                        ; C@ ( c-addr -- char )
   481                        ;
   482                        ; Fetch the character stored at c-addr. When the cell size is greater than
   483                        ; character size, the unused high-order bits are all zeroes.
   484                        
   485 00:0624: 0D 06 00                     HEADER  NORMAL
   486 00:0627: 02 43 40                     db      2,"C@"
   487                        C_FETCH:
   488 00:062A: 5A                           phy
   489 00:062B: B4 03                        ldy     DSTACK+1,x              ; Fetch the memory address
   490 00:062D: E2 20                        short_a
   491 00:062F: B9 00 00                     lda     0,y                     ; Load the actual data
   492 00:0632: C2 20                        long_a
   493 00:0634: 29 FF 00                     and     #$00ff
   494 00:0637: 95 03                        sta     DSTACK+1,x              ; And replace the top value
   495 00:0639: 7A                           ply
   496 00:063A: 4C F5 0C                     jmp     NEXT                    ; Done
   497                        
   498                        ; HERE
   499                        
  Thu Nov 19 2015 21:53                                                                                                    Page 12


   500 00:063D: 24 06 00                     HEADER  NORMAL
   501 00:0640: 04 48 45 52                  db      4,"HERE"
       00:0644: 45 
   502 00:0645: 4C F0 0C     HERE:           jmp     DO_COLON
   503 00:0648: 98 04 D5 05                  dw      DP,FETCH
   504 00:064C: 42 0A                        dw      EXIT
   505                        
   506                        ;==============================================================================
   507                        ; Alignment
   508                        ;------------------------------------------------------------------------------
   509                        
   510                        ; ALIGN ( -- )
   511                        ;
   512                        ; If the data-space pointer is not aligned, reserve enough space to align it.
   513                        
   514 00:064E: 3D 06 00                     HEADER  NORMAL
   515 00:0651: 05 41 4C 49                  db      5,"ALIGN"
       00:0655: 47 4E 
   516                        ALIGN:
   517 00:0657: 4C F5 0C                     jmp     NEXT                    ; Done
   518                        
   519                        ; ALIGNED ( addr -- a-addr )
   520                        ;
   521                        ; a-addr is the first aligned address greater than or equal to addr.
   522                        
   523 00:065A: 4E 06 00                     HEADER  NORMAL
   524 00:065D: 07 41 4C 49                  db      7,"ALIGNED"
       00:0661: 47 4E 45 44 
   525                        ALIGNED:
   526 00:0665: 4C F5 0C                     jmp     NEXT                    ; Done
   527                        
   528                        ; CELL+ ( a-addr1 -- a-addr2 )
   529                        ;
   530                        ; Add the size in address units of a cell to a-addr1, giving a-addr2.
   531                        
   532 00:0668: 5A 06 00                     HEADER  NORMAL
   533 00:066B: 05 43 45 4C                  db      5,"CELL+"
       00:066F: 4C 2B 
   534                        CELL_PLUS:
   535 00:0671: F6 03                        inc     DSTACK+1,x              ; Bump the address by two
   536 00:0673: F6 03                        inc     DSTACK+1,X
   537 00:0675: 4C F5 0C                     jmp     NEXT
   538                        
   539                        ; CELLS ( n1 -- n2 )
   540                        ;
   541                        ; n2 is the size in address units of n1 cells.
   542                        
   543 00:0678: 68 06 00                     HEADER  NORMAL
   544 00:067B: 05 43 45 4C                  db      5,"CELLS"
       00:067F: 4C 53 
   545                        CELLS:
   546 00:0681: 16 03                        asl     DSTACK+1,x              ; Two bytes per cell
   547 00:0683: 4C F5 0C                     jmp     NEXT
   548                        
   549                        ; CHAR+ ( c-addr1 -- c-addr2 )
   550                        ;
   551                        ; Add the size in address units of a character to c-addr1, giving c-addr2.
   552                        
  Thu Nov 19 2015 21:53                                                                                                    Page 13


   553 00:0686: 78 06 00                     HEADER  NORMAL
   554 00:0689: 05 43 48 41                  db      5,"CHAR+"
       00:068D: 52 2B 
   555                        CHAR_PLUS:
   556 00:068F: F6 03                        inc     DSTACK+1,x              ; Bump the address by one
   557 00:0691: 4C F5 0C                     jmp     NEXT
   558                        
   559                        ; CHARS ( n1 -- n2 )
   560                        ;
   561                        ; n2 is the size in address units of n1 characters.
   562                        
   563 00:0694: 86 06 00                     HEADER  NORMAL
   564 00:0697: 05 43 48 41                  db      5,"CHARS"
       00:069B: 52 53 
   565                        CHARS:
   566 00:069D: 4C F5 0C                     jmp     NEXT
   567                        
   568                        ;==============================================================================
   569                        ; Stack Operations
   570                        ;------------------------------------------------------------------------------
   571                        
   572                        ; 2DROP ( x1 x2 -- )
   573                        ;
   574                        ; Drop cell pair x1 x2 from the stack.
   575                        
   576 00:06A0: 94 06 00                     HEADER  NORMAL
   577 00:06A3: 05 32 44 52                  db      5,"2DROP"
       00:06A7: 4F 50 
   578                        TWO_DROP:
   579 00:06A9: E8                           inx
   580 00:06AA: E8                           inx
   581 00:06AB: E8                           inx
   582 00:06AC: E8                           inx
   583 00:06AD: 4C F5 0C                     jmp     NEXT
   584                        
   585                        ; 2DUP ( x1 x2 -- x1 x2 x1 x2 )
   586                        ;
   587                        ; Duplicate cell pair x1 x2.
   588                        
   589 00:06B0: A0 06 00                     HEADER  NORMAL
   590 00:06B3: 04 32 44 55                  db      4,"2DUP"
       00:06B7: 50 
   591                        TWO_DUP:
   592 00:06B8: B5 03                        lda     DSTACK+1,x              ; Fetch the top value
   593 00:06BA: CA                           dex                             ; Make space for new values
   594 00:06BB: CA                           dex
   595 00:06BC: CA                           dex
   596 00:06BD: CA                           dex
   597 00:06BE: 95 03                        sta     DSTACK+1,x              ; Make two copies
   598 00:06C0: 95 05                        sta     DSTACK+3,x
   599 00:06C2: 4C F5 0C                     jmp     NEXT
   600                        
   601                        ; 2OVER ( x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2 )
   602                        ;
   603                        ; Copy cell pair x1 x2 to the top of the stack.
   604                        
   605 00:06C5: B0 06 00                     HEADER  NORMAL
   606 00:06C8: 05 32 4F 56                  db      5,"2OVER"
  Thu Nov 19 2015 21:53                                                                                                    Page 14


       00:06CC: 45 52 
   607                        TWO_OVER:
   608 00:06CE: B5 09                        lda     DSTACK+7,x              ; Copy over x1
   609 00:06D0: CA                           dex
   610 00:06D1: CA                           dex
   611 00:06D2: 95 03                        sta     DSTACK+1,x
   612 00:06D4: B5 09                        lda     DSTACK+7,x              ; Copy over x2
   613 00:06D6: CA                           dex
   614 00:06D7: CA                           dex
   615 00:06D8: 95 03                        sta     DSTACK+1,x
   616 00:06DA: 4C F5 0C                     jmp     NEXT                    ; Done
   617                        
   618                        ; 2ROT
   619                        
   620                        ; 2SWAP ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
   621                        ;
   622                        ; Exchange the top two cell pairs.
   623                        
   624 00:06DD: C5 06 00                     HEADER  NORMAL
   625 00:06E0: 05 32 53 57                  db      5,"2SWAP"
       00:06E4: 41 50 
   626                        TWO_SWAP:
   627 00:06E6: B5 05                        lda     DSTACK+3,x              ; Save x3
   628 00:06E8: 48                           pha
   629 00:06E9: B5 03                        lda     DSTACK+1,x              ; Save x4
   630 00:06EB: B5 09                        lda     DSTACK+7,x              ; Move x1
   631 00:06ED: 95 05                        sta     DSTACK+3,x
   632 00:06EF: B5 07                        lda     DSTACK+5,x              ; Move x2
   633 00:06F1: 95 03                        sta     DSTACK+1,x
   634 00:06F3: 68                           pla                             ; Move x4
   635 00:06F4: 95 07                        sta     DSTACK+5,x
   636 00:06F6: 68                           pla                             ; Move x3
   637 00:06F7: 95 09                        sta     DSTACK+7,x
   638 00:06F9: 4C F5 0C                     jmp     NEXT                    ; Done
   639                        
   640                        ; ?DUP ( x -- 0 | x x )
   641                        ;
   642                        ; Duplicate x if it is non-zero.
   643                        
   644 00:06FC: DD 06 00                     HEADER  NORMAL
   645 00:06FF: 04 3F 44 55                  db      4,"?DUP"
       00:0703: 50 
   646                        QUERY_DUP:
   647 00:0704: B5 03                        lda     DSTACK+1,x              ; Fetch top value
   648 00:0706: F0 04                        beq     QUERY_DUP_1             ; Non-zero value?
   649 00:0708: CA                           dex
   650 00:0709: CA                           dex
   651 00:070A: 95 03                        sta     DSTACK+1,x              ; Push a copy
   652 00:070C: 4C F5 0C     QUERY_DUP_1:    jmp     NEXT                    ; Done
   653                        
   654                        ; DROP ( x -- )
   655                        ;
   656                        ; Remove x from the stack.
   657                        
   658 00:070F: FC 06 00                     HEADER  NORMAL
   659 00:0712: 04 44 52 4F                  db      4,"DROP"
       00:0716: 50 
   660                        DROP:
  Thu Nov 19 2015 21:53                                                                                                    Page 15


   661 00:0717: E8                           inx                             ; Drop the top value
   662 00:0718: E8                           inx
   663 00:0719: 4C F5 0C                     jmp     NEXT                    ; Done
   664                        
   665                        ; DUP ( x -- x x )
   666                        ;
   667                        ; Duplicate x.
   668                        
   669 00:071C: 0F 07 00                     HEADER  NORMAL
   670 00:071F: 03 44 55 50                  db      3,"DUP"
   671                        DUP:
   672 00:0723: B5 03                        lda     DSTACK+1,x              ; Fetch top value
   673 00:0725: CA                           dex                             ; And make a copy
   674 00:0726: CA                           dex
   675 00:0727: 95 03                        sta     DSTACK+1,x
   676 00:0729: 4C F5 0C                     jmp     NEXT                    ; Done
   677                        
   678                        ; NIP ( x1 x2 -- x2 )
   679                        ;
   680                        ; Drop the first item below the top of stack.
   681                        
   682 00:072C: 1C 07 00                     HEADER  NORMAL
   683 00:072F: 03 4E 49 50                  db      3,"NIP"
   684                        NIP:
   685 00:0733: B5 03                        lda     DSTACK+1,x              ; Copy x2 over x1
   686 00:0735: 95 05                        sta     DSTACK+3,x
   687 00:0737: E8                           inx                             ; Clean up the stack
   688 00:0738: E8                           inx
   689 00:0739: 4C F5 0C                     jmp     NEXT
   690                        
   691                        ; OVER ( x1 x2 -- x1 x2 x1 )
   692                        ;
   693                        ; Place a copy of x1 on top of the stack.
   694                        
   695 00:073C: 2C 07 00                     HEADER  NORMAL
   696 00:073F: 04 4F 56 45                  db      4,"OVER"
       00:0743: 52 
   697                        OVER:
   698 00:0744: B5 05                        lda     DSTACK+3,x              ; Fetch second value
   699 00:0746: CA                           dex                             ; And make a copy
   700 00:0747: CA                           dex
   701 00:0748: 95 03                        sta     DSTACK+1,x
   702 00:074A: 4C F5 0C                     jmp     NEXT                    ; Done
   703                        
   704                        ; SWAP ( x1 x2 -- x2 x1 )
   705                        ;
   706                        ; Exchange the top two stack items.
   707                        
   708 00:074D: 3C 07 00                     HEADER  NORMAL
   709 00:0750: 04 53 57 41                  db      4,"SWAP"
       00:0754: 50 
   710                        SWAP:
   711 00:0755: B5 03                        lda     DSTACK+1,x              ; Fetch top of stack
   712 00:0757: 48                           pha                             ; .. and save
   713 00:0758: B5 05                        lda     DSTACK+3,x              ; Exchange second
   714 00:075A: 95 03                        sta     DSTACK+1,x              ; .. and top
   715 00:075C: 68                           pla                             ; Recover top
   716 00:075D: 95 05                        sta     DSTACK+3,x              ; .. and save as second
  Thu Nov 19 2015 21:53                                                                                                    Page 16


   717 00:075F: 4C F5 0C                     jmp     NEXT                    ; Done
   718                        
   719                        ; ROT
   720                        ; ROLL
   721                        
   722                        ; TUCK ( x1 x2 -- x2 x1 x2 )
   723                        ;
   724                        ; Copy the first (top) stack item below the second stack item.
   725                        
   726 00:0762: 4D 07 00                     HEADER  NORMAL
   727 00:0765: 04 54 55 43                  db      4,"TUCK"
       00:0769: 4B 
   728 00:076A: 4C F0 0C     TUCK:           jmp     DO_COLON
   729 00:076D: 55 07                        dw      SWAP
   730 00:076F: 44 07                        dw      OVER
   731 00:0771: 42 0A                        dw      EXIT
   732                        
   733                        ;==============================================================================
   734                        ; Return Stack Operations
   735                        ;------------------------------------------------------------------------------
   736                        
   737                        ; 2>R ( x1 x2 -- ) ( R: -- x1 x2 )
   738                        ;
   739                        ; Transfer cell pair x1 x2 to the return stack. Semantically equivalent to
   740                        ; SWAP >R >R.
   741                        
   742 00:0773: 62 07 00                     HEADER  NORMAL
   743 00:0776: 03 32 3E 52                  db      3,"2>R"
   744                        TWO_TO_R:
   745 00:077A: B5 05                        lda     DSTACK+3,x              ; Transfer x1
   746 00:077C: 48                           pha
   747 00:077D: B5 03                        lda     DSTACK+1,x              ; Transfer x2
   748 00:077F: 48                           pha
   749 00:0780: E8                           inx                             ; Clean up data stack
   750 00:0781: E8                           inx
   751 00:0782: E8                           inx
   752 00:0783: E8                           inx
   753 00:0784: 4C F5 0C                     jmp     NEXT                    ; Done
   754                        
   755                        ; 2R> ( -- x1 x2 ) ( R: x1 x2 -- )
   756                        ;
   757                        ; Transfer cell pair x1 x2 from the return stack. Semantically equivalent to R>
   758                        ; R> SWAP.
   759                        
   760 00:0787: 73 07 00                     HEADER  NORMAL
   761 00:078A: 03 32 52 3E                  db      3,"2R>"
   762                        TWO_R_FROM:
   763 00:078E: CA                           dex                             ; Make space for values
   764 00:078F: CA                           dex
   765 00:0790: CA                           dex
   766 00:0791: CA                           dex
   767 00:0792: 68                           pla                             ; Transfer x2
   768 00:0793: 95 03                        sta     DSTACK+1,x
   769 00:0795: 68                           pla                             ; Transfer x1
   770 00:0796: 95 05                        sta     DSTACK+3,x
   771 00:0798: 4C F5 0C                     jmp     NEXT                    ; Done
   772                        
   773                        ; 2R@ ( -- x1 x2 ) ( R: x1 x2 -- x1 x2 )
  Thu Nov 19 2015 21:53                                                                                                    Page 17


   774                        ;
   775                        ; Copy cell pair x1 x2 from the return stack. Semantically equivalent to R> R>
   776                        ; 2DUP >R >R SWAP.
   777                        
   778 00:079B: 87 07 00                     HEADER  NORMAL
   779 00:079E: 03 32 52 40                  db      3,"2R@"
   780                        TWO_R_FETCH:
   781 00:07A2: CA                           dex                             ; Make space for values
   782 00:07A3: CA                           dex
   783 00:07A4: CA                           dex
   784 00:07A5: CA                           dex
   785 00:07A6: A3 01                        lda     1,s                     ; Transfer x2
   786 00:07A8: 95 03                        sta     DSTACK+1,x
   787 00:07AA: A3 03                        lda     3,s                     ; Transfer x1
   788 00:07AC: 95 05                        sta     DSTACK+3,x
   789 00:07AE: 4C F5 0C                     jmp     NEXT                    ; Done
   790                        
   791                        ; >R ( x -- ) ( R: -- x )
   792                        ;
   793                        ; Move x to the return stack.
   794                        
   795 00:07B1: 9B 07 00                     HEADER  NORMAL
   796 00:07B4: 02 3E 52                     db      2,">R"
   797                        TO_R:
   798 00:07B7: B5 03                        lda     DSTACK+1,x              ; Transfer top value
   799 00:07B9: 48                           pha                             ; .. to return stack
   800 00:07BA: E8                           inx
   801 00:07BB: E8                           inx
   802 00:07BC: 4C F5 0C                     jmp     NEXT                    ; Done
   803                        
   804                        ; I ( -- n|u ) ( R: loop-sys -- loop-sys )
   805                        ;
   806                        ; n|u is a copy of the current (innermost) loop index. An ambiguous condition
   807                        ; exists if the loop control parameters are unavailable.
   808                        
   809 00:07BF: B1 07 00                     HEADER  NORMAL
   810 00:07C2: 01 49                        db      1,"I"
   811                        I:
   812 00:07C4: A3 01                        lda     1,s
   813 00:07C6: CA                           dex
   814 00:07C7: CA                           dex
   815 00:07C8: 95 03                        sta     DSTACK+1,x
   816 00:07CA: 4C F5 0C                     jmp     NEXT
   817                        
   818                        ; J ( -- n|u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
   819                        ;
   820                        ; n|u is a copy of the next-outer loop index. An ambiguous condition exists if
   821                        ; the loop control parameters of the next-outer loop, loop-sys1, are
   822                        ; unavailable.
   823                        
   824 00:07CD: BF 07 00                     HEADER  NORMAL
   825 00:07D0: 01 4A                        db      1,"J"
   826                        J:
   827 00:07D2: A3 03                        lda     3,s
   828 00:07D4: CA                           dex
   829 00:07D5: CA                           dex
   830 00:07D6: 95 03                        sta     DSTACK+1,x
   831 00:07D8: 4C F5 0C                     jmp     NEXT
  Thu Nov 19 2015 21:53                                                                                                    Page 18


   832                        
   833                        ; R> ( -- x ) ( R: x -- )
   834                        ;
   835                        ; Move x from the return stack to the data stack.
   836                        
   837 00:07DB: CD 07 00                     HEADER  NORMAL
   838 00:07DE: 02 52 3E                     db      2,"R>"
   839                        R_FROM:
   840 00:07E1: 68                           pla                             ; Fetch return stack value
   841 00:07E2: CA                           dex                             ; And push
   842 00:07E3: CA                           dex
   843 00:07E4: 95 03                        sta     DSTACK+1,X
   844 00:07E6: 4C F5 0C                     jmp     NEXT                    ; Done
   845                        
   846                        ; R@ ( -- x ) ( R: x -- x )
   847                        ;
   848                        ; Copy x from the return stack to the data stack.
   849                        
   850 00:07E9: DB 07 00                     HEADER  NORMAL
   851 00:07EC: 02 52 40                     db      2,"R@"
   852                        R_FETCH:
   853 00:07EF: A3 01                        lda     1,s
   854 00:07F1: CA                           dex
   855 00:07F2: CA                           dex
   856 00:07F3: 95 03                        sta     DSTACK+1,x
   857 00:07F5: 4C F5 0C                     jmp     NEXT
   858                        
   859                        ; ROT ( x1 x2 x3 -- x2 x3 x1 )
   860                        ;
   861                        ; Rotate the top three stack entries.
   862                        
   863 00:07F8: E9 07 00                     HEADER  NORMAL
   864 00:07FB: 03 52 4F 54                  db      3,"ROT"
   865 00:07FF: B5 07        ROT:            lda     DSTACK+5,x              ; Save x1
   866 00:0801: 48                           pha
   867 00:0802: B5 05                        lda     DSTACK+3,x              ; Move x2,x3 up
   868 00:0804: 95 07                        sta     DSTACK+5,x
   869 00:0806: B5 03                        lda     DSTACK+1,x
   870 00:0808: 95 05                        sta     DSTACK+3,x
   871 00:080A: 68                           pla                             ; Recover x1
   872 00:080B: 95 03                        sta     DSTACK+1,x
   873 00:080D: 4C F5 0C                     jmp     NEXT                    ; Done
   874                        
   875                        ;==============================================================================
   876                        ; Single Precision Arithmetic
   877                        ;------------------------------------------------------------------------------
   878                        
   879                        ; * ( n1|u1 n2|u2 -- n3|u3 )
   880                        ;
   881                        ; Multiply n1|u1 by n2|u2 giving the product n3|u3.
   882                        
   883 00:0810: F8 07 00                     HEADER  NORMAL
   884 00:0813: 01 2A                        db      1,"*"
   885                        STAR:
   886 00:0815: 4C F5 0C                     jmp     NEXT                    ; Done
   887                        
   888                        ; */
   889                        ; */MOD
  Thu Nov 19 2015 21:53                                                                                                    Page 19


   890                        
   891                        
   892                        ; + ( n1|u1 n2|u2 -- n3|u3 )
   893                        ;
   894                        ; Add n2|u2 to n1|u1, giving the sum n3|u3.
   895                        
   896 00:0818: 10 08 00                     HEADER  NORMAL
   897 00:081B: 01 2B                        db      1,"+"
   898                        PLUS:
   899 00:081D: 18                           clc                             ; Add top two values
   900 00:081E: B5 03                        lda     DSTACK+1,x
   901 00:0820: 75 05                        adc     DSTACK+3,x
   902 00:0822: 95 05                        sta     DSTACK+3,x              ; Save result
   903 00:0824: E8                           inx                             ; Clean up data stack
   904 00:0825: E8                           inx
   905 00:0826: 4C F5 0C                     JMP     NEXT                    ; Done
   906                        
   907                        ; - ( n1|u1 n2|u2 -- n3|u3 )
   908                        ;
   909                        ; Subtract n2|u2 from n1|u1, giving the difference n3|u3.
   910                        
   911 00:0829: 18 08 00                     HEADER  NORMAL
   912 00:082C: 01 2D                        db      1,"-"
   913                        MINUS:
   914 00:082E: 38                           sec                             ; Subtract top two values
   915 00:082F: B5 03                        lda     DSTACK+1,x
   916 00:0831: F5 05                        sbc     DSTACK+3,x
   917 00:0833: 95 05                        sta     DSTACK+3,x              ; Save result
   918 00:0835: E8                           inx                             ; Clean up data stack
   919 00:0836: E8                           inx
   920 00:0837: 4C F5 0C                     jmp     NEXT                    ; Done
   921                        
   922                        ; /
   923                        ; /MOD
   924                        
   925                        ; 1+ ( n1|u1 -- n2|u2 )
   926                        ;
   927                        ; Add one (1) to n1|u1 giving the sum n2|u2.
   928                        
   929 00:083A: 29 08 00                     HEADER  NORMAL
   930 00:083D: 02 31 2B                     db      2,"1+"
   931                        ONE_PLUS:
   932 00:0840: F6 03                        inc     DSTACK+1,x              ; Increment top of stack
   933 00:0842: 4C F5 0C                     jmp     NEXT                    ; Done
   934                        
   935                        ; 1- ( n1|u1 -- n2|u2 )
   936                        ;
   937                        ; Subtract one (1) from n1|u1 giving the difference n2|u2.
   938                        
   939 00:0845: 3A 08 00                     HEADER  NORMAL
   940 00:0848: 02 31 2D                     db      2,"1-"
   941                        ONE_MINUS:
   942 00:084B: D6 03                        dec     DSTACK+1,x              ; Decrement top of stack
   943 00:084D: 4C F5 0C                     jmp     NEXT                    ; Done
   944                        
   945                        ; 2* ( x1 -- x2 )
   946                        ;
   947                        ; x2 is the result of shifting x1 one bit toward the most-significant bit,
  Thu Nov 19 2015 21:53                                                                                                    Page 20


   948                        ; filling the vacated least-significant bit with zero.
   949                        
   950 00:0850: 45 08 00                     HEADER  NORMAL
   951 00:0853: 02 32 2A                     db      2,"2*"
   952                        TWO_STAR:
   953 00:0856: 16 03                        asl     DSTACK+1,x              ; Multiply top value by two
   954 00:0858: 4C F5 0C                     jmp     NEXT                    ; Done
   955                        
   956                        ; 2/ ( x1 -- x2 )
   957                        ;
   958                        ; x2 is the result of shifting x1 one bit toward the least-significant bit,
   959                        ; leaving the most-significant bit unchanged.
   960                        
   961 00:085B: 50 08 00                     HEADER  NORMAL
   962 00:085E: 02 32 2F                     db      2,"2/"
   963                        TWO_SLASH:
   964 00:0861: B5 03                        lda     DSTACK+1,x              ; Load the top value
   965 00:0863: 2A                           rol     a                       ; Extract the top bit
   966 00:0864: 76 03                        ror     DSTACK+1,x              ; And shift back into value
   967 00:0866: 4C F5 0C                     jmp     NEXT
   968                        
   969                        ; ABS ( n -- u )
   970                        ;
   971                        ; u is the absolute value of n.
   972                        
   973 00:0869: 5B 08 00                     HEADER  NORMAL
   974 00:086C: 03 41 42 53                  db      3,"ABS"
   975                        ABS:
   976 00:0870: 38                           sec                             ; Assume to is negative
   977 00:0871: A9 00 00                     lda     #0
   978 00:0874: F5 03                        sbc     DSTACK+1,x              ; Invert it
   979 00:0876: 30 02                        bmi     ABS_1                   ; Correct assumption?
   980 00:0878: 95 03                        sta     DSTACK+1,x              ; Yes, same the result
   981 00:087A: 4C F5 0C     ABS_1           jmp     NEXT                    ; Done
   982                        
   983                        ; MAX
   984                        ; MIN
   985                        ; MOD
   986                        
   987                        ; NEGATE ( n1 -- n2 )
   988                        ;
   989                        ; Negate n1, giving its arithmetic inverse n2.
   990                        
   991 00:087D: 69 08 00                     HEADER  NORMAL
   992 00:0880: 06 4E 45 47                  db      6,"NEGATE"
       00:0884: 41 54 45 
   993                        NEGATE:
   994 00:0887: 38                           sec                             ; Negate the top of stack
   995 00:0888: A9 00 00                     lda     #0
   996 00:088B: F5 03                        sbc     DSTACK+1,x
   997 00:088D: 95 03                        sta     DSTACK+1,x
   998 00:088F: 4C F5 0C                     jmp     NEXT                    ; Done
   999                        
  1000                        ; UMAX
  1001                        
  1002 00:0892: 7D 08 00                     HEADER  NORMAL
  1003 00:0895: 04 55 4D 41                  db      4,"UMAX"
       00:0899: 58 
  Thu Nov 19 2015 21:53                                                                                                    Page 21


  1004                        UMAX:
  1005 00:089A: B5 03                        lda     DSTACK+1,x              ; Compare the top values
  1006 00:089C: D5 05                        cmp     DSTACK+3,x
  1007 00:089E: B0 03                        bcs     $+5                     ; Is x2 biggest?
  1008 00:08A0: 4C 17 07                     jmp     DROP                    ; No, x1 is
  1009 00:08A3: 4C 33 07                     jmp     NIP
  1010                        
  1011                        ; UMIN
  1012                        
  1013 00:08A6: 92 08 00                     HEADER  NORMAL
  1014 00:08A9: 04 55 4D 49                  db      4,"UMIN"
       00:08AD: 4E 
  1015                        UMIN:
  1016 00:08AE: B5 03                        lda     DSTACK+1,x              ; Compare the top values
  1017 00:08B0: D5 05                        cmp     DSTACK+3,x
  1018 00:08B2: 90 03                        bcc     $+5                     ; Is x2 smallest?
  1019 00:08B4: 4C 17 07                     jmp     DROP                    ; No, x1 is
  1020 00:08B7: 4C 33 07                     jmp     NIP
  1021                        
  1022                        ;==============================================================================
  1023                        ; Double Precision Arithmetic
  1024                        ;------------------------------------------------------------------------------
  1025                        
  1026                        ; D+
  1027                        ; D-
  1028                        ; DNEGATE
  1029                        
  1030                        ;==============================================================================
  1031                        ; Mixed Arithmetic
  1032                        ;------------------------------------------------------------------------------
  1033                        
  1034                        
  1035                        ; D>S ( d -- n )
  1036                        ;
  1037                        ; n is the equivalent of d. An ambiguous condition exists if d lies outside the
  1038                        ; range of a signed single-cell number.
  1039                        
  1040 00:08BA: A6 08 00                     HEADER  NORMAL
  1041 00:08BD: 03 44 3E 53                  db      3,"D>S"
  1042                        D_TO_S:
  1043 00:08C1: E8                           inx                             ; Drop the high word
  1044 00:08C2: E8                           inx
  1045 00:08C3: 4C F5 0C                     jmp     NEXT
  1046                        
  1047                        ; S>D ( n -- d )
  1048                        ;
  1049                        ; Convert the number n to the double-cell number d with the same numerical
  1050                        ; value.
  1051                        
  1052 00:08C6: BA 08 00                     HEADER  NORMAL
  1053 00:08C9: 03 53 3E 44                  db      3,"S>D"
  1054                        S_TO_D:
  1055 00:08CD: CA                           dex                             ; Assume n is positive
  1056 00:08CE: CA                           dex
  1057 00:08CF: 74 03                        stz     DSTACK+1,x              ; .. push a zero value
  1058 00:08D1: 34 05                        bit     DSTACK+3,x              ; Test the number
  1059 00:08D3: 10 02                        bpl     S_TO_D_1
  1060 00:08D5: D6 03                        dec     DSTACK+1,x              ; Make top -1 if negative
  Thu Nov 19 2015 21:53                                                                                                    Page 22


  1061 00:08D7: 4C F5 0C     S_TO_D_1        jmp     NEXT                    ; Done
  1062                        
  1063                        ;==============================================================================
  1064                        ; Comparisons
  1065                        ;------------------------------------------------------------------------------
  1066                        
  1067                        ; 0< ( n -- flag )
  1068                        ;
  1069                        ; flag is true if and only if n is less than zero.
  1070                        
  1071 00:08DA: C6 08 00                     HEADER  NORMAL
  1072 00:08DD: 02 30 3C                     db      2,"0<"
  1073                        ZERO_LESS:
  1074 00:08E0: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1075 00:08E2: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1076 00:08E4: 10 03                        bpl     $+5                     ; Was the value negative?
  1077 00:08E6: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1078 00:08E8: 4C F5 0C                     jmp     NEXT                    ; Done
  1079                        
  1080                        ; 0<> ( x -- flag )
  1081                        ;
  1082                        ; flag is true if and only if x is not equal to zero.
  1083                        
  1084 00:08EB: DA 08 00                     HEADER  NORMAL
  1085 00:08EE: 03 30 3C 3E                  db      3,"0<>"
  1086                        ZERO_NOT_EQUAL:
  1087 00:08F2: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1088 00:08F4: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1089 00:08F6: F0 03                        beq     $+5                     ; Was the value non-zero?
  1090 00:08F8: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1091 00:08FA: 4C F5 0C                     jmp     NEXT                    ; Done
  1092                        
  1093                        ; 0= ( x -- flag )
  1094                        ;
  1095                        ; flag is true if and only if x is equal to zero.
  1096                        
  1097 00:08FD: EB 08 00                     HEADER  NORMAL
  1098 00:0900: 02 30 3D                     db      2,"0="
  1099                        ZERO_EQUAL:
  1100 00:0903: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1101 00:0905: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1102 00:0907: D0 03                        bne     $+5                     ; Was the value zero?
  1103 00:0909: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1104 00:090B: 4C F5 0C                     jmp     NEXT                    ; Done
  1105                        
  1106                        ; 0> ( n -- flag )
  1107                        ;
  1108                        ; flag is true if and only if n is greater than zero.
  1109                        
  1110 00:090E: FD 08 00                     HEADER  NORMAL
  1111 00:0911: 02 30 3E                     db      2,"0>"
  1112                        ZERO_GREATER:
  1113 00:0914: B5 03                        lda     DSTACK+1,x              ; Test top of stack
  1114 00:0916: 74 03                        stz     DSTACK+1,x              ; Assume false result
  1115 00:0918: 30 05                        bmi     $+7                     ; Was the value positive?
  1116 00:091A: F0 03                        beq     $+5                     ; .. but not zero
  1117 00:091C: D6 03                        dec     DSTACK+1,x              ; Yes, make true result
  1118 00:091E: 4C F5 0C                     jmp     NEXT                    ; Done
  Thu Nov 19 2015 21:53                                                                                                    Page 23


  1119                        
  1120                        ; <
  1121                        
  1122                        ; <>
  1123                        
  1124 00:0921: 0E 09 00                     HEADER  NORMAL
  1125 00:0924: 02 3C 3E                     db      2,"<>"
  1126                        NOT_EQUAL:
  1127 00:0927: B5 03                        lda     DSTACK+1,x              ; Pull x2 from stack
  1128 00:0929: E8                           inx
  1129 00:092A: E8                           inx
  1130 00:092B: D5 03                        cmp     DSTACK+1,x              ; Compare with x1
  1131 00:092D: 74 03                        stz     DSTACK+1,x              ; Assume equal
  1132 00:092F: F0 03                        beq     $+5                     ; Test flags
  1133 00:0931: D6 03                        dec     DSTACK+1,x              ; Make result true
  1134 00:0933: 4C F5 0C                     jmp     NEXT                    ; Done
  1135                        
  1136                        ; = ( x1 x2 -- flag )
  1137                        ;
  1138                        ; flag is true if and only if x1 is bit-for-bit the same as x2.
  1139                        
  1140 00:0936: 21 09 00                     HEADER  NORMAL
  1141 00:0939: 01 3D                        db      1,"="
  1142                        EQUAL:
  1143 00:093B: B5 03                        lda     DSTACK+1,x              ; Pull x2 from stack
  1144 00:093D: E8                           inx
  1145 00:093E: E8                           inx
  1146 00:093F: D5 03                        cmp     DSTACK+1,x              ; Compare with x1
  1147 00:0941: 74 03                        stz     DSTACK+1,x              ; Assume not equal
  1148 00:0943: D0 03                        bne     $+5                     ; Test the flags
  1149 00:0945: F6 03                        inc     DSTACK+1,x              ; Make result true
  1150 00:0947: 4C F5 0C                     jmp     NEXT                    ; Done
  1151                        
  1152                        ; >
  1153                        
  1154                        ; U<
  1155                        ; U>
  1156                        
  1157                        ;==============================================================================
  1158                        ; Logical Operations
  1159                        ;------------------------------------------------------------------------------
  1160                        
  1161                        ; AND ( x1 x2 -- x3 )
  1162                        ;
  1163                        ; x3 is the bit-by-bit logical “and” of x1 with x2.
  1164                        
  1165 00:094A: 36 09 00                     HEADER  NORMAL
  1166 00:094D: 03 41 4E 44                  db      3,"AND"
  1167                        AND:
  1168 00:0951: B5 03                        lda     DSTACK+1,x
  1169 00:0953: 35 05                        and     DSTACK+3,x
  1170 00:0955: 95 05                        sta     DSTACK+3,x
  1171 00:0957: E8                           inx
  1172 00:0958: E8                           inx
  1173 00:0959: 4C F5 0C                     jmp     NEXT
  1174                        
  1175                        ; INVERT ( x1 -- x2 )
  1176                        ;
  Thu Nov 19 2015 21:53                                                                                                    Page 24


  1177                        ; Invert all bits of x1, giving its logical inverse x2.
  1178                        
  1179 00:095C: 4A 09 00                     HEADER  NORMAL
  1180 00:095F: 06 49 4E 56                  db      6,"INVERT"
       00:0963: 45 52 54 
  1181                        INVERT:
  1182 00:0966: B5 03                        lda     DSTACK+1,x              ; Fetch top value
  1183 00:0968: 49 FF FF                     eor     #$ffff                  ; Invert all the bits
  1184 00:096B: 95 03                        sta     DSTACK+1,x              ; .. and write back
  1185 00:096D: 4C F5 0C                     jmp     NEXT                    ; Done
  1186                        
  1187                        ; LSHIFT ( x1 u -- x2 )
  1188                        ;
  1189                        ; Perform a logical left shift of u bit-places on x1, giving x2. Put zeroes
  1190                        ; into the least significant bits vacated by the shift. An ambiguous condition
  1191                        ; exists if u is greater than or equal to the number of bits in a cell.
  1192                        
  1193 00:0970: 5C 09 00                     HEADER  NORMAL
  1194 00:0973: 06 4C 53 48                  db      6,"LSHIFT"
       00:0977: 49 46 54 
  1195                        LSHIFT:
  1196 00:097A: B5 03                        lda     DSTACK+1,x              ; Pull bit count
  1197 00:097C: 08                           php
  1198 00:097D: E8                           inx                             ; .. from the stack
  1199 00:097E: E8                           inx
  1200 00:097F: 28                           plp
  1201 00:0980: F0 0A                        beq     LSHIFT_0                ; Zero shift?
  1202 00:0982: C9 10 00                     cmp     #16                     ; Shifting by 16+ bits
  1203 00:0985: B0 08                        bcs     LSHIFT_2                ; Yes, result will be zero
  1204 00:0987: 16 03        LSHIFT_1        asl     DSTACK+1,x              ; Shift one bit left
  1205 00:0989: 3A                           dec     a                       ; Update count
  1206 00:098A: D0 FB                        bne     LSHIFT_1                ; .. and repeat as needed
  1207 00:098C: 4C F5 0C     LSHIFT_0        jmp     NEXT                    ; Done
  1208 00:098F: 74 03        LSHIFT_2        stz     DSTACK+1,x              ; Clear top value
  1209 00:0991: 4C F5 0C                     jmp     NEXT                    ; Done
  1210                        
  1211                        ; OR ( x1 x2 -- x3 )
  1212                        ;
  1213                        ; x3 is the bit-by-bit inclusive-or of x1 with x2.
  1214                        
  1215 00:0994: 70 09 00                     HEADER  NORMAL
  1216 00:0997: 02 4F 52                     db      2,"OR"
  1217                        OR:
  1218 00:099A: B5 03                        lda     DSTACK+1,x
  1219 00:099C: 15 05                        ora     DSTACK+3,x
  1220 00:099E: 95 05                        sta     DSTACK+3,x
  1221 00:09A0: E8                           inx
  1222 00:09A1: E8                           inx
  1223 00:09A2: 4C F5 0C                     jmp     NEXT
  1224                        
  1225                        ; RSHIFT ( x1 u -- x2 )
  1226                        ;
  1227                        ; Perform a logical right shift of u bit-places on x1, giving x2. Put zeroes
  1228                        ; into the most significant bits vacated by the shift. An ambiguous condition
  1229                        ; exists if u is greater than or equal to the number of bits in a cell.
  1230                        
  1231 00:09A5: 94 09 00                     HEADER  NORMAL
  1232 00:09A8: 06 52 53 48                  db      6,"RSHIFT"
  Thu Nov 19 2015 21:53                                                                                                    Page 25


       00:09AC: 49 46 54 
  1233                        RSHIFT:
  1234 00:09AF: B5 03                        lda     DSTACK+1,x              ; Pull bit count
  1235 00:09B1: 08                           php
  1236 00:09B2: E8                           inx                             ; .. from the stack
  1237 00:09B3: E8                           inx
  1238 00:09B4: 28                           plp
  1239 00:09B5: F0 0A                        beq     RSHIFT_0                ; Zero shift?
  1240 00:09B7: C9 10 00                     cmp     #16                     ; Shifting by 16+ bits
  1241 00:09BA: B0 08                        bcs     RSHIFT_2                ; Yes, result will be zero
  1242 00:09BC: 56 03        RSHIFT_1        lsr     DSTACK+1,x              ; Shift one bit left
  1243 00:09BE: 3A                           dec     a                       ; Update count
  1244 00:09BF: D0 FB                        bne     RSHIFT_1                ; .. and repeat as needed
  1245 00:09C1: 4C F5 0C     RSHIFT_0        jmp     NEXT                    ; Done
  1246 00:09C4: 74 03        RSHIFT_2        stz     DSTACK+1,x              ; Clear top value
  1247 00:09C6: 4C F5 0C                     jmp     NEXT                    ; Done
  1248                        
  1249                        ; XOR ( x1 x2 -- x3 )
  1250                        ;
  1251                        ; x3 is the bit-by-bit exclusive-or of x1 with x2.
  1252                        
  1253 00:09C9: A5 09 00                     HEADER  NORMAL
  1254 00:09CC: 03 58 4F 52                  db      3,"XOR"
  1255                        XOR:
  1256 00:09D0: B5 03                        lda     DSTACK+1,x
  1257 00:09D2: 55 05                        eor     DSTACK+3,x
  1258 00:09D4: 95 05                        sta     DSTACK+3,x
  1259 00:09D6: E8                           inx
  1260 00:09D7: E8                           inx
  1261 00:09D8: 4C F5 0C                     jmp     NEXT
  1262                        
  1263                        ;==============================================================================
  1264                        ; Control Words
  1265                        ;------------------------------------------------------------------------------
  1266                        
  1267                        ; ABORT ( i*x -- ) ( R: j*x -- )
  1268                        ;
  1269                        ; Empty the data stack and perform the function of QUIT, which includes
  1270                        ; emptying the return stack, without displaying a message.
  1271                        
  1272 00:09DB: C9 09 00                     HEADER  NORMAL
  1273 00:09DE: 05 41 42 4F                  db      5,"ABORT"
       00:09E2: 52 54 
  1274 00:09E4: 4C F0 0C     ABORT:          jmp     DO_COLON
  1275 00:09E7: EB 09                        dw      DO_ABORT
  1276 00:09E9: 4E 0A                        dw      QUIT
  1277                        
  1278                        DO_ABORT:
  1279 00:09EB: A2 81 00                     ldx     #DSTACK_INIT
  1280 00:09EE: 4C F5 0C                     jmp     NEXT
  1281                        
  1282                        ; (BUILD) ( dtc-addr -- )
  1283                        ;
  1284                        ; Adds a jump the to exection function for the new word.
  1285                        
  1286 00:09F1: DB 09 00                     HEADER  NORMAL
  1287 00:09F4: 07 28 42 55                  db      7,"(BUILD)"
       00:09F8: 49 4C 44 29 
  Thu Nov 19 2015 21:53                                                                                                    Page 26


  1288 00:09FC: 4C F0 0C     BUILD:          jmp     DO_COLON
  1289 00:09FF: BE 0D 4C 00                  dw      DO_LITERAL,$4c,C_COMMA
       00:0A03: 13 06 
  1290 00:0A05: 95 05 42 0A                  dw      COMMA,EXIT
  1291                        
  1292                        ; CREATE ( -- )
  1293                        ;
  1294                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1295                        ; definition for name with the execution semantics defined below. If the data-
  1296                        ; space pointer is not aligned, reserve enough data space to align it. The new
  1297                        ; data-space pointer defines name’s data field. CREATE does not allocate data
  1298                        ; space in name’s data field.
  1299                        
  1300 00:0A09: F1 09 00                     HEADER  NORMAL
  1301 00:0A0C: 06 43 52 45                  db      6,"CREATE"
       00:0A10: 41 54 45 
  1302 00:0A13: 4C F0 0C     CREATE:         jmp     DO_COLON
  1303                                        ; parse
  1304 00:0A16: 45 06 A7 04                  dw      HERE,LATEST,FETCH,COMMA
       00:0A1A: D5 05 95 05 
  1305 00:0A1E: FC 04 13 06                  dw      ZERO,C_COMMA,LATEST,STORE
       00:0A22: A7 04 66 05 
  1306                                        ; move name
  1307 00:0A26: 42 0A                        dw      EXIT
  1308                                        
  1309                        ; EXECUTE
  1310                        
  1311 00:0A28: 09 0A 00                     HEADER  NORMAL
  1312 00:0A2B: 07 45 58 45                  db      7,"EXECUTE"
       00:0A2F: 43 55 54 45 
  1313                        EXECUTE:
  1314 00:0A33: B5 03                        lda     DSTACK+1,x
  1315 00:0A35: E8                           inx
  1316 00:0A36: E8                           inx
  1317 00:0A37: 3A                           dec     a
  1318 00:0A38: 48                           pha
  1319 00:0A39: 60                           rts
  1320                        
  1321                        ; EXIT ( -- ) ( R: nest-sys -- )
  1322                        
  1323 00:0A3A: 28 0A 00                     HEADER  NORMAL
  1324 00:0A3D: 04 45 58 49                  db      4,"EXIT"
       00:0A41: 54 
  1325                        EXIT:
  1326 00:0A42: 7A                           ply
  1327 00:0A43: 4C F5 0C                     jmp     NEXT
  1328                        
  1329                        ; QUIT ( -- ) ( R: i*x -- )
  1330                        ;
  1331                        ; Empty the return stack, store zero in SOURCE-ID if it is present, make the
  1332                        ; user input device the input source, and enter interpretation state. Do not
  1333                        ; display a message. Repeat the following:
  1334                        ; – Accept a line from the input source into the input buffer, set >IN to zero,
  1335                        ;   and interpret.
  1336                        ; – Display the implementation-defined system prompt if in interpretation state,
  1337                        ;   all processing has been completed, and no ambiguous condition exists.
  1338                        ;
  1339                        ; In this implementation it is defined as:
  Thu Nov 19 2015 21:53                                                                                                    Page 27


  1340                        ;
  1341                        ;   DO_QUIT 0 STATE !
  1342                        ;   0 (SOURCE-ID) !
  1343                        ;   BEGIN
  1344                        ;       REFILL
  1345                        ;       WHILE SOURCE EVALUATE
  1346                        ;       STATE @ 0= IF CR S" OK" TYPE THEN
  1347                        ;   AGAIN ;
  1348                        
  1349 00:0A46: 3A 0A 00                     HEADER  NORMAL
  1350 00:0A49: 04 51 55 49                  db      4,"QUIT"
       00:0A4D: 54 
  1351 00:0A4E: 4C F0 0C     QUIT:           jmp     DO_COLON
  1352 00:0A51: 7B 0A                        dw      DO_QUIT
  1353 00:0A53: FC 04 E6 04                  dw      ZERO,STATE,STORE
       00:0A57: 66 05 
  1354 00:0A59: FC 04 D8 04                  dw      ZERO,SOURCEID,STORE
       00:0A5D: 66 05 
  1355 00:0A5F: 9B 0B 8C 0D  QUIT_1:         dw      REFILL,QUERY_BRANCH,QUIT_2
       00:0A63: 67 0A 
  1356 00:0A65: 31 0B                        dw      INTERPRET
  1357 00:0A67: E6 04 D5 05  QUIT_2:         dw      STATE,FETCH,ZERO_EQUAL
       00:0A6B: 03 09 
  1358 00:0A6D: 8C 0D 77 0A                  dw      QUERY_BRANCH,QUIT_3
  1359 00:0A71: 4E 0E                        dw      DO_S_QUOTE
  1360 00:0A73: 02 4F 6B E0                  db      2,"Ok",TYPE
  1361 00:0A77: 7A 0D 5F 0A  QUIT_3:         dw      BRANCH,QUIT_1
  1362                        
  1363                        DO_QUIT:
  1364 00:0A7B: A9 FF 01                     lda     #RSTACK_INIT            ; Reset the return stack
  1365 00:0A7E: 1B                           tcs
  1366 00:0A7F: 4C F5 0C                     jmp     NEXT                    ; Done
  1367                        
  1368                        ;==============================================================================
  1369                        ; Parser & Interpreter
  1370                        ;------------------------------------------------------------------------------
  1371                        
  1372                        ; ?NUMBER
  1373                        
  1374 00:0A82: 46 0A 00                     HEADER  NORMAL
  1375 00:0A85: 07 3F 4E 55                  db      7,"?NUMBER"
       00:0A89: 4D 42 45 52 
  1376 00:0A8D: F0           QUERY_NUMBER:   db      DO_COLON
  1377                        
  1378 00:0A8E: 42 0A                        dw      EXIT
  1379                        
  1380                        ; ACCEPT ( c-addr +n1 -- +n2 )
  1381                        ;
  1382                        ; Receive a string of at most +n1 characters. An ambiguous condition exists if
  1383                        ; +n1 is zero or greater than 32,767. Display graphic characters as they are
  1384                        ; received. A program that depends on the presence or absence of non-graphic
  1385                        ; characters in the string has an environmental dependency. The editing
  1386                        ; functions, if any, that the system performs in order to construct the string
  1387                        ; are implementation-defined.
  1388                        ;
  1389                        ; Input terminates when an implementation-defined line terminator is received.
  1390                        ; When input terminates, nothing is appended to the string, and the display is
  1391                        ; maintained in an implementation-defined way.
  Thu Nov 19 2015 21:53                                                                                                    Page 28


  1392                        ;
  1393                        ; +n2 is the length of the string stored at c-addr.
  1394                        ;
  1395                        ;   OVER + 1- OVER      -- sa ea a
  1396                        ;   BEGIN KEY           -- sa ea a c
  1397                        ;   DUP 0D <> WHILE
  1398                        ;       DUP EMIT        -- sa ea a c
  1399                        ;       DUP 8 = IF  DROP 1-
  1400                        ;             >R OVER R> UMAX
  1401                        ;             ELSE  OVER C! 1+ OVER UMIN
  1402                        ;       THEN            -- sa ea a
  1403                        ;   REPEAT              -- sa ea a c
  1404                        ;   DROP NIP SWAP - ;
  1405                        
  1406 00:0A90: 82 0A 00                     HEADER  NORMAL
  1407 00:0A93: 06 41 43 43                  db      6,"ACCEPT"
       00:0A97: 45 50 54 
  1408 00:0A9A: 4C F0 0C     ACCEPT:         jmp     DO_COLON
  1409 00:0A9D: 44 07 1D 08                  dw      OVER,PLUS,ONE_MINUS,OVER
       00:0AA1: 4B 08 44 07 
  1410 00:0AA5: 98 0E 23 07  ACCEPT_1:       dw      KEY,DUP,DO_LITERAL,$0D,NOT_EQUAL
       00:0AA9: BE 0D 0D 00 
       00:0AAD: 27 09 
  1411 00:0AAF: 8C 0D EB 0A                  dw      QUERY_BRANCH,ACCEPT_4
  1412 00:0AB3: 23 07 87 0E                  dw      DUP,EMIT
  1413 00:0AB7: 23 07 BE 0D                  dw      DUP,DO_LITERAL,$08,EQUAL
       00:0ABB: 08 00 3B 09 
  1414 00:0ABF: 44 07 BE 0D                  dw      OVER,DO_LITERAL,$7f,EQUAL,OR
       00:0AC3: 7F 00 3B 09 
       00:0AC7: 9A 09 
  1415 00:0AC9: 8C 0D DD 0A                  dw      QUERY_BRANCH,ACCEPT_2
  1416 00:0ACD: 17 07 4B 08                  dw      DROP,ONE_MINUS
  1417 00:0AD1: B7 07 44 07                  dw      TO_R,OVER,R_FROM,UMAX,BRANCH,ACCEPT_3
       00:0AD5: E1 07 9A 08 
       00:0AD9: 7A 0D E7 0A 
  1418 00:0ADD: 44 07 F9 05  ACCEPT_2:       dw      OVER,C_STORE,ONE_PLUS,OVER,UMIN
       00:0AE1: 40 08 44 07 
       00:0AE5: AE 08 
  1419 00:0AE7: 7A 0D A5 0A  ACCEPT_3:       dw      BRANCH,ACCEPT_1
  1420 00:0AEB: 17 07 33 07  ACCEPT_4:       dw      DROP,NIP,SWAP,MINUS,EXIT
       00:0AEF: 55 07 2E 08 
       00:0AF3: 42 0A 
  1421                        
  1422                        ; EVALUATE ( i*x c-addr u -- j*x )
  1423                        ;
  1424                        ; Save the current input source specification. Store minus-one (-1) in
  1425                        ; SOURCE-ID if it is present. Make the string described by c-addr and u both
  1426                        ; the input source and input buffer, set >IN to zero, and interpret. When the
  1427                        ; parse area is empty, restore the prior input source specification. Other
  1428                        ; stack effects are due to the words EVALUATEd.
  1429                        ;
  1430                        ;   >R >R SAVE-INPUT
  1431                        ;   -1 (SOURCE-ID) !
  1432                        ;   0 >IN ! (LENGTH) ! (BUFFER) !
  1433                        ;   INTERPRET
  1434                        ;   RESTORE-INPUT DROP
  1435                        
  1436 00:0AF5: 90 0A 00                     HEADER  NORMAL
  Thu Nov 19 2015 21:53                                                                                                    Page 29


  1437 00:0AF8: 08 45 56 41                  db      8,"EVALUATE"
       00:0AFC: 4C 55 41 54 
       00:0B00: 45 
  1438 00:0B01: 4C F0 0C     EVALUATE:       jmp     DO_COLON
  1439 00:0B04: B7 07 B7 07                  dw      TO_R,TO_R,SAVE_INPUT
       00:0B08: FE 0B 
  1440 00:0B0A: E1 07 E1 07                  dw      R_FROM,R_FROM
  1441 00:0B0E: 2B 05 D8 04                  dw      TRUE,SOURCEID,STORE
       00:0B12: 66 05 
  1442 00:0B14: FC 04 63 04                  dw      ZERO,TO_IN,STORE
       00:0B18: 66 05 
  1443 00:0B1A: B8 04 66 05                  dw      LENGTH,STORE
  1444 00:0B1E: 8D 04 66 05                  dw      BUFFER,STORE
  1445 00:0B22: 31 0B                        dw      INTERPRET
  1446 00:0B24: D9 0B 17 07                  dw      RESTORE_INPUT,DROP
  1447 00:0B28: 42 0A                        dw      EXIT
  1448                        
  1449                        ; INTERPRET ( -- )
  1450                        ;
  1451                        ;
  1452                        ;   BEGIN
  1453                        ;   BL WORD DUP C@ WHILE        -- textadr
  1454                        ;       FIND                    -- a 0/1/-1
  1455                        ;       ?DUP IF                 -- xt 1/-1
  1456                        ;           1+ STATE @ 0= OR    immed or interp?
  1457                        ;           IF EXECUTE ELSE ,XT THEN
  1458                        ;       ELSE                    -- textadr
  1459                        ;           ?NUMBER
  1460                        ;           IF POSTPONE LITERAL     converted ok
  1461                        ;           ELSE COUNT TYPE 3F EMIT CR ABORT  err
  1462                        ;           THEN
  1463                        ;       THEN
  1464                        ;   REPEAT DROP ;
  1465                        
  1466 00:0B2A: F5 0A 31                     HEADER  INTERPRET
  1467 00:0B2D: 09 00 54 45                  dw      9,"INTERPRET"
  1468 00:0B31: 4C F0 0C     INTERPRET:      jmp     DO_COLON
  1469 00:0B34: 09 05 48 0C  INTERPRET_1:    dw      BL,WORD,DUP,C_FETCH,QUERY_BRANCH,INTERPRET_7
       00:0B38: 23 07 2A 06 
       00:0B3C: 8C 0D 80 0B 
  1470 00:0B40: 8C 0B 04 07                  dw      FIND,QUERY_DUP,QUERY_BRANCH,INTERPRET_4
       00:0B44: 8C 0D 62 0B 
  1471 00:0B48: 40 08 E6 04                  dw      ONE_PLUS,STATE,FETCH,ZERO_EQUAL,OR
       00:0B4C: D5 05 03 09 
       00:0B50: 9A 09 
  1472 00:0B52: 8C 0D 5C 0B                  dw      QUERY_BRANCH,INTERPRET_2,EXECUTE,BRANCH,INTERPRET_3
       00:0B56: 33 0A 7A 0D 
       00:0B5A: 5E 0B 
  1473 00:0B5C: 95 05        INTERPRET_2:    dw      COMMA
  1474 00:0B5E: 7A 0D 7C 0B  INTERPRET_3:    dw      BRANCH,INTERPRET_6
  1475 00:0B62: 8D 0A 8C 0D  INTERPRET_4:    dw      QUERY_NUMBER,QUERY_BRANCH,INTERPRET_5
       00:0B66: 6E 0B 
  1476 00:0B68: A4 0D 7A 0D                  dw      LITERAL,BRANCH,INTERPRET_6
       00:0B6C: 7C 0B 
  1477 00:0B6E: 5A 00 E0 0E  INTERPRET_5:    dw      COUNT,TYPE,DO_LITERAL,$3f,EMIT,CR,ABORT
       00:0B72: BE 0D 3F 00 
       00:0B76: 87 0E 6E 0E 
       00:0B7A: E4 09 
  Thu Nov 19 2015 21:53                                                                                                    Page 30


  1478 00:0B7C: 7A 0D 34 0B  INTERPRET_6     dw      BRANCH,INTERPRET_1
  1479 00:0B80: 17 07 42 0A  INTERPRET_7:    dw      DROP,EXIT
  1480                        
  1481                        ; FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
  1482                        ;
  1483                        ; Find the definition named in the counted string at c-addr. If the definition
  1484                        ; is not found, return c-addr and zero. If the definition is found, return its
  1485                        ; execution token xt. If the definition is immediate, also return one (1),
  1486                        ; otherwise also return minus-one (-1). For a given string, the values returned
  1487                        ; by FIND while compiling may differ from those returned while not compiling.
  1488                        ;
  1489                        ;   LATEST @ BEGIN             -- a nfa
  1490                        ;       2DUP OVER C@ CHAR+     -- a nfa a nfa n+1
  1491                        ;       N=                     -- a nfa f
  1492                        ;       DUP IF
  1493                        ;           DROP
  1494                        ;           NFA>LFA H@ DUP     -- a link link
  1495                        ;       THEN
  1496                        ;   0= UNTIL                   -- a nfa  OR  a 0
  1497                        ;   DUP IF
  1498                        ;       NIP DUP NFA>CFA        -- nfa xt
  1499                        ;       SWAP IMMED?            -- xt iflag
  1500                        ;       0= 1 OR                -- xt 1/-1
  1501                        ;   THEN ;
  1502                        
  1503 00:0B84: 2A 0B 00                     HEADER  NORMAL
  1504 00:0B87: 04 46 49 4E                  db      4,"FIND"
       00:0B8B: 44 
  1505 00:0B8C: 4C F0 0C     FIND:           jmp     DO_COLON
  1506                        
  1507                        
  1508                        
  1509 00:0B8F: 42 0A                        dw      EXIT
  1510                        
  1511                        ; REFILL ( -- flag )
  1512                        ;
  1513                        ; Attempt to fill the input buffer from the input source, returning a true flag
  1514                        ; if successful.
  1515                        ;
  1516                        ; When the input source is the user input device, attempt to receive input into
  1517                        ; the terminal input buffer. If successful, make the result the input buffer,
  1518                        ; set >IN to zero, and return true. Receipt of a line containing no characters
  1519                        ; is considered successful. If there is no input available from the current
  1520                        ; input source, return false.
  1521                        ;
  1522                        ; When the input source is a string from EVALUATE, return false and perform no
  1523                        ; other action.
  1524                        ;
  1525                        ;   SOURCE-ID 0= IF
  1526                        ;    TIB DUP #TIB @ ACCEPT SPACE
  1527                        ;    LENGTH ! BUFFER !
  1528                        ;    0 >IN ! TRUE EXIT
  1529                        ;   THEN
  1530                        ;   FALSE
  1531                        
  1532 00:0B91: 84 0B 00                     HEADER  NORMAL
  1533 00:0B94: 06 52 45 46                  db      6,"REFILL"
       00:0B98: 49 4C 4C 
  Thu Nov 19 2015 21:53                                                                                                    Page 31


  1534 00:0B9B: 4C F0 0C     REFILL:         jmp     DO_COLON
  1535 00:0B9E: D8 04 03 09                  dw      SOURCEID,ZERO_EQUAL,QUERY_BRANCH,REFILL_1
       00:0BA2: 8C 0D C4 0B 
  1536 00:0BA6: F2 04 23 07                  dw      TIB,DUP,HASH_TIB,FETCH,ACCEPT,SPACE
       00:0BAA: 55 04 D5 05 
       00:0BAE: 9A 0A AE 0E 
  1537 00:0BB2: B8 04 66 05                  dw      LENGTH,STORE,BUFFER,STORE
       00:0BB6: 8D 04 66 05 
  1538 00:0BBA: FC 04 63 04                  dw      ZERO,TO_IN,STORE,TRUE,EXIT
       00:0BBE: 66 05 2B 05 
       00:0BC2: 42 0A 
  1539 00:0BC4: 1C 05 42 0A  REFILL_1:       dw      FALSE,EXIT
  1540                        
  1541                        ; RESTORE-INPUT
  1542                        
  1543 00:0BC8: 91 0B 00                     HEADER  NORMAL
  1544 00:0BCB: 0D 52 45 53                  db      13,"RESTORE-INPUT"
       00:0BCF: 54 4F 52 45 
       00:0BD3: 2D 49 4E 50 
       00:0BD7: 55 54 
  1545 00:0BD9: 4C F0 0C     RESTORE_INPUT   jmp     DO_COLON
  1546 00:0BDC: 63 04 66 05                  dw      TO_IN,STORE
  1547 00:0BE0: B8 04 66 05                  dw      LENGTH,STORE
  1548 00:0BE4: 8D 04 66 05                  dw      BUFFER,STORE
  1549 00:0BE8: D8 04 66 05                  dw      SOURCEID,STORE
  1550 00:0BEC: 2B 05 42 0A                  dw      TRUE,EXIT
  1551                        
  1552                        ; SAVE-INPUT
  1553                        
  1554 00:0BF0: C8 0B 00                     HEADER  NORMAL
  1555 00:0BF3: 0A 53 41 56                  db      10,"SAVE-INPUT"
       00:0BF7: 45 2D 49 4E 
       00:0BFB: 50 55 54 
  1556 00:0BFE: 4C F0 0C     SAVE_INPUT:     jmp     DO_COLON
  1557 00:0C01: D8 04 D5 05                  dw      SOURCEID,FETCH
  1558 00:0C05: 8D 04 D5 05                  dw      BUFFER,FETCH
  1559 00:0C09: B8 04 D5 05                  dw      LENGTH,FETCH
  1560 00:0C0D: 63 04 D5 05                  dw      TO_IN,FETCH,EXIT
       00:0C11: 42 0A 
  1561                        
  1562                        ; SOURCE ( -- c-addr u )
  1563                        ;
  1564                        ; c-addr is the address of, and u is the number of characters in, the input
  1565                        ; buffer.
  1566                        ;
  1567                        ; In this implementation it is defined as
  1568                        ;
  1569                        ;   BUFFER @ LENGTH @
  1570                        
  1571 00:0C13: F0 0B 00                     HEADER  NORMAL
  1572 00:0C16: 06 53 4F 55                  db      6,"SOURCE"
       00:0C1A: 52 43 45 
  1573 00:0C1D: 4C F0 0C     SOURCE:         jmp     DO_COLON
  1574 00:0C20: 8D 04 D5 05                  dw      BUFFER,FETCH
  1575 00:0C24: B8 04 D5 05                  dw      LENGTH,FETCH
  1576 00:0C28: 42 0A                        dw      EXIT
  1577                        
  1578                        ; SOURCE-ID ( -- 0 | -1 )
  Thu Nov 19 2015 21:53                                                                                                    Page 32


  1579                        ;
  1580                        ; Identifies the input source: -1 if string (via EVALUATE), 0 if user input
  1581                        ; device.
  1582                        
  1583 00:0C2A: 13 0C 00                     HEADER  NORMAL
  1584 00:0C2D: 09 53 4F 55                  db      9,"SOURCE-ID"
       00:0C31: 52 43 45 2D 
       00:0C35: 49 44 
  1585 00:0C37: 4C F0 0C     SOURCE_ID:      jmp     DO_COLON
  1586 00:0C3A: D8 04 D5 05                  dw      SOURCEID,FETCH,EXIT
       00:0C3E: 42 0A 
  1587                        
  1588                        ; WORD
  1589                        ;
  1590                        ;   DUP  SOURCE >IN @ /STRING   -- c c adr n
  1591                        ;   DUP >R   ROT SKIP           -- c adr' n'
  1592                        ;   OVER >R  ROT SCAN           -- adr" n"
  1593                        ;   DUP IF CHAR- THEN        skip trailing delim.
  1594                        ;   R> R> ROT -   >IN +!        update >IN offset
  1595                        ;   TUCK -                      -- adr' N
  1596                        ;   HERE >counted               --
  1597                        ;   HERE                        -- a
  1598                        ;   BL OVER COUNT + C! ;    append trailing blank
  1599                        
  1600 00:0C40: 2A 0C 00                     HEADER  NORMAL
  1601 00:0C43: 04 57 4F 52                  db      4,"WORD"
       00:0C47: 44 
  1602 00:0C48: 4C F0 0C     WORD:           jmp     DO_COLON
  1603 00:0C4B: 23 07 1D 0C                  dw      DUP,SOURCE,TO_IN,FETCH,SLASH_STRING
       00:0C4F: 63 04 D5 05 
       00:0C53: 8C 0C 
  1604 00:0C55: 23 07 B7 07                  dw      DUP,TO_R,ROT,SKIP
       00:0C59: FF 07 67 0C 
  1605 00:0C5D: 44 07 B7 07                  dw      OVER,TO_R,ROT,SCAN
       00:0C61: FF 07 6C 0C 
  1606                        
  1607 00:0C65: 42 0A                        dw      EXIT
  1608                        
  1609 00:0C67: 4C F0 0C     SKIP:           jmp     DO_COLON
  1610                        
  1611 00:0C6A: 42 0A                        dw      EXIT
  1612                        
  1613 00:0C6C: 4C F0 0C     SCAN:           jmp     DO_COLON
  1614                        
  1615 00:0C6F: 42 0A                        dw      EXIT
  1616                        
  1617                        ;==============================================================================
  1618                        ; String Words
  1619                        ;------------------------------------------------------------------------------
  1620                        
  1621                        ; -TRAILING
  1622                        
  1623 00:0C71: 40 0C 00                     HEADER  NORMAL
  1624 00:0C74: 09 2D 54 52                  db      9,"-TRAILING"
       00:0C78: 41 49 4C 49 
       00:0C7C: 4E 47 
  1625 00:0C7E: 4C F0 0C     DASH_TRAILING:  jmp     DO_COLON
  1626                        
  Thu Nov 19 2015 21:53                                                                                                    Page 33


  1627                        ; /STRING ( c-addr1 u1 n -- c-addr2 u2 )
  1628                        ;
  1629                        ; Adjust the character string at c-addr1 by n characters. The resulting
  1630                        ; character string, specified by c-addr2 u2, begins at c-addr1 plus n;
  1631                        ; characters and is u1 minus n characters long.
  1632                        ;
  1633                        ;   ROT OVER + ROT ROT -
  1634                        
  1635 00:0C81: 71 0C 00                     HEADER  NORMAL
  1636 00:0C84: 07 2F 53 54                  db      7,"/STRING"
       00:0C88: 52 49 4E 47 
  1637 00:0C8C: 4C F0 0C     SLASH_STRING:   jmp     DO_COLON
  1638 00:0C8F: FF 07 44 07                  dw      ROT,OVER,PLUS
       00:0C93: 1D 08 
  1639 00:0C95: FF 07 FF 07                  dw      ROT,ROT,MINUS,EXIT
       00:0C99: 2E 08 42 0A 
  1640                        
  1641                        ; BLANK
  1642                        
  1643                        ; CMOVE ( c-addr1 c-addr2 u -- )
  1644                        ;
  1645                        ; If u is greater than zero, copy u consecutive characters from the data space
  1646                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1647                        ; character from lower addresses to higher addresses.
  1648                        
  1649 00:0C9D: 81 0C 00     		HEADER	NORMAL
  1650 00:0CA0: 05 43 4D 4F  		db	5,"CMOVE"
       00:0CA4: 56 45 
  1651                        CMOVE:
  1652 00:0CA6: B5 03        		lda	DSTACK+1,x		; Any data to move?
  1653 00:0CA8: D0 03        		bne	$+5
  1654 00:0CAA: 4C F5 0C     		jmp	NEXT			; Done
  1655 00:0CAD: E2 20        		short_a
  1656 00:0CAF: A1 07        		lda	(DSTACK+5,x)		; Move a byte
  1657 00:0CB1: 81 05        		sta	(DSTACK+3,x)
  1658 00:0CB3: C2 20        		long_a
  1659 00:0CB5: F6 07        		inc	DSTACK+5,x		; Adjust the address
  1660 00:0CB7: F6 05        		inc	DSTACK+3,x
  1661 00:0CB9: D6 03        		dec	DSTACK+1,x		; Adjust the count
  1662 00:0CBB: 80 E9        		bra	CMOVE			; And try again
  1663                        
  1664                        ; CMOVE> ( c-addr1 c-addr2 u -- )
  1665                        ;
  1666                        ; If u is greater than zero, copy u consecutive characters from the data space
  1667                        ; starting at c-addr1 to that starting at c-addr2, proceeding character-by-
  1668                        ; character from higher addresses to lower addresses.
  1669                        
  1670 00:0CBD: 9D 0C 00     		HEADER	NORMAL
  1671 00:0CC0: 06 43 4D 4F  		db	6,"CMOVE>"
       00:0CC4: 56 45 3E 
  1672                        CMOVE_GREATER:
  1673 00:0CC7: 4C F5 0C     		jmp	NEXT
  1674                        
  1675                        ; COMPARE
  1676                        
  1677                        ; SEARCH
  1678                        
  1679                        
  Thu Nov 19 2015 21:53                                                                                                    Page 34


  1680                        ;==============================================================================
  1681                        ; Compiling Words
  1682                        ;------------------------------------------------------------------------------
  1683                        
  1684                        ; +LOOP ( -- )
  1685                        
  1686 00:0CCA: BD 0C 80                     HEADER  IMMEDIATE
  1687 00:0CCD: 05 2B 4C 4F                  db      5,"+LOOP"
       00:0CD1: 4F 50 
  1688 00:0CD3: 4C F0 0C     PLUS_LOOP:      jmp     DO_COLON
  1689                        
  1690 00:0CD6: 42 0A                        dw      EXIT
  1691                        
  1692                        ; (+LOOP)
  1693                        
  1694 00:0CD8: CA 0C 00                     HEADER  NORMAL
  1695 00:0CDB: 07 28 2B 4C                  db      7,"(+LOOP)"
       00:0CDF: 4F 4F 50 29 
  1696                        DO_PLUS_LOOP:
  1697                        
  1698 00:0CE3: 4C F5 0C                     jmp     NEXT
  1699                        
  1700                        ; : ( -- )
  1701                        
  1702 00:0CE6: D8 0C 00                     HEADER  NORMAL
  1703 00:0CE9: 01 3A                        db      1,":"
  1704 00:0CEB: 4C F0 0C     COLON:          jmp     DO_COLON
  1705                        
  1706 00:0CEE: 42 0A                        dw      EXIT
  1707                        
  1708                        DO_COLON:
  1709 00:0CF0: 5A                           phy                             ; Save the instruction pointer
  1710 00:0CF1: A8                           tay                             ; Calculate the new IP
  1711 00:0CF2: C8                           iny
  1712 00:0CF3: C8                           iny
  1713 00:0CF4: C8                           iny
  1714                        NEXT:
  1715 00:0CF5: B9 00 00                     lda     0,y                     ; Fetch the next word address
  1716 00:0CF8: 85 00                        sta     WA
  1717 00:0CFA: C8                           iny                             ; Bump the instruction pointer
  1718 00:0CFB: C8                           iny
  1719 00:0CFC: 6C 00 00                     jmp     (!WA)                   ; And execute word
  1720                        
  1721                        ; AGAIN
  1722                        
  1723 00:0CFF: E6 0C 80                     HEADER  IMMEDIATE
  1724 00:0D02: 05 00 4E 49                  dw      5,"AGAIN"
  1725 00:0D06: 4C F0 0C     AGAIN:          jmp     DO_COLON
  1726                        
  1727 00:0D09: 42 0A                        dw      EXIT
  1728                        
  1729                        ; BEGIN
  1730                        
  1731 00:0D0B: FF 0C 80                     HEADER  IMMEDIATE
  1732 00:0D0E: 05 00 4E 49                  dw      5,"BEGIN"
  1733 00:0D12: 4C F0 0C     BEGIN:          jmp     DO_COLON
  1734                        
  1735 00:0D15: 42 0A                        dw      EXIT
  Thu Nov 19 2015 21:53                                                                                                    Page 35


  1736                        
  1737                        ; CONSTANT ( x “<spaces>name” -- )
  1738                        ;
  1739                        ; Skip leading space delimiters. Parse name delimited by a space. Create a
  1740                        ; definition for name with the execution semantics defined below.
  1741                        
  1742 00:0D17: 0B 0D 00                     HEADER  NORMAL
  1743 00:0D1A: 08 43 4F 4E                  db      8,"CONSTANT"
       00:0D1E: 53 54 41 4E 
       00:0D22: 54 
  1744 00:0D23: 4C F0 0C     CONSTANT:       jmp     DO_COLON
  1745 00:0D26: 13 0A                        dw      CREATE
  1746 00:0D28: BE 0D 40 0D                  dw      DO_LITERAL,DO_CONSTANT,BUILD
       00:0D2C: FC 09 
  1747 00:0D2E: 95 05 42 0A                  dw      COMMA,EXIT
  1748                        
  1749                        ; (CONSTANT) ( -- x )
  1750                        
  1751 00:0D32: 17 0D 00                     HEADER  NORMAL
  1752 00:0D35: 0A 28 43 4F                  db      10,"(CONSTANT)"
       00:0D39: 4E 53 54 41 
       00:0D3D: 4E 54 29 
  1753                        DO_CONSTANT:
  1754 00:0D40: 5A                           phy                             ; Save IP
  1755 00:0D41: A8                           tay                             ; Fetch constant after WA
  1756 00:0D42: B9 03 00                     lda     3,y
  1757 00:0D45: CA                           dex                             ; And push
  1758 00:0D46: CA                           dex
  1759 00:0D47: 95 03                        sta     DSTACK+1,x
  1760 00:0D49: 7A                           ply
  1761 00:0D4A: 4C F5 0C                     jmp     NEXT                    ; Done
  1762                        
  1763                        ; DO ( -- )
  1764                        
  1765 00:0D4D: 32 0D 80                     HEADER  IMMEDIATE
  1766 00:0D50: 02 44 4F                     db      2,"DO"
  1767 00:0D53: 4C F0 0C     DO:             jmp     DO_COLON
  1768                        
  1769 00:0D56: 42 0A                        dw      EXIT
  1770                        
  1771                        ; (DO) ( -- )
  1772                        
  1773 00:0D58: 4D 0D 00                     HEADER  NORMAL
  1774 00:0D5B: 04 28 44 4F                  db      4,"(DO)"
       00:0D5F: 29 
  1775                        DO_DO:
  1776 00:0D60: B5 05                        lda     DSTACK+3,x
  1777 00:0D62: 48                           pha
  1778 00:0D63: B5 03                        lda     DSTACK+1,x
  1779 00:0D65: 48                           pha
  1780 00:0D66: E8                           inx
  1781 00:0D67: E8                           inx
  1782 00:0D68: E8                           inx
  1783 00:0D69: E8                           inx
  1784 00:0D6A: 4C F5 0C                     jmp     NEXT
  1785                        
  1786                        ; ELSE
  1787                        
  Thu Nov 19 2015 21:53                                                                                                    Page 36


  1788 00:0D6D: 58 0D 80                     HEADER  IMMEDIATE
  1789 00:0D70: 04 45 4C 53                  db      4,"ELSE"
       00:0D74: 45 
  1790 00:0D75: 4C F0 0C     ELSE:           jmp     DO_COLON
  1791                        
  1792 00:0D78: 42 0A                        dw      EXIT
  1793                        
  1794                        ; (BRANCH) ( -- )
  1795                        ;
  1796                        ; Cause the IP to be loaded with the word following the link to this word.
  1797                        
  1798                        BRANCH:
  1799 00:0D7A: B9 00 00                     lda     0,y                     ; Load branch address into IP
  1800 00:0D7D: A8                           tay
  1801 00:0D7E: 4C F5 0C                     jmp     NEXT                    ; Done
  1802                        
  1803                        
  1804                        
  1805                        ; IF
  1806                        
  1807 00:0D81: 6D 0D 80                     HEADER  IMMEDIATE
  1808 00:0D84: 02 49 46                     db      2,"IF"
  1809 00:0D87: 4C F0 0C     IF:             jmp     DO_COLON
  1810                        
  1811 00:0D8A: 42 0A                        dw      EXIT
  1812                        
  1813                        ; (?BRANCH) ( flag -- )
  1814                        ;
  1815                        ; If flag is false then cause the IP to be loaded with the word following the
  1816                        ; link to this word, otherwise skip over it.
  1817                        
  1818                        QUERY_BRANCH:
  1819 00:0D8C: B5 03                        lda     DSTACK+1,x              ; Pull the top of stack value
  1820 00:0D8E: 08                           php                             ; Save the flags
  1821 00:0D8F: E8                           inx                             ; Drop top item
  1822 00:0D90: E8                           inx
  1823 00:0D91: 28                           plp
  1824 00:0D92: F0 E6                        beq     BRANCH                  ; Branch if top was zero
  1825 00:0D94: C8                           iny                             ; Otherwise skip address
  1826 00:0D95: C8                           iny
  1827 00:0D96: 4C F5 0C                     jmp     NEXT                    ; Done
  1828                        
  1829                        ; LITERAL ( x -- )
  1830                        ;
  1831                        ; Append the run-time semantics given below to the current definition.
  1832                        
  1833 00:0D99: 81 0D 80                     HEADER  IMMEDIATE
  1834 00:0D9C: 07 4C 49 54                  db      7,"LITERAL"
       00:0DA0: 45 52 41 4C 
  1835 00:0DA4: 4C F0 0C     LITERAL:        jmp     DO_COLON
  1836 00:0DA7: BE 0D BE 0D                  dw      DO_LITERAL,DO_LITERAL,COMMA
       00:0DAB: 95 05 
  1837 00:0DAD: 95 05 42 0A                  dw      COMMA,EXIT
  1838                        
  1839                        ; (LITERAL) ( -- x )
  1840                        ;
  1841                        ; Place x on the stack.
  1842                        
  Thu Nov 19 2015 21:53                                                                                                    Page 37


  1843 00:0DB1: 99 0D 00                     HEADER  NORMAL
  1844 00:0DB4: 0A 28 4C 49                  db      10,"(LITERAL)"
       00:0DB8: 54 45 52 41 
       00:0DBC: 4C 29 
  1845                        DO_LITERAL:
  1846 00:0DBE: B9 00 00                     lda     0,y                     ; Fetch constant from IP
  1847 00:0DC1: C8                           iny
  1848 00:0DC2: C8                           iny
  1849 00:0DC3: CA                           dex                             ; And push
  1850 00:0DC4: CA                           dex
  1851 00:0DC5: 95 03                        sta     DSTACK+1,x
  1852 00:0DC7: 4C F5 0C                     jmp     NEXT                    ; Done
  1853                        
  1854                        ; LOOP
  1855                        
  1856 00:0DCA: B1 0D 80                     HEADER  IMMEDIATE
  1857 00:0DCD: 04 4C 4F 4F                  db      4,"LOOP"
       00:0DD1: 50 
  1858 00:0DD2: 4C F0 0C     LOOP:           jmp     DO_COLON
  1859                        
  1860 00:0DD5: 42 0A                        dw      EXIT
  1861                        
  1862                        ; (LOOP)
  1863                        
  1864 00:0DD7: CA 0D 00                     HEADER  NORMAL
  1865 00:0DDA: 06 28 4C 4F                  db      6,"(LOOP)"
       00:0DDE: 4F 50 29 
  1866                        DO_LOOP
  1867 00:0DE1: A3 01                        lda     1,s                     ; Add one to loop counter
  1868 00:0DE3: 1A                           inc     a
  1869 00:0DE4: 83 01                        sta     1,s
  1870 00:0DE6: C3 03                        cmp     3,s                     ; Reached limit?
  1871 00:0DE8: B0 07                        bcs     DO_LOOP_END             ; Yes
  1872 00:0DEA: B9 00 00                     lda     0,y                     ; No, branch back to start
  1873 00:0DED: A8                           tay
  1874 00:0DEE: 4C F5 0C                     jmp     NEXT                    ; Done
  1875 00:0DF1: C8           DO_LOOP_END:    iny                             ; Skip over address
  1876 00:0DF2: C8                           iny
  1877 00:0DF3: 4C F5 0C                     jmp     NEXT                    ; Done
  1878                        
  1879                        ; USER
  1880                        
  1881 00:0DF6: D7 0D 00                     HEADER  NORMAL
  1882 00:0DF9: 04 55 53 45                  db      4,"USER"
       00:0DFD: 52 
  1883 00:0DFE: 4C F0 0C     USER:           jmp     DO_COLON
  1884                        
  1885 00:0E01: 42 0A                        dw      EXIT
  1886                        
  1887 00:0E03: F6 0D 00                     HEADER  NORMAL
  1888 00:0E06: 06 28 55 53                  db      6,"(USER)"
       00:0E0A: 45 52 29 
  1889                        DO_USER:
  1890 00:0E0D: 5A                           phy                             ; Save the IP
  1891 00:0E0E: A8                           tay                             ; Fetch offset after WA
  1892 00:0E0F: B9 03 00                     lda     3,y
  1893 00:0E12: 18                           clc                             ; Work out address in user area
  1894 00:0E13: 69 10 02                     adc     #USER_AREA
  Thu Nov 19 2015 21:53                                                                                                    Page 38


  1895 00:0E16: CA                           dex                             ; Push on data stack
  1896 00:0E17: CA                           dex
  1897 00:0E18: 95 03                        sta     DSTACK+1,x
  1898 00:0E1A: 7A                           ply                             ; Restore IP
  1899 00:0E1B: 4C F5 0C                     jmp     NEXT                    ; Done
  1900                        
  1901                        ; VARIABLE
  1902                        
  1903 00:0E1E: 03 0E 00                     HEADER  NORMAL
  1904 00:0E21: 08 56 41 52                  db      8,"VARIABLE"
       00:0E25: 49 41 42 4C 
       00:0E29: 45 
  1905 00:0E2A: 4C F0 0C     VARIABLE:       jmp     DO_COLON
  1906                        
  1907 00:0E2D: 42 0A                        dw      EXIT
  1908                        
  1909 00:0E2F: 1E 0E 00                     HEADER  NORMAL
  1910 00:0E32: 0A 28 56 41                  db      10,"(VARIABLE)"
       00:0E36: 52 49 41 42 
       00:0E3A: 4C 45 29 
  1911                        DO_VARIABLE:
  1912 00:0E3D: 18                           clc
  1913 00:0E3E: 69 03 00                     adc     #3
  1914 00:0E41: CA                           dex
  1915 00:0E42: CA                           dex
  1916 00:0E43: 95 03                        sta     DSTACK+1,x
  1917 00:0E45: 4C F5 0C                     jmp     NEXT
  1918                        
  1919                        
  1920                        
  1921                        
  1922                        
  1923 00:0E48: 2F 0E 80                     HEADER  IMMEDIATE
  1924 00:0E4B: 02 53 22                     db      2,"S",'"'
  1925                        S_QUOTE:
  1926                        
  1927                        ; (S") ( -- c-addr u )
  1928                        
  1929                        DO_S_QUOTE:
  1930 00:0E4E: CA                           dex                             ; Reserve space for values
  1931 00:0E4F: CA                           dex
  1932 00:0E50: CA                           dex
  1933 00:0E51: CA                           dex
  1934 00:0E52: E2 20                        short_a
  1935 00:0E54: B9 00 00                     lda     0,y                     ; Fetch the length
  1936 00:0E57: C2 20                        long_a
  1937 00:0E59: 29 FF 00                     and     #$00ff
  1938 00:0E5C: 95 03                        sta     DSTACK+1,x
  1939 00:0E5E: C8                           iny                             ; Save the text address
  1940 00:0E5F: 94 05                        sty     DSTACK+3,x
  1941 00:0E61: 18                           clc                             ; And update IP
  1942 00:0E62: 75 05                        adc     DSTACK+3,X
  1943 00:0E64: A8                           tay
  1944 00:0E65: 4C F5 0C                     jmp     NEXT                    ; Done
  1945                        
  1946                        ;==============================================================================
  1947                        ; I/O Operations
  1948                        ;------------------------------------------------------------------------------
  Thu Nov 19 2015 21:53                                                                                                    Page 39


  1949                        
  1950                        ; CR ( -- )
  1951                        ;
  1952                        ; Cause subsequent output to appear at the beginning of the next line.
  1953                        ;
  1954                        ; In this implementation it is defined as
  1955                        ;
  1956                        ;   13 EMIT 10 EMIT
  1957                        
  1958 00:0E68: 48 0E 00                     HEADER  NORMAL
  1959 00:0E6B: 02 43 52                     db      2,"CR"
  1960 00:0E6E: 4C F0 0C     CR:             jmp     DO_COLON
  1961 00:0E71: BE 0D 0D 00                  dw      DO_LITERAL,13,EMIT
       00:0E75: 87 0E 
  1962 00:0E77: BE 0D 0A 00                  dw      DO_LITERAL,10,EMIT
       00:0E7B: 87 0E 
  1963 00:0E7D: 42 0A                        dw      EXIT
  1964                        
  1965                        ; EMIT ( x -- )
  1966                        ;
  1967                        ; If x is a graphic character in the implementation-defined character set,
  1968                        ; display x. The effect of EMIT for all other values of x is implementation
  1969                        ; -defined.
  1970                        
  1971 00:0E7F: 68 0E 00                     HEADER  NORMAL
  1972 00:0E82: 04 45 4D 49                  db      4,"EMIT"
       00:0E86: 54 
  1973                                        extern  UartTx
  1974                        EMIT:
  1975 00:0E87: B5 03                        lda     DSTACK+1,X              ; Fetch character from stack
  1976 00:0E89: 20 xx xx                     jsr     UartTx                  ; .. and transmit
  1977 00:0E8C: E8                           inx                             ; Drop the character
  1978 00:0E8D: E8                           inx
  1979 00:0E8E: 4C F5 0C                     jmp     NEXT                    ; Done
  1980                        
  1981                        ; KEY ( -- char )
  1982                        ;
  1983                        ; Receive one character char, a member of the implementation-defined character
  1984                        ; set. Keyboard events that do not correspond to such characters are discarded
  1985                        ; until a valid character is received, and those events are subsequently
  1986                        ; unavailable.
  1987                        ;
  1988                        ; All standard characters can be received. Characters received by KEY are not
  1989                        ; displayed.
  1990                        
  1991 00:0E91: 7F 0E 00                     HEADER  NORMAL
  1992 00:0E94: 03 4B 45 59                  db      3,"KEY"
  1993                                        extern  UartRx
  1994                        KEY:
  1995 00:0E98: 20 xx xx                     jsr     UartRx                  ; Receive a character
  1996 00:0E9B: 29 FF 00                     and     #$00ff                  ; Ensure in ASCII range
  1997 00:0E9E: CA                           dex                             ; And push to stack
  1998 00:0E9F: CA                           dex
  1999 00:0EA0: 95 03                        sta     DSTACK+1,x
  2000 00:0EA2: 4C F5 0C                     jmp     NEXT                    ; Done
  2001                        
  2002                        ; SPACE ( -- )
  2003                        ;
  Thu Nov 19 2015 21:53                                                                                                    Page 40


  2004                        ; Display one space.
  2005                        ;
  2006                        ; In this implementation it is defined as
  2007                        ;
  2008                        ;   SPACE EMIT
  2009                        
  2010 00:0EA5: 91 0E 00                     HEADER  NORMAL
  2011 00:0EA8: 05 53 50 41                  db      5,"SPACE"
       00:0EAC: 43 45 
  2012 00:0EAE: 4C F0 0C     SPACE:          jmp     DO_COLON
  2013 00:0EB1: 09 05                        dw      BL
  2014 00:0EB3: 87 0E                        dw      EMIT
  2015 00:0EB5: 42 0A                        dw      EXIT
  2016                        
  2017                        ; SPACES ( n -- )
  2018                        ;
  2019                        ; If n is greater than zero, display n spaces.
  2020                        ;
  2021                        ; In this implementation it is defined as
  2022                        ;
  2023                        ;   BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP
  2024                        
  2025 00:0EB7: A5 0E 00                     HEADER  NORMAL
  2026 00:0EBA: 06 53 50 41                  db      6,"SPACES"
       00:0EBE: 43 45 53 
  2027 00:0EC1: 4C F0 0C     SPACES:         jmp     DO_COLON
  2028 00:0EC4: 23 07 14 09  SPACES_1:       dw      DUP,ZERO_GREATER,QUERY_BRANCH,SPACES_2
       00:0EC8: 8C 0D D4 0E 
  2029 00:0ECC: AE 0E 4B 08                  dw      SPACE,ONE_MINUS,BRANCH,SPACES_1
       00:0ED0: 7A 0D C4 0E 
  2030 00:0ED4: 17 07 42 0A  SPACES_2:       dw      DROP,EXIT
  2031                        
  2032                        ; TYPE ( c-addr u -- )
  2033                        ;
  2034                        ; If u is greater than zero, display the character string specified by c-addr
  2035                        ; and u.
  2036                        ;
  2037                        ; In this implementation it is defined as
  2038                        ;
  2039                        ;   ?DUP IF
  2040                        ;     OVER + SWAP DO I C@ EMIT LOOP
  2041                        ;   ELSE DROP THEN
  2042                        
  2043 00:0ED8: B7 0E 00                     HEADER  NORMAL
  2044 00:0EDB: 04 54 59 50                  db      4,"TYPE"
       00:0EDF: 45 
  2045 00:0EE0: 4C F0 0C     TYPE:           jmp     DO_COLON
  2046 00:0EE3: 04 07 8C 0D                  dw      QUERY_DUP,QUERY_BRANCH,TYPE_2
       00:0EE7: FF 0E 
  2047 00:0EE9: 44 07 1D 08                  dw      OVER,PLUS,SWAP,DO_DO
       00:0EED: 55 07 60 0D 
  2048 00:0EF1: C4 07 2A 06  TYPE_1:         dw      I,C_FETCH,EMIT,DO_LOOP,TYPE_1
       00:0EF5: 87 0E E1 0D 
       00:0EF9: F1 0E 
  2049 00:0EFB: 7A 0D 01 0F                  dw      BRANCH,TYPE_3
  2050 00:0EFF: 17 07        TYPE_2          dw      DROP
  2051 00:0F01: 42 0A        TYPE_3          dw      EXIT
  2052                        
  Thu Nov 19 2015 21:53                                                                                                    Page 41


  2053                        ;================================================================================
  2054                        ;--------------------------------------------------------------------------------
  2055                        
  2056                        ; #
  2057                        ; #>
  2058                        ; #S
  2059                        ; SIGN
  2060                        
  2061                        ;================================================================================
  2062                        ;--------------------------------------------------------------------------------
  2063                        
  2064                                        TRAILER
  2065                        NEXT_WORD:
  2066                        
  2067                                        end


      Lines assembled: 2701
      Errors: 0
